// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: model/schema.proto

/*
Package model is a generated protocol buffer package.

It is generated from these files:
	model/schema.proto

It has these top-level messages:
	BusinessAccount
	Topics
	Media
	Address
	DateOfBirth
	ServicesManagedByBlackspace
	PaymentProcessingMethods
	PaymentMedium
	PaymentOptions
	BusinessType
	BusinessCategory
	BusinessSubCategory
	MerchantType
	PhoneNumber
	PhoneType
*/
package model

import context "context"
import fmt "fmt"
import strings "strings"

import errors1 "github.com/infobloxopen/protoc-gen-gorm/errors"
import field_mask1 "google.golang.org/genproto/protobuf/field_mask"
import gorm1 "github.com/jinzhu/gorm"
import gorm2 "github.com/infobloxopen/atlas-app-toolkit/gorm"
import pq1 "github.com/lib/pq"

import math "math"
import _ "github.com/golang/protobuf/ptypes/timestamp"

// Reference imports to suppress errors if they are not otherwise used.
var _ = fmt.Errorf
var _ = math.Inf

type BusinessAccountORM struct {
	AuthnId          uint32
	BusinessGoals    pq1.StringArray `gorm:"type:text[]"`
	BusinessStage    string
	Category         string
	CompanyAddress   string
	CompanyName      string
	Email            string
	Id               uint32 `gorm:"type:serial;primary_key;auto_increment"`
	IsActive         bool
	Media            *MediaORM `gorm:"foreignkey:BusinessAccountId;association_foreignkey:Id;preload:true"`
	Password         string
	SubscribedTopics *TopicsORM `gorm:"foreignkey:BusinessAccountId;association_foreignkey:Id;preload:true"`
}

// TableName overrides the default tablename generated by GORM
func (BusinessAccountORM) TableName() string {
	return "business_accounts"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *BusinessAccount) ToORM(ctx context.Context) (BusinessAccountORM, error) {
	to := BusinessAccountORM{}
	var err error
	if prehook, ok := interface{}(m).(BusinessAccountWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.CompanyName = m.CompanyName
	to.CompanyAddress = m.CompanyAddress
	to.Category = m.Category
	if m.Media != nil {
		tempMedia, err := m.Media.ToORM(ctx)
		if err != nil {
			return to, err
		}
		to.Media = &tempMedia
	}
	to.Password = m.Password
	to.Email = m.Email
	to.IsActive = m.IsActive
	if m.BusinessGoals != nil {
		to.BusinessGoals = make(pq1.StringArray, len(m.BusinessGoals))
		copy(to.BusinessGoals, m.BusinessGoals)
	}
	to.BusinessStage = m.BusinessStage
	if m.SubscribedTopics != nil {
		tempSubscribedTopics, err := m.SubscribedTopics.ToORM(ctx)
		if err != nil {
			return to, err
		}
		to.SubscribedTopics = &tempSubscribedTopics
	}
	to.AuthnId = m.AuthnId
	if posthook, ok := interface{}(m).(BusinessAccountWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *BusinessAccountORM) ToPB(ctx context.Context) (BusinessAccount, error) {
	to := BusinessAccount{}
	var err error
	if prehook, ok := interface{}(m).(BusinessAccountWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.CompanyName = m.CompanyName
	to.CompanyAddress = m.CompanyAddress
	to.Category = m.Category
	if m.Media != nil {
		tempMedia, err := m.Media.ToPB(ctx)
		if err != nil {
			return to, err
		}
		to.Media = &tempMedia
	}
	to.Password = m.Password
	to.Email = m.Email
	to.IsActive = m.IsActive
	if m.BusinessGoals != nil {
		to.BusinessGoals = make(pq1.StringArray, len(m.BusinessGoals))
		copy(to.BusinessGoals, m.BusinessGoals)
	}
	to.BusinessStage = m.BusinessStage
	if m.SubscribedTopics != nil {
		tempSubscribedTopics, err := m.SubscribedTopics.ToPB(ctx)
		if err != nil {
			return to, err
		}
		to.SubscribedTopics = &tempSubscribedTopics
	}
	to.AuthnId = m.AuthnId
	if posthook, ok := interface{}(m).(BusinessAccountWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type BusinessAccount the arg will be the target, the caller the one being converted from

// BusinessAccountBeforeToORM called before default ToORM code
type BusinessAccountWithBeforeToORM interface {
	BeforeToORM(context.Context, *BusinessAccountORM) error
}

// BusinessAccountAfterToORM called after default ToORM code
type BusinessAccountWithAfterToORM interface {
	AfterToORM(context.Context, *BusinessAccountORM) error
}

// BusinessAccountBeforeToPB called before default ToPB code
type BusinessAccountWithBeforeToPB interface {
	BeforeToPB(context.Context, *BusinessAccount) error
}

// BusinessAccountAfterToPB called after default ToPB code
type BusinessAccountWithAfterToPB interface {
	AfterToPB(context.Context, *BusinessAccount) error
}

type TopicsORM struct {
	Art               bool
	Business          bool
	BusinessAccountId *uint32
	Cooking           bool
	Design            bool
	FashionAndStyle   bool
	Food              bool
	Health            bool
	Id                uint32 `gorm:"type:serial;primary_key;auto_increment"`
	Music             bool
	Science           bool
	Technology        bool
	Travel            bool
}

// TableName overrides the default tablename generated by GORM
func (TopicsORM) TableName() string {
	return "topics"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *Topics) ToORM(ctx context.Context) (TopicsORM, error) {
	to := TopicsORM{}
	var err error
	if prehook, ok := interface{}(m).(TopicsWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.Technology = m.Technology
	to.Health = m.Health
	to.Food = m.Food
	to.Science = m.Science
	to.Music = m.Music
	to.Travel = m.Travel
	to.Business = m.Business
	to.Cooking = m.Cooking
	to.FashionAndStyle = m.FashionAndStyle
	to.Design = m.Design
	to.Art = m.Art
	if posthook, ok := interface{}(m).(TopicsWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *TopicsORM) ToPB(ctx context.Context) (Topics, error) {
	to := Topics{}
	var err error
	if prehook, ok := interface{}(m).(TopicsWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.Technology = m.Technology
	to.Health = m.Health
	to.Food = m.Food
	to.Science = m.Science
	to.Music = m.Music
	to.Travel = m.Travel
	to.Business = m.Business
	to.Cooking = m.Cooking
	to.FashionAndStyle = m.FashionAndStyle
	to.Design = m.Design
	to.Art = m.Art
	if posthook, ok := interface{}(m).(TopicsWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type Topics the arg will be the target, the caller the one being converted from

// TopicsBeforeToORM called before default ToORM code
type TopicsWithBeforeToORM interface {
	BeforeToORM(context.Context, *TopicsORM) error
}

// TopicsAfterToORM called after default ToORM code
type TopicsWithAfterToORM interface {
	AfterToORM(context.Context, *TopicsORM) error
}

// TopicsBeforeToPB called before default ToPB code
type TopicsWithBeforeToPB interface {
	BeforeToPB(context.Context, *Topics) error
}

// TopicsAfterToPB called after default ToPB code
type TopicsWithAfterToPB interface {
	AfterToPB(context.Context, *Topics) error
}

type MediaORM struct {
	BusinessAccountId *uint32
	Facebook          string
	Id                uint32 `gorm:"type:serial;primary_key;auto_increment"`
	Instagram         string
	LinkedIn          string
	Pinterest         string
	Website           string
}

// TableName overrides the default tablename generated by GORM
func (MediaORM) TableName() string {
	return "media"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *Media) ToORM(ctx context.Context) (MediaORM, error) {
	to := MediaORM{}
	var err error
	if prehook, ok := interface{}(m).(MediaWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.Website = m.Website
	to.Instagram = m.Instagram
	to.Facebook = m.Facebook
	to.LinkedIn = m.LinkedIn
	to.Pinterest = m.Pinterest
	if posthook, ok := interface{}(m).(MediaWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *MediaORM) ToPB(ctx context.Context) (Media, error) {
	to := Media{}
	var err error
	if prehook, ok := interface{}(m).(MediaWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.Website = m.Website
	to.Instagram = m.Instagram
	to.Facebook = m.Facebook
	to.LinkedIn = m.LinkedIn
	to.Pinterest = m.Pinterest
	if posthook, ok := interface{}(m).(MediaWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type Media the arg will be the target, the caller the one being converted from

// MediaBeforeToORM called before default ToORM code
type MediaWithBeforeToORM interface {
	BeforeToORM(context.Context, *MediaORM) error
}

// MediaAfterToORM called after default ToORM code
type MediaWithAfterToORM interface {
	AfterToORM(context.Context, *MediaORM) error
}

// MediaBeforeToPB called before default ToPB code
type MediaWithBeforeToPB interface {
	BeforeToPB(context.Context, *Media) error
}

// MediaAfterToPB called after default ToPB code
type MediaWithAfterToPB interface {
	AfterToPB(context.Context, *Media) error
}

// DefaultCreateBusinessAccount executes a basic gorm create call
func DefaultCreateBusinessAccount(ctx context.Context, in *BusinessAccount, db *gorm1.DB) (*BusinessAccount, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(BusinessAccountORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(BusinessAccountORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type BusinessAccountORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type BusinessAccountORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm1.DB) error
}

// DefaultReadBusinessAccount executes a basic gorm read call
func DefaultReadBusinessAccount(ctx context.Context, in *BusinessAccount, db *gorm1.DB) (*BusinessAccount, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(BusinessAccountORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm2.ApplyFieldSelection(ctx, db, nil, &BusinessAccountORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(BusinessAccountORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := BusinessAccountORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(BusinessAccountORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type BusinessAccountORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type BusinessAccountORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type BusinessAccountORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm1.DB) error
}

func DefaultDeleteBusinessAccount(ctx context.Context, in *BusinessAccount, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(BusinessAccountORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&BusinessAccountORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(BusinessAccountORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type BusinessAccountORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type BusinessAccountORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm1.DB) error
}

func DefaultDeleteBusinessAccountSet(ctx context.Context, in []*BusinessAccount, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	var err error
	keys := []uint32{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors1.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&BusinessAccountORM{})).(BusinessAccountORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&BusinessAccountORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&BusinessAccountORM{})).(BusinessAccountORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type BusinessAccountORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*BusinessAccount, *gorm1.DB) (*gorm1.DB, error)
}
type BusinessAccountORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*BusinessAccount, *gorm1.DB) error
}

// DefaultStrictUpdateBusinessAccount clears first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateBusinessAccount(ctx context.Context, in *BusinessAccount, db *gorm1.DB) (*BusinessAccount, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateBusinessAccount")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &BusinessAccountORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(BusinessAccountORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	filterMedia := MediaORM{}
	if ormObj.Id == 0 {
		return nil, errors1.EmptyIdError
	}
	filterMedia.BusinessAccountId = new(uint32)
	*filterMedia.BusinessAccountId = ormObj.Id
	if err = db.Where(filterMedia).Delete(MediaORM{}).Error; err != nil {
		return nil, err
	}
	filterSubscribedTopics := TopicsORM{}
	if ormObj.Id == 0 {
		return nil, errors1.EmptyIdError
	}
	filterSubscribedTopics.BusinessAccountId = new(uint32)
	*filterSubscribedTopics.BusinessAccountId = ormObj.Id
	if err = db.Where(filterSubscribedTopics).Delete(TopicsORM{}).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(BusinessAccountORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(BusinessAccountORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type BusinessAccountORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type BusinessAccountORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type BusinessAccountORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm1.DB) error
}

// DefaultPatchBusinessAccount executes a basic gorm update call with patch behavior
func DefaultPatchBusinessAccount(ctx context.Context, in *BusinessAccount, updateMask *field_mask1.FieldMask, db *gorm1.DB) (*BusinessAccount, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	var pbObj BusinessAccount
	var err error
	if hook, ok := interface{}(&pbObj).(BusinessAccountWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadBusinessAccount(ctx, &BusinessAccount{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(BusinessAccountWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskBusinessAccount(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(BusinessAccountWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateBusinessAccount(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(BusinessAccountWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type BusinessAccountWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *BusinessAccount, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type BusinessAccountWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *BusinessAccount, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type BusinessAccountWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *BusinessAccount, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type BusinessAccountWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *BusinessAccount, *field_mask1.FieldMask, *gorm1.DB) error
}

// DefaultPatchSetBusinessAccount executes a bulk gorm update call with patch behavior
func DefaultPatchSetBusinessAccount(ctx context.Context, objects []*BusinessAccount, updateMasks []*field_mask1.FieldMask, db *gorm1.DB) ([]*BusinessAccount, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors1.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*BusinessAccount, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchBusinessAccount(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskBusinessAccount patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskBusinessAccount(ctx context.Context, patchee *BusinessAccount, patcher *BusinessAccount, updateMask *field_mask1.FieldMask, prefix string, db *gorm1.DB) (*BusinessAccount, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors1.NilArgumentError
	}
	var err error
	var updatedPhoneNumber bool
	var updatedMedia bool
	var updatedTypeOfBusiness bool
	var updatedMerchantType bool
	var updatedPaymentDetails bool
	var updatedServicesManagedByBlackspace bool
	var updatedFounderAddress bool
	var updatedSubscribedTopics bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"CompanyName" {
			patchee.CompanyName = patcher.CompanyName
			continue
		}
		if f == prefix+"CompanyAddress" {
			patchee.CompanyAddress = patcher.CompanyAddress
			continue
		}
		if !updatedPhoneNumber && strings.HasPrefix(f, prefix+"PhoneNumber.") {
			if patcher.PhoneNumber == nil {
				patchee.PhoneNumber = nil
				continue
			}
			if patchee.PhoneNumber == nil {
				patchee.PhoneNumber = &PhoneNumber{}
			}
			childMask := &field_mask1.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"PhoneNumber."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm2.MergeWithMask(patcher.PhoneNumber, patchee.PhoneNumber, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"PhoneNumber" {
			updatedPhoneNumber = true
			patchee.PhoneNumber = patcher.PhoneNumber
			continue
		}
		if f == prefix+"Category" {
			patchee.Category = patcher.Category
			continue
		}
		if !updatedMedia && strings.HasPrefix(f, prefix+"Media.") {
			updatedMedia = true
			if patcher.Media == nil {
				patchee.Media = nil
				continue
			}
			if patchee.Media == nil {
				patchee.Media = &Media{}
			}
			if o, err := DefaultApplyFieldMaskMedia(ctx, patchee.Media, patcher.Media, &field_mask1.FieldMask{Paths: updateMask.Paths[i:]}, prefix+"Media.", db); err != nil {
				return nil, err
			} else {
				patchee.Media = o
			}
			continue
		}
		if f == prefix+"Media" {
			updatedMedia = true
			patchee.Media = patcher.Media
			continue
		}
		if f == prefix+"Password" {
			patchee.Password = patcher.Password
			continue
		}
		if f == prefix+"Email" {
			patchee.Email = patcher.Email
			continue
		}
		if f == prefix+"IsActive" {
			patchee.IsActive = patcher.IsActive
			continue
		}
		if !updatedTypeOfBusiness && strings.HasPrefix(f, prefix+"TypeOfBusiness.") {
			if patcher.TypeOfBusiness == nil {
				patchee.TypeOfBusiness = nil
				continue
			}
			if patchee.TypeOfBusiness == nil {
				patchee.TypeOfBusiness = &BusinessType{}
			}
			childMask := &field_mask1.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"TypeOfBusiness."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm2.MergeWithMask(patcher.TypeOfBusiness, patchee.TypeOfBusiness, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"TypeOfBusiness" {
			updatedTypeOfBusiness = true
			patchee.TypeOfBusiness = patcher.TypeOfBusiness
			continue
		}
		if f == prefix+"BusinessGoals" {
			patchee.BusinessGoals = patcher.BusinessGoals
			continue
		}
		if f == prefix+"BusinessStage" {
			patchee.BusinessStage = patcher.BusinessStage
			continue
		}
		if !updatedMerchantType && strings.HasPrefix(f, prefix+"MerchantType.") {
			if patcher.MerchantType == nil {
				patchee.MerchantType = nil
				continue
			}
			if patchee.MerchantType == nil {
				patchee.MerchantType = &MerchantType{}
			}
			childMask := &field_mask1.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"MerchantType."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm2.MergeWithMask(patcher.MerchantType, patchee.MerchantType, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"MerchantType" {
			updatedMerchantType = true
			patchee.MerchantType = patcher.MerchantType
			continue
		}
		if !updatedPaymentDetails && strings.HasPrefix(f, prefix+"PaymentDetails.") {
			if patcher.PaymentDetails == nil {
				patchee.PaymentDetails = nil
				continue
			}
			if patchee.PaymentDetails == nil {
				patchee.PaymentDetails = &PaymentProcessingMethods{}
			}
			childMask := &field_mask1.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"PaymentDetails."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm2.MergeWithMask(patcher.PaymentDetails, patchee.PaymentDetails, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"PaymentDetails" {
			updatedPaymentDetails = true
			patchee.PaymentDetails = patcher.PaymentDetails
			continue
		}
		if !updatedServicesManagedByBlackspace && strings.HasPrefix(f, prefix+"ServicesManagedByBlackspace.") {
			if patcher.ServicesManagedByBlackspace == nil {
				patchee.ServicesManagedByBlackspace = nil
				continue
			}
			if patchee.ServicesManagedByBlackspace == nil {
				patchee.ServicesManagedByBlackspace = &ServicesManagedByBlackspace{}
			}
			childMask := &field_mask1.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"ServicesManagedByBlackspace."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm2.MergeWithMask(patcher.ServicesManagedByBlackspace, patchee.ServicesManagedByBlackspace, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"ServicesManagedByBlackspace" {
			updatedServicesManagedByBlackspace = true
			patchee.ServicesManagedByBlackspace = patcher.ServicesManagedByBlackspace
			continue
		}
		if !updatedFounderAddress && strings.HasPrefix(f, prefix+"FounderAddress.") {
			if patcher.FounderAddress == nil {
				patchee.FounderAddress = nil
				continue
			}
			if patchee.FounderAddress == nil {
				patchee.FounderAddress = &Address{}
			}
			childMask := &field_mask1.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"FounderAddress."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm2.MergeWithMask(patcher.FounderAddress, patchee.FounderAddress, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"FounderAddress" {
			updatedFounderAddress = true
			patchee.FounderAddress = patcher.FounderAddress
			continue
		}
		if !updatedSubscribedTopics && strings.HasPrefix(f, prefix+"SubscribedTopics.") {
			updatedSubscribedTopics = true
			if patcher.SubscribedTopics == nil {
				patchee.SubscribedTopics = nil
				continue
			}
			if patchee.SubscribedTopics == nil {
				patchee.SubscribedTopics = &Topics{}
			}
			if o, err := DefaultApplyFieldMaskTopics(ctx, patchee.SubscribedTopics, patcher.SubscribedTopics, &field_mask1.FieldMask{Paths: updateMask.Paths[i:]}, prefix+"SubscribedTopics.", db); err != nil {
				return nil, err
			} else {
				patchee.SubscribedTopics = o
			}
			continue
		}
		if f == prefix+"SubscribedTopics" {
			updatedSubscribedTopics = true
			patchee.SubscribedTopics = patcher.SubscribedTopics
			continue
		}
		if f == prefix+"AuthnId" {
			patchee.AuthnId = patcher.AuthnId
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListBusinessAccount executes a gorm list call
func DefaultListBusinessAccount(ctx context.Context, db *gorm1.DB) ([]*BusinessAccount, error) {
	in := BusinessAccount{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(BusinessAccountORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm2.ApplyCollectionOperators(ctx, db, &BusinessAccountORM{}, &BusinessAccount{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(BusinessAccountORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []BusinessAccountORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(BusinessAccountORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*BusinessAccount{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type BusinessAccountORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type BusinessAccountORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type BusinessAccountORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm1.DB, *[]BusinessAccountORM) error
}

// DefaultCreateTopics executes a basic gorm create call
func DefaultCreateTopics(ctx context.Context, in *Topics, db *gorm1.DB) (*Topics, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TopicsORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TopicsORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type TopicsORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type TopicsORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm1.DB) error
}

// DefaultReadTopics executes a basic gorm read call
func DefaultReadTopics(ctx context.Context, in *Topics, db *gorm1.DB) (*Topics, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(TopicsORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm2.ApplyFieldSelection(ctx, db, nil, &TopicsORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TopicsORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := TopicsORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(TopicsORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type TopicsORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type TopicsORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type TopicsORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm1.DB) error
}

func DefaultDeleteTopics(ctx context.Context, in *Topics, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(TopicsORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&TopicsORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(TopicsORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type TopicsORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type TopicsORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm1.DB) error
}

func DefaultDeleteTopicsSet(ctx context.Context, in []*Topics, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	var err error
	keys := []uint32{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors1.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&TopicsORM{})).(TopicsORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&TopicsORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&TopicsORM{})).(TopicsORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type TopicsORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*Topics, *gorm1.DB) (*gorm1.DB, error)
}
type TopicsORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*Topics, *gorm1.DB) error
}

// DefaultStrictUpdateTopics clears first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateTopics(ctx context.Context, in *Topics, db *gorm1.DB) (*Topics, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateTopics")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &TopicsORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(TopicsORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(TopicsORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TopicsORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type TopicsORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type TopicsORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type TopicsORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm1.DB) error
}

// DefaultPatchTopics executes a basic gorm update call with patch behavior
func DefaultPatchTopics(ctx context.Context, in *Topics, updateMask *field_mask1.FieldMask, db *gorm1.DB) (*Topics, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	var pbObj Topics
	var err error
	if hook, ok := interface{}(&pbObj).(TopicsWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadTopics(ctx, &Topics{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(TopicsWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskTopics(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(TopicsWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateTopics(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(TopicsWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type TopicsWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *Topics, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type TopicsWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *Topics, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type TopicsWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *Topics, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type TopicsWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *Topics, *field_mask1.FieldMask, *gorm1.DB) error
}

// DefaultPatchSetTopics executes a bulk gorm update call with patch behavior
func DefaultPatchSetTopics(ctx context.Context, objects []*Topics, updateMasks []*field_mask1.FieldMask, db *gorm1.DB) ([]*Topics, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors1.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*Topics, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchTopics(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskTopics patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskTopics(ctx context.Context, patchee *Topics, patcher *Topics, updateMask *field_mask1.FieldMask, prefix string, db *gorm1.DB) (*Topics, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors1.NilArgumentError
	}
	var err error
	for _, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"Technology" {
			patchee.Technology = patcher.Technology
			continue
		}
		if f == prefix+"Health" {
			patchee.Health = patcher.Health
			continue
		}
		if f == prefix+"Food" {
			patchee.Food = patcher.Food
			continue
		}
		if f == prefix+"Science" {
			patchee.Science = patcher.Science
			continue
		}
		if f == prefix+"Music" {
			patchee.Music = patcher.Music
			continue
		}
		if f == prefix+"Travel" {
			patchee.Travel = patcher.Travel
			continue
		}
		if f == prefix+"Business" {
			patchee.Business = patcher.Business
			continue
		}
		if f == prefix+"Cooking" {
			patchee.Cooking = patcher.Cooking
			continue
		}
		if f == prefix+"FashionAndStyle" {
			patchee.FashionAndStyle = patcher.FashionAndStyle
			continue
		}
		if f == prefix+"Design" {
			patchee.Design = patcher.Design
			continue
		}
		if f == prefix+"Art" {
			patchee.Art = patcher.Art
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListTopics executes a gorm list call
func DefaultListTopics(ctx context.Context, db *gorm1.DB) ([]*Topics, error) {
	in := Topics{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TopicsORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm2.ApplyCollectionOperators(ctx, db, &TopicsORM{}, &Topics{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TopicsORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []TopicsORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TopicsORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*Topics{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type TopicsORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type TopicsORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type TopicsORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm1.DB, *[]TopicsORM) error
}

// DefaultCreateMedia executes a basic gorm create call
func DefaultCreateMedia(ctx context.Context, in *Media, db *gorm1.DB) (*Media, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MediaORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MediaORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type MediaORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type MediaORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm1.DB) error
}

// DefaultReadMedia executes a basic gorm read call
func DefaultReadMedia(ctx context.Context, in *Media, db *gorm1.DB) (*Media, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(MediaORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm2.ApplyFieldSelection(ctx, db, nil, &MediaORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MediaORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := MediaORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(MediaORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type MediaORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type MediaORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type MediaORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm1.DB) error
}

func DefaultDeleteMedia(ctx context.Context, in *Media, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(MediaORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&MediaORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(MediaORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type MediaORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type MediaORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm1.DB) error
}

func DefaultDeleteMediaSet(ctx context.Context, in []*Media, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	var err error
	keys := []uint32{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors1.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&MediaORM{})).(MediaORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&MediaORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&MediaORM{})).(MediaORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type MediaORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*Media, *gorm1.DB) (*gorm1.DB, error)
}
type MediaORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*Media, *gorm1.DB) error
}

// DefaultStrictUpdateMedia clears first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateMedia(ctx context.Context, in *Media, db *gorm1.DB) (*Media, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateMedia")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &MediaORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(MediaORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(MediaORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MediaORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type MediaORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type MediaORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type MediaORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm1.DB) error
}

// DefaultPatchMedia executes a basic gorm update call with patch behavior
func DefaultPatchMedia(ctx context.Context, in *Media, updateMask *field_mask1.FieldMask, db *gorm1.DB) (*Media, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	var pbObj Media
	var err error
	if hook, ok := interface{}(&pbObj).(MediaWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadMedia(ctx, &Media{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(MediaWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskMedia(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(MediaWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateMedia(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(MediaWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type MediaWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *Media, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type MediaWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *Media, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type MediaWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *Media, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type MediaWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *Media, *field_mask1.FieldMask, *gorm1.DB) error
}

// DefaultPatchSetMedia executes a bulk gorm update call with patch behavior
func DefaultPatchSetMedia(ctx context.Context, objects []*Media, updateMasks []*field_mask1.FieldMask, db *gorm1.DB) ([]*Media, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors1.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*Media, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchMedia(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskMedia patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskMedia(ctx context.Context, patchee *Media, patcher *Media, updateMask *field_mask1.FieldMask, prefix string, db *gorm1.DB) (*Media, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors1.NilArgumentError
	}
	var err error
	for _, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"Website" {
			patchee.Website = patcher.Website
			continue
		}
		if f == prefix+"Instagram" {
			patchee.Instagram = patcher.Instagram
			continue
		}
		if f == prefix+"Facebook" {
			patchee.Facebook = patcher.Facebook
			continue
		}
		if f == prefix+"LinkedIn" {
			patchee.LinkedIn = patcher.LinkedIn
			continue
		}
		if f == prefix+"Pinterest" {
			patchee.Pinterest = patcher.Pinterest
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListMedia executes a gorm list call
func DefaultListMedia(ctx context.Context, db *gorm1.DB) ([]*Media, error) {
	in := Media{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MediaORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm2.ApplyCollectionOperators(ctx, db, &MediaORM{}, &Media{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MediaORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []MediaORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MediaORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*Media{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type MediaORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type MediaORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type MediaORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm1.DB, *[]MediaORM) error
}
