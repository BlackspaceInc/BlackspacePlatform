// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: model/schema.proto

/*
Package model is a generated protocol buffer package.

It is generated from these files:
	model/schema.proto

It has these top-level messages:
	ShopperAccount
	CreditCard
	Address
	SubscribedTopic
	Topic
	Image
	ImageMeta
*/
package model

import context "context"
import fmt "fmt"
import strings "strings"

import errors1 "github.com/infobloxopen/protoc-gen-gorm/errors"
import field_mask1 "google.golang.org/genproto/protobuf/field_mask"
import gorm1 "github.com/jinzhu/gorm"
import gorm2 "github.com/infobloxopen/atlas-app-toolkit/gorm"
import pq1 "github.com/lib/pq"

import math "math"

// Reference imports to suppress errors if they are not otherwise used.
var _ = fmt.Errorf
var _ = math.Inf

type ShopperAccountORM struct {
	AcceptedMarketingAt string
	AcceptsMarketing    bool
	Addresses           []*AddressORM `gorm:"foreignkey:ShopperAccountId;association_foreignkey:Id;association_autoupdate:true;association_autocreate:true;association_save_reference:true;preload:true" atlas:"position:Priority"`
	AuthnId             uint32
	Causes              []*SubscribedTopicORM `gorm:"foreignkey:CausesShopperAccountId;association_foreignkey:Id" atlas:"position:Priority"`
	CreditCard          *CreditCardORM        `gorm:"foreignkey:ShopperAccountId;association_foreignkey:Id"`
	Email               string
	FirstName           string
	Id                  uint32 `gorm:"type:serial;primary_key;auto_increment"`
	IsActive            bool
	LastName            string
	Password            string
	Phone               string
	SubscribedTopics    []*SubscribedTopicORM `gorm:"foreignkey:SubscribedTopicsShopperAccountId;association_foreignkey:Id;association_autoupdate:true;association_autocreate:true;association_save_reference:true;preload:true" atlas:"position:Priority"`
	Tags                pq1.StringArray       `gorm:"type:text[]"`
	Username            string
}

// TableName overrides the default tablename generated by GORM
func (ShopperAccountORM) TableName() string {
	return "shopper_accounts"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *ShopperAccount) ToORM(ctx context.Context) (ShopperAccountORM, error) {
	to := ShopperAccountORM{}
	var err error
	if prehook, ok := interface{}(m).(ShopperAccountWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.FirstName = m.FirstName
	to.LastName = m.LastName
	to.Email = m.Email
	to.Username = m.Username
	to.Phone = m.Phone
	to.IsActive = m.IsActive
	to.AcceptsMarketing = m.AcceptsMarketing
	to.AcceptedMarketingAt = m.AcceptedMarketingAt
	for _, v := range m.Addresses {
		if v != nil {
			if tempAddresses, cErr := v.ToORM(ctx); cErr == nil {
				to.Addresses = append(to.Addresses, &tempAddresses)
			} else {
				return to, cErr
			}
		} else {
			to.Addresses = append(to.Addresses, nil)
		}
	}
	if m.Tags != nil {
		to.Tags = make(pq1.StringArray, len(m.Tags))
		copy(to.Tags, m.Tags)
	}
	for _, v := range m.Causes {
		if v != nil {
			if tempCauses, cErr := v.ToORM(ctx); cErr == nil {
				to.Causes = append(to.Causes, &tempCauses)
			} else {
				return to, cErr
			}
		} else {
			to.Causes = append(to.Causes, nil)
		}
	}
	if m.CreditCard != nil {
		tempCreditCard, err := m.CreditCard.ToORM(ctx)
		if err != nil {
			return to, err
		}
		to.CreditCard = &tempCreditCard
	}
	for _, v := range m.SubscribedTopics {
		if v != nil {
			if tempSubscribedTopics, cErr := v.ToORM(ctx); cErr == nil {
				to.SubscribedTopics = append(to.SubscribedTopics, &tempSubscribedTopics)
			} else {
				return to, cErr
			}
		} else {
			to.SubscribedTopics = append(to.SubscribedTopics, nil)
		}
	}
	to.AuthnId = m.AuthnId
	to.Password = m.Password
	for i, e := range to.Addresses {
		e.Priority = int(i)
	}
	for i, e := range to.Causes {
		e.Priority = int(i)
	}
	for i, e := range to.SubscribedTopics {
		e.Priority = int(i)
	}
	if posthook, ok := interface{}(m).(ShopperAccountWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *ShopperAccountORM) ToPB(ctx context.Context) (ShopperAccount, error) {
	to := ShopperAccount{}
	var err error
	if prehook, ok := interface{}(m).(ShopperAccountWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.FirstName = m.FirstName
	to.LastName = m.LastName
	to.Email = m.Email
	to.Username = m.Username
	to.Phone = m.Phone
	to.IsActive = m.IsActive
	to.AcceptsMarketing = m.AcceptsMarketing
	to.AcceptedMarketingAt = m.AcceptedMarketingAt
	for _, v := range m.Addresses {
		if v != nil {
			if tempAddresses, cErr := v.ToPB(ctx); cErr == nil {
				to.Addresses = append(to.Addresses, &tempAddresses)
			} else {
				return to, cErr
			}
		} else {
			to.Addresses = append(to.Addresses, nil)
		}
	}
	if m.Tags != nil {
		to.Tags = make(pq1.StringArray, len(m.Tags))
		copy(to.Tags, m.Tags)
	}
	for _, v := range m.Causes {
		if v != nil {
			if tempCauses, cErr := v.ToPB(ctx); cErr == nil {
				to.Causes = append(to.Causes, &tempCauses)
			} else {
				return to, cErr
			}
		} else {
			to.Causes = append(to.Causes, nil)
		}
	}
	if m.CreditCard != nil {
		tempCreditCard, err := m.CreditCard.ToPB(ctx)
		if err != nil {
			return to, err
		}
		to.CreditCard = &tempCreditCard
	}
	for _, v := range m.SubscribedTopics {
		if v != nil {
			if tempSubscribedTopics, cErr := v.ToPB(ctx); cErr == nil {
				to.SubscribedTopics = append(to.SubscribedTopics, &tempSubscribedTopics)
			} else {
				return to, cErr
			}
		} else {
			to.SubscribedTopics = append(to.SubscribedTopics, nil)
		}
	}
	to.AuthnId = m.AuthnId
	to.Password = m.Password
	if posthook, ok := interface{}(m).(ShopperAccountWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type ShopperAccount the arg will be the target, the caller the one being converted from

// ShopperAccountBeforeToORM called before default ToORM code
type ShopperAccountWithBeforeToORM interface {
	BeforeToORM(context.Context, *ShopperAccountORM) error
}

// ShopperAccountAfterToORM called after default ToORM code
type ShopperAccountWithAfterToORM interface {
	AfterToORM(context.Context, *ShopperAccountORM) error
}

// ShopperAccountBeforeToPB called before default ToPB code
type ShopperAccountWithBeforeToPB interface {
	BeforeToPB(context.Context, *ShopperAccount) error
}

// ShopperAccountAfterToPB called after default ToPB code
type ShopperAccountWithAfterToPB interface {
	AfterToPB(context.Context, *ShopperAccount) error
}

type CreditCardORM struct {
	CardBrand                string
	CardHolderName           string
	CardNumber               string
	CreditCardBillingAddress *AddressORM `gorm:"foreignkey:CreditCardId;association_foreignkey:Id"`
	ExpirationMonth          int64
	ExpirationYear           int64
	ExpiresSoon              bool
	FirstDigits              string
	Id                       uint32 `gorm:"type:serial;primary_key;auto_increment"`
	LastDigits               string
	MaskedNumber             string
	ShopperAccountId         uint32 `gorm:"type:serial;not null;auto_increment"`
}

// TableName overrides the default tablename generated by GORM
func (CreditCardORM) TableName() string {
	return "credit_cards"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *CreditCard) ToORM(ctx context.Context) (CreditCardORM, error) {
	to := CreditCardORM{}
	var err error
	if prehook, ok := interface{}(m).(CreditCardWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.CardNumber = m.CardNumber
	to.CardBrand = m.CardBrand
	to.ExpiresSoon = m.ExpiresSoon
	to.ExpirationMonth = m.ExpirationMonth
	to.ExpirationYear = m.ExpirationYear
	to.FirstDigits = m.FirstDigits
	to.LastDigits = m.LastDigits
	to.MaskedNumber = m.MaskedNumber
	to.CardHolderName = m.CardHolderName
	if m.CreditCardBillingAddress != nil {
		tempCreditCardBillingAddress, err := m.CreditCardBillingAddress.ToORM(ctx)
		if err != nil {
			return to, err
		}
		to.CreditCardBillingAddress = &tempCreditCardBillingAddress
	}
	if posthook, ok := interface{}(m).(CreditCardWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *CreditCardORM) ToPB(ctx context.Context) (CreditCard, error) {
	to := CreditCard{}
	var err error
	if prehook, ok := interface{}(m).(CreditCardWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.CardNumber = m.CardNumber
	to.CardBrand = m.CardBrand
	to.ExpiresSoon = m.ExpiresSoon
	to.ExpirationMonth = m.ExpirationMonth
	to.ExpirationYear = m.ExpirationYear
	to.FirstDigits = m.FirstDigits
	to.LastDigits = m.LastDigits
	to.MaskedNumber = m.MaskedNumber
	to.CardHolderName = m.CardHolderName
	if m.CreditCardBillingAddress != nil {
		tempCreditCardBillingAddress, err := m.CreditCardBillingAddress.ToPB(ctx)
		if err != nil {
			return to, err
		}
		to.CreditCardBillingAddress = &tempCreditCardBillingAddress
	}
	if posthook, ok := interface{}(m).(CreditCardWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type CreditCard the arg will be the target, the caller the one being converted from

// CreditCardBeforeToORM called before default ToORM code
type CreditCardWithBeforeToORM interface {
	BeforeToORM(context.Context, *CreditCardORM) error
}

// CreditCardAfterToORM called after default ToORM code
type CreditCardWithAfterToORM interface {
	AfterToORM(context.Context, *CreditCardORM) error
}

// CreditCardBeforeToPB called before default ToPB code
type CreditCardWithBeforeToPB interface {
	BeforeToPB(context.Context, *CreditCard) error
}

// CreditCardAfterToPB called after default ToPB code
type CreditCardWithAfterToPB interface {
	AfterToPB(context.Context, *CreditCard) error
}

type AddressORM struct {
	City             string
	Country          string
	CountryCode      string
	CreditCardId     uint32 `gorm:"not null"`
	Id               uint32 `gorm:"type:serial;primary_key;auto_increment"`
	Priority         int
	Province         string
	ProvinceCode     string
	ShopperAccountId uint32 `gorm:"type:serial;not null;auto_increment"`
	Street           string
	ZipCode          string
}

// TableName overrides the default tablename generated by GORM
func (AddressORM) TableName() string {
	return "addresses"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *Address) ToORM(ctx context.Context) (AddressORM, error) {
	to := AddressORM{}
	var err error
	if prehook, ok := interface{}(m).(AddressWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.Street = m.Street
	to.Province = m.Province
	to.City = m.City
	to.ZipCode = m.ZipCode
	to.Country = m.Country
	to.CountryCode = m.CountryCode
	to.ProvinceCode = m.ProvinceCode
	if posthook, ok := interface{}(m).(AddressWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *AddressORM) ToPB(ctx context.Context) (Address, error) {
	to := Address{}
	var err error
	if prehook, ok := interface{}(m).(AddressWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.Street = m.Street
	to.Province = m.Province
	to.City = m.City
	to.ZipCode = m.ZipCode
	to.Country = m.Country
	to.CountryCode = m.CountryCode
	to.ProvinceCode = m.ProvinceCode
	if posthook, ok := interface{}(m).(AddressWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type Address the arg will be the target, the caller the one being converted from

// AddressBeforeToORM called before default ToORM code
type AddressWithBeforeToORM interface {
	BeforeToORM(context.Context, *AddressORM) error
}

// AddressAfterToORM called after default ToORM code
type AddressWithAfterToORM interface {
	AfterToORM(context.Context, *AddressORM) error
}

// AddressBeforeToPB called before default ToPB code
type AddressWithBeforeToPB interface {
	BeforeToPB(context.Context, *Address) error
}

// AddressAfterToPB called after default ToPB code
type AddressWithAfterToPB interface {
	AfterToPB(context.Context, *Address) error
}

type SubscribedTopicORM struct {
	CausesShopperAccountId           uint32 `gorm:"not null"`
	Description                      string
	Id                               uint32 `gorm:"type:serial;primary_key;auto_increment"`
	Priority                         int
	SubscribedAt                     string
	SubscribedTopic                  *TopicORM `gorm:"foreignkey:SubscribedTopicId;association_foreignkey:Id"`
	SubscribedTopicsShopperAccountId *uint32
}

// TableName overrides the default tablename generated by GORM
func (SubscribedTopicORM) TableName() string {
	return "subscribed_topics"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *SubscribedTopic) ToORM(ctx context.Context) (SubscribedTopicORM, error) {
	to := SubscribedTopicORM{}
	var err error
	if prehook, ok := interface{}(m).(SubscribedTopicWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	if m.SubscribedTopic != nil {
		tempSubscribedTopic, err := m.SubscribedTopic.ToORM(ctx)
		if err != nil {
			return to, err
		}
		to.SubscribedTopic = &tempSubscribedTopic
	}
	to.SubscribedAt = m.SubscribedAt
	to.Description = m.Description
	if posthook, ok := interface{}(m).(SubscribedTopicWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *SubscribedTopicORM) ToPB(ctx context.Context) (SubscribedTopic, error) {
	to := SubscribedTopic{}
	var err error
	if prehook, ok := interface{}(m).(SubscribedTopicWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	if m.SubscribedTopic != nil {
		tempSubscribedTopic, err := m.SubscribedTopic.ToPB(ctx)
		if err != nil {
			return to, err
		}
		to.SubscribedTopic = &tempSubscribedTopic
	}
	to.SubscribedAt = m.SubscribedAt
	to.Description = m.Description
	if posthook, ok := interface{}(m).(SubscribedTopicWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type SubscribedTopic the arg will be the target, the caller the one being converted from

// SubscribedTopicBeforeToORM called before default ToORM code
type SubscribedTopicWithBeforeToORM interface {
	BeforeToORM(context.Context, *SubscribedTopicORM) error
}

// SubscribedTopicAfterToORM called after default ToORM code
type SubscribedTopicWithAfterToORM interface {
	AfterToORM(context.Context, *SubscribedTopicORM) error
}

// SubscribedTopicBeforeToPB called before default ToPB code
type SubscribedTopicWithBeforeToPB interface {
	BeforeToPB(context.Context, *SubscribedTopic) error
}

// SubscribedTopicAfterToPB called after default ToPB code
type SubscribedTopicWithAfterToPB interface {
	AfterToPB(context.Context, *SubscribedTopic) error
}

type TopicORM struct {
	Id                uint32 `gorm:"type:serial;primary_key;auto_increment"`
	Name              string
	SubscribedTopicId uint32          `gorm:"not null"`
	Tags              pq1.StringArray `gorm:"type:text[]"`
	TopicCoverImage   *ImageORM       `gorm:"foreignkey:TopicId;association_foreignkey:Id"`
}

// TableName overrides the default tablename generated by GORM
func (TopicORM) TableName() string {
	return "topics"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *Topic) ToORM(ctx context.Context) (TopicORM, error) {
	to := TopicORM{}
	var err error
	if prehook, ok := interface{}(m).(TopicWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.Name = m.Name
	if m.Tags != nil {
		to.Tags = make(pq1.StringArray, len(m.Tags))
		copy(to.Tags, m.Tags)
	}
	if m.TopicCoverImage != nil {
		tempTopicCoverImage, err := m.TopicCoverImage.ToORM(ctx)
		if err != nil {
			return to, err
		}
		to.TopicCoverImage = &tempTopicCoverImage
	}
	if posthook, ok := interface{}(m).(TopicWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *TopicORM) ToPB(ctx context.Context) (Topic, error) {
	to := Topic{}
	var err error
	if prehook, ok := interface{}(m).(TopicWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.Name = m.Name
	if m.Tags != nil {
		to.Tags = make(pq1.StringArray, len(m.Tags))
		copy(to.Tags, m.Tags)
	}
	if m.TopicCoverImage != nil {
		tempTopicCoverImage, err := m.TopicCoverImage.ToPB(ctx)
		if err != nil {
			return to, err
		}
		to.TopicCoverImage = &tempTopicCoverImage
	}
	if posthook, ok := interface{}(m).(TopicWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type Topic the arg will be the target, the caller the one being converted from

// TopicBeforeToORM called before default ToORM code
type TopicWithBeforeToORM interface {
	BeforeToORM(context.Context, *TopicORM) error
}

// TopicAfterToORM called after default ToORM code
type TopicWithAfterToORM interface {
	AfterToORM(context.Context, *TopicORM) error
}

// TopicBeforeToPB called before default ToPB code
type TopicWithBeforeToPB interface {
	BeforeToPB(context.Context, *Topic) error
}

// TopicAfterToPB called after default ToPB code
type TopicWithAfterToPB interface {
	AfterToPB(context.Context, *Topic) error
}

type ImageORM struct {
	AltText string
	BlobUrl string
	Id      uint32 `gorm:"type:serial;primary_key;auto_increment"`
	TopicId uint32 `gorm:"not null"`
}

// TableName overrides the default tablename generated by GORM
func (ImageORM) TableName() string {
	return "images"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *Image) ToORM(ctx context.Context) (ImageORM, error) {
	to := ImageORM{}
	var err error
	if prehook, ok := interface{}(m).(ImageWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.BlobUrl = m.BlobUrl
	to.AltText = m.AltText
	if posthook, ok := interface{}(m).(ImageWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *ImageORM) ToPB(ctx context.Context) (Image, error) {
	to := Image{}
	var err error
	if prehook, ok := interface{}(m).(ImageWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.BlobUrl = m.BlobUrl
	to.AltText = m.AltText
	if posthook, ok := interface{}(m).(ImageWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type Image the arg will be the target, the caller the one being converted from

// ImageBeforeToORM called before default ToORM code
type ImageWithBeforeToORM interface {
	BeforeToORM(context.Context, *ImageORM) error
}

// ImageAfterToORM called after default ToORM code
type ImageWithAfterToORM interface {
	AfterToORM(context.Context, *ImageORM) error
}

// ImageBeforeToPB called before default ToPB code
type ImageWithBeforeToPB interface {
	BeforeToPB(context.Context, *Image) error
}

// ImageAfterToPB called after default ToPB code
type ImageWithAfterToPB interface {
	AfterToPB(context.Context, *Image) error
}

// DefaultCreateShopperAccount executes a basic gorm create call
func DefaultCreateShopperAccount(ctx context.Context, in *ShopperAccount, db *gorm1.DB) (*ShopperAccount, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ShopperAccountORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ShopperAccountORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type ShopperAccountORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ShopperAccountORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm1.DB) error
}

// DefaultReadShopperAccount executes a basic gorm read call
func DefaultReadShopperAccount(ctx context.Context, in *ShopperAccount, db *gorm1.DB) (*ShopperAccount, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(ShopperAccountORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm2.ApplyFieldSelection(ctx, db, nil, &ShopperAccountORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ShopperAccountORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := ShopperAccountORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(ShopperAccountORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type ShopperAccountORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ShopperAccountORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ShopperAccountORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm1.DB) error
}

func DefaultDeleteShopperAccount(ctx context.Context, in *ShopperAccount, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(ShopperAccountORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&ShopperAccountORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(ShopperAccountORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type ShopperAccountORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ShopperAccountORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm1.DB) error
}

func DefaultDeleteShopperAccountSet(ctx context.Context, in []*ShopperAccount, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	var err error
	keys := []uint32{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors1.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&ShopperAccountORM{})).(ShopperAccountORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&ShopperAccountORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&ShopperAccountORM{})).(ShopperAccountORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type ShopperAccountORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*ShopperAccount, *gorm1.DB) (*gorm1.DB, error)
}
type ShopperAccountORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*ShopperAccount, *gorm1.DB) error
}

// DefaultStrictUpdateShopperAccount clears first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateShopperAccount(ctx context.Context, in *ShopperAccount, db *gorm1.DB) (*ShopperAccount, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateShopperAccount")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &ShopperAccountORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(ShopperAccountORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	filterAddresses := AddressORM{}
	if ormObj.Id == 0 {
		return nil, errors1.EmptyIdError
	}
	filterAddresses.ShopperAccountId = ormObj.Id
	if err = db.Where(filterAddresses).Delete(AddressORM{}).Error; err != nil {
		return nil, err
	}
	filterCauses := SubscribedTopicORM{}
	if ormObj.Id == 0 {
		return nil, errors1.EmptyIdError
	}
	filterCauses.CausesShopperAccountId = ormObj.Id
	if err = db.Where(filterCauses).Delete(SubscribedTopicORM{}).Error; err != nil {
		return nil, err
	}
	filterCreditCard := CreditCardORM{}
	if ormObj.Id == 0 {
		return nil, errors1.EmptyIdError
	}
	filterCreditCard.ShopperAccountId = ormObj.Id
	if err = db.Where(filterCreditCard).Delete(CreditCardORM{}).Error; err != nil {
		return nil, err
	}
	filterSubscribedTopics := SubscribedTopicORM{}
	if ormObj.Id == 0 {
		return nil, errors1.EmptyIdError
	}
	filterSubscribedTopics.SubscribedTopicsShopperAccountId = new(uint32)
	*filterSubscribedTopics.SubscribedTopicsShopperAccountId = ormObj.Id
	if err = db.Where(filterSubscribedTopics).Delete(SubscribedTopicORM{}).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ShopperAccountORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ShopperAccountORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type ShopperAccountORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ShopperAccountORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ShopperAccountORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm1.DB) error
}

// DefaultPatchShopperAccount executes a basic gorm update call with patch behavior
func DefaultPatchShopperAccount(ctx context.Context, in *ShopperAccount, updateMask *field_mask1.FieldMask, db *gorm1.DB) (*ShopperAccount, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	var pbObj ShopperAccount
	var err error
	if hook, ok := interface{}(&pbObj).(ShopperAccountWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadShopperAccount(ctx, &ShopperAccount{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(ShopperAccountWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskShopperAccount(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(ShopperAccountWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateShopperAccount(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(ShopperAccountWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type ShopperAccountWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *ShopperAccount, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type ShopperAccountWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *ShopperAccount, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type ShopperAccountWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *ShopperAccount, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type ShopperAccountWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *ShopperAccount, *field_mask1.FieldMask, *gorm1.DB) error
}

// DefaultPatchSetShopperAccount executes a bulk gorm update call with patch behavior
func DefaultPatchSetShopperAccount(ctx context.Context, objects []*ShopperAccount, updateMasks []*field_mask1.FieldMask, db *gorm1.DB) ([]*ShopperAccount, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors1.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*ShopperAccount, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchShopperAccount(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskShopperAccount patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskShopperAccount(ctx context.Context, patchee *ShopperAccount, patcher *ShopperAccount, updateMask *field_mask1.FieldMask, prefix string, db *gorm1.DB) (*ShopperAccount, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors1.NilArgumentError
	}
	var err error
	var updatedCreditCard bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"FirstName" {
			patchee.FirstName = patcher.FirstName
			continue
		}
		if f == prefix+"LastName" {
			patchee.LastName = patcher.LastName
			continue
		}
		if f == prefix+"Email" {
			patchee.Email = patcher.Email
			continue
		}
		if f == prefix+"Username" {
			patchee.Username = patcher.Username
			continue
		}
		if f == prefix+"Phone" {
			patchee.Phone = patcher.Phone
			continue
		}
		if f == prefix+"IsActive" {
			patchee.IsActive = patcher.IsActive
			continue
		}
		if f == prefix+"AcceptsMarketing" {
			patchee.AcceptsMarketing = patcher.AcceptsMarketing
			continue
		}
		if f == prefix+"AcceptedMarketingAt" {
			patchee.AcceptedMarketingAt = patcher.AcceptedMarketingAt
			continue
		}
		if f == prefix+"Addresses" {
			patchee.Addresses = patcher.Addresses
			continue
		}
		if f == prefix+"Tags" {
			patchee.Tags = patcher.Tags
			continue
		}
		if f == prefix+"Causes" {
			patchee.Causes = patcher.Causes
			continue
		}
		if !updatedCreditCard && strings.HasPrefix(f, prefix+"CreditCard.") {
			updatedCreditCard = true
			if patcher.CreditCard == nil {
				patchee.CreditCard = nil
				continue
			}
			if patchee.CreditCard == nil {
				patchee.CreditCard = &CreditCard{}
			}
			if o, err := DefaultApplyFieldMaskCreditCard(ctx, patchee.CreditCard, patcher.CreditCard, &field_mask1.FieldMask{Paths: updateMask.Paths[i:]}, prefix+"CreditCard.", db); err != nil {
				return nil, err
			} else {
				patchee.CreditCard = o
			}
			continue
		}
		if f == prefix+"CreditCard" {
			updatedCreditCard = true
			patchee.CreditCard = patcher.CreditCard
			continue
		}
		if f == prefix+"SubscribedTopics" {
			patchee.SubscribedTopics = patcher.SubscribedTopics
			continue
		}
		if f == prefix+"AuthnId" {
			patchee.AuthnId = patcher.AuthnId
			continue
		}
		if f == prefix+"Password" {
			patchee.Password = patcher.Password
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListShopperAccount executes a gorm list call
func DefaultListShopperAccount(ctx context.Context, db *gorm1.DB) ([]*ShopperAccount, error) {
	in := ShopperAccount{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ShopperAccountORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm2.ApplyCollectionOperators(ctx, db, &ShopperAccountORM{}, &ShopperAccount{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ShopperAccountORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []ShopperAccountORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ShopperAccountORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*ShopperAccount{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type ShopperAccountORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ShopperAccountORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ShopperAccountORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm1.DB, *[]ShopperAccountORM) error
}

// DefaultCreateCreditCard executes a basic gorm create call
func DefaultCreateCreditCard(ctx context.Context, in *CreditCard, db *gorm1.DB) (*CreditCard, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CreditCardORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CreditCardORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type CreditCardORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type CreditCardORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm1.DB) error
}

// DefaultReadCreditCard executes a basic gorm read call
func DefaultReadCreditCard(ctx context.Context, in *CreditCard, db *gorm1.DB) (*CreditCard, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(CreditCardORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm2.ApplyFieldSelection(ctx, db, nil, &CreditCardORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CreditCardORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := CreditCardORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(CreditCardORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type CreditCardORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type CreditCardORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type CreditCardORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm1.DB) error
}

func DefaultDeleteCreditCard(ctx context.Context, in *CreditCard, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(CreditCardORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&CreditCardORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(CreditCardORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type CreditCardORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type CreditCardORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm1.DB) error
}

func DefaultDeleteCreditCardSet(ctx context.Context, in []*CreditCard, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	var err error
	keys := []uint32{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors1.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&CreditCardORM{})).(CreditCardORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&CreditCardORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&CreditCardORM{})).(CreditCardORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type CreditCardORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*CreditCard, *gorm1.DB) (*gorm1.DB, error)
}
type CreditCardORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*CreditCard, *gorm1.DB) error
}

// DefaultStrictUpdateCreditCard clears first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateCreditCard(ctx context.Context, in *CreditCard, db *gorm1.DB) (*CreditCard, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateCreditCard")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &CreditCardORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(CreditCardORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	filterCreditCardBillingAddress := AddressORM{}
	if ormObj.Id == 0 {
		return nil, errors1.EmptyIdError
	}
	filterCreditCardBillingAddress.CreditCardId = ormObj.Id
	if err = db.Where(filterCreditCardBillingAddress).Delete(AddressORM{}).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CreditCardORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CreditCardORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type CreditCardORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type CreditCardORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type CreditCardORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm1.DB) error
}

// DefaultPatchCreditCard executes a basic gorm update call with patch behavior
func DefaultPatchCreditCard(ctx context.Context, in *CreditCard, updateMask *field_mask1.FieldMask, db *gorm1.DB) (*CreditCard, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	var pbObj CreditCard
	var err error
	if hook, ok := interface{}(&pbObj).(CreditCardWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadCreditCard(ctx, &CreditCard{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(CreditCardWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskCreditCard(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(CreditCardWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateCreditCard(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(CreditCardWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type CreditCardWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *CreditCard, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type CreditCardWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *CreditCard, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type CreditCardWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *CreditCard, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type CreditCardWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *CreditCard, *field_mask1.FieldMask, *gorm1.DB) error
}

// DefaultPatchSetCreditCard executes a bulk gorm update call with patch behavior
func DefaultPatchSetCreditCard(ctx context.Context, objects []*CreditCard, updateMasks []*field_mask1.FieldMask, db *gorm1.DB) ([]*CreditCard, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors1.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*CreditCard, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchCreditCard(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskCreditCard patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskCreditCard(ctx context.Context, patchee *CreditCard, patcher *CreditCard, updateMask *field_mask1.FieldMask, prefix string, db *gorm1.DB) (*CreditCard, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors1.NilArgumentError
	}
	var err error
	var updatedCreditCardBillingAddress bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"CardNumber" {
			patchee.CardNumber = patcher.CardNumber
			continue
		}
		if f == prefix+"CardBrand" {
			patchee.CardBrand = patcher.CardBrand
			continue
		}
		if f == prefix+"ExpiresSoon" {
			patchee.ExpiresSoon = patcher.ExpiresSoon
			continue
		}
		if f == prefix+"ExpirationMonth" {
			patchee.ExpirationMonth = patcher.ExpirationMonth
			continue
		}
		if f == prefix+"ExpirationYear" {
			patchee.ExpirationYear = patcher.ExpirationYear
			continue
		}
		if f == prefix+"FirstDigits" {
			patchee.FirstDigits = patcher.FirstDigits
			continue
		}
		if f == prefix+"LastDigits" {
			patchee.LastDigits = patcher.LastDigits
			continue
		}
		if f == prefix+"MaskedNumber" {
			patchee.MaskedNumber = patcher.MaskedNumber
			continue
		}
		if f == prefix+"CardHolderName" {
			patchee.CardHolderName = patcher.CardHolderName
			continue
		}
		if !updatedCreditCardBillingAddress && strings.HasPrefix(f, prefix+"CreditCardBillingAddress.") {
			updatedCreditCardBillingAddress = true
			if patcher.CreditCardBillingAddress == nil {
				patchee.CreditCardBillingAddress = nil
				continue
			}
			if patchee.CreditCardBillingAddress == nil {
				patchee.CreditCardBillingAddress = &Address{}
			}
			if o, err := DefaultApplyFieldMaskAddress(ctx, patchee.CreditCardBillingAddress, patcher.CreditCardBillingAddress, &field_mask1.FieldMask{Paths: updateMask.Paths[i:]}, prefix+"CreditCardBillingAddress.", db); err != nil {
				return nil, err
			} else {
				patchee.CreditCardBillingAddress = o
			}
			continue
		}
		if f == prefix+"CreditCardBillingAddress" {
			updatedCreditCardBillingAddress = true
			patchee.CreditCardBillingAddress = patcher.CreditCardBillingAddress
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListCreditCard executes a gorm list call
func DefaultListCreditCard(ctx context.Context, db *gorm1.DB) ([]*CreditCard, error) {
	in := CreditCard{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CreditCardORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm2.ApplyCollectionOperators(ctx, db, &CreditCardORM{}, &CreditCard{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CreditCardORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []CreditCardORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CreditCardORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*CreditCard{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type CreditCardORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type CreditCardORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type CreditCardORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm1.DB, *[]CreditCardORM) error
}

// DefaultCreateAddress executes a basic gorm create call
func DefaultCreateAddress(ctx context.Context, in *Address, db *gorm1.DB) (*Address, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AddressORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AddressORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type AddressORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type AddressORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm1.DB) error
}

// DefaultReadAddress executes a basic gorm read call
func DefaultReadAddress(ctx context.Context, in *Address, db *gorm1.DB) (*Address, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(AddressORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm2.ApplyFieldSelection(ctx, db, nil, &AddressORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AddressORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := AddressORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(AddressORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type AddressORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type AddressORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type AddressORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm1.DB) error
}

func DefaultDeleteAddress(ctx context.Context, in *Address, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(AddressORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&AddressORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(AddressORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type AddressORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type AddressORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm1.DB) error
}

func DefaultDeleteAddressSet(ctx context.Context, in []*Address, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	var err error
	keys := []uint32{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors1.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&AddressORM{})).(AddressORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&AddressORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&AddressORM{})).(AddressORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type AddressORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*Address, *gorm1.DB) (*gorm1.DB, error)
}
type AddressORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*Address, *gorm1.DB) error
}

// DefaultStrictUpdateAddress clears first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateAddress(ctx context.Context, in *Address, db *gorm1.DB) (*Address, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateAddress")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &AddressORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(AddressORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(AddressORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AddressORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type AddressORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type AddressORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type AddressORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm1.DB) error
}

// DefaultPatchAddress executes a basic gorm update call with patch behavior
func DefaultPatchAddress(ctx context.Context, in *Address, updateMask *field_mask1.FieldMask, db *gorm1.DB) (*Address, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	var pbObj Address
	var err error
	if hook, ok := interface{}(&pbObj).(AddressWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadAddress(ctx, &Address{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(AddressWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskAddress(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(AddressWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateAddress(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(AddressWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type AddressWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *Address, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type AddressWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *Address, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type AddressWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *Address, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type AddressWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *Address, *field_mask1.FieldMask, *gorm1.DB) error
}

// DefaultPatchSetAddress executes a bulk gorm update call with patch behavior
func DefaultPatchSetAddress(ctx context.Context, objects []*Address, updateMasks []*field_mask1.FieldMask, db *gorm1.DB) ([]*Address, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors1.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*Address, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchAddress(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskAddress patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskAddress(ctx context.Context, patchee *Address, patcher *Address, updateMask *field_mask1.FieldMask, prefix string, db *gorm1.DB) (*Address, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors1.NilArgumentError
	}
	var err error
	for _, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"Street" {
			patchee.Street = patcher.Street
			continue
		}
		if f == prefix+"Province" {
			patchee.Province = patcher.Province
			continue
		}
		if f == prefix+"City" {
			patchee.City = patcher.City
			continue
		}
		if f == prefix+"ZipCode" {
			patchee.ZipCode = patcher.ZipCode
			continue
		}
		if f == prefix+"Country" {
			patchee.Country = patcher.Country
			continue
		}
		if f == prefix+"CountryCode" {
			patchee.CountryCode = patcher.CountryCode
			continue
		}
		if f == prefix+"ProvinceCode" {
			patchee.ProvinceCode = patcher.ProvinceCode
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListAddress executes a gorm list call
func DefaultListAddress(ctx context.Context, db *gorm1.DB) ([]*Address, error) {
	in := Address{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AddressORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm2.ApplyCollectionOperators(ctx, db, &AddressORM{}, &Address{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AddressORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []AddressORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AddressORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*Address{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type AddressORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type AddressORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type AddressORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm1.DB, *[]AddressORM) error
}

// DefaultCreateSubscribedTopic executes a basic gorm create call
func DefaultCreateSubscribedTopic(ctx context.Context, in *SubscribedTopic, db *gorm1.DB) (*SubscribedTopic, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(SubscribedTopicORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(SubscribedTopicORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type SubscribedTopicORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type SubscribedTopicORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm1.DB) error
}

// DefaultReadSubscribedTopic executes a basic gorm read call
func DefaultReadSubscribedTopic(ctx context.Context, in *SubscribedTopic, db *gorm1.DB) (*SubscribedTopic, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(SubscribedTopicORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm2.ApplyFieldSelection(ctx, db, nil, &SubscribedTopicORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(SubscribedTopicORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := SubscribedTopicORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(SubscribedTopicORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type SubscribedTopicORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type SubscribedTopicORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type SubscribedTopicORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm1.DB) error
}

func DefaultDeleteSubscribedTopic(ctx context.Context, in *SubscribedTopic, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(SubscribedTopicORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&SubscribedTopicORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(SubscribedTopicORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type SubscribedTopicORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type SubscribedTopicORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm1.DB) error
}

func DefaultDeleteSubscribedTopicSet(ctx context.Context, in []*SubscribedTopic, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	var err error
	keys := []uint32{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors1.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&SubscribedTopicORM{})).(SubscribedTopicORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&SubscribedTopicORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&SubscribedTopicORM{})).(SubscribedTopicORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type SubscribedTopicORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*SubscribedTopic, *gorm1.DB) (*gorm1.DB, error)
}
type SubscribedTopicORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*SubscribedTopic, *gorm1.DB) error
}

// DefaultStrictUpdateSubscribedTopic clears first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateSubscribedTopic(ctx context.Context, in *SubscribedTopic, db *gorm1.DB) (*SubscribedTopic, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateSubscribedTopic")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &SubscribedTopicORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(SubscribedTopicORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	filterSubscribedTopic := TopicORM{}
	if ormObj.Id == 0 {
		return nil, errors1.EmptyIdError
	}
	filterSubscribedTopic.SubscribedTopicId = ormObj.Id
	if err = db.Where(filterSubscribedTopic).Delete(TopicORM{}).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(SubscribedTopicORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(SubscribedTopicORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type SubscribedTopicORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type SubscribedTopicORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type SubscribedTopicORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm1.DB) error
}

// DefaultPatchSubscribedTopic executes a basic gorm update call with patch behavior
func DefaultPatchSubscribedTopic(ctx context.Context, in *SubscribedTopic, updateMask *field_mask1.FieldMask, db *gorm1.DB) (*SubscribedTopic, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	var pbObj SubscribedTopic
	var err error
	if hook, ok := interface{}(&pbObj).(SubscribedTopicWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadSubscribedTopic(ctx, &SubscribedTopic{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(SubscribedTopicWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskSubscribedTopic(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(SubscribedTopicWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateSubscribedTopic(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(SubscribedTopicWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type SubscribedTopicWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *SubscribedTopic, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type SubscribedTopicWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *SubscribedTopic, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type SubscribedTopicWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *SubscribedTopic, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type SubscribedTopicWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *SubscribedTopic, *field_mask1.FieldMask, *gorm1.DB) error
}

// DefaultPatchSetSubscribedTopic executes a bulk gorm update call with patch behavior
func DefaultPatchSetSubscribedTopic(ctx context.Context, objects []*SubscribedTopic, updateMasks []*field_mask1.FieldMask, db *gorm1.DB) ([]*SubscribedTopic, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors1.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*SubscribedTopic, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchSubscribedTopic(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskSubscribedTopic patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskSubscribedTopic(ctx context.Context, patchee *SubscribedTopic, patcher *SubscribedTopic, updateMask *field_mask1.FieldMask, prefix string, db *gorm1.DB) (*SubscribedTopic, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors1.NilArgumentError
	}
	var err error
	var updatedSubscribedTopic bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if !updatedSubscribedTopic && strings.HasPrefix(f, prefix+"SubscribedTopic.") {
			updatedSubscribedTopic = true
			if patcher.SubscribedTopic == nil {
				patchee.SubscribedTopic = nil
				continue
			}
			if patchee.SubscribedTopic == nil {
				patchee.SubscribedTopic = &Topic{}
			}
			if o, err := DefaultApplyFieldMaskTopic(ctx, patchee.SubscribedTopic, patcher.SubscribedTopic, &field_mask1.FieldMask{Paths: updateMask.Paths[i:]}, prefix+"SubscribedTopic.", db); err != nil {
				return nil, err
			} else {
				patchee.SubscribedTopic = o
			}
			continue
		}
		if f == prefix+"SubscribedTopic" {
			updatedSubscribedTopic = true
			patchee.SubscribedTopic = patcher.SubscribedTopic
			continue
		}
		if f == prefix+"SubscribedAt" {
			patchee.SubscribedAt = patcher.SubscribedAt
			continue
		}
		if f == prefix+"Description" {
			patchee.Description = patcher.Description
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListSubscribedTopic executes a gorm list call
func DefaultListSubscribedTopic(ctx context.Context, db *gorm1.DB) ([]*SubscribedTopic, error) {
	in := SubscribedTopic{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(SubscribedTopicORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm2.ApplyCollectionOperators(ctx, db, &SubscribedTopicORM{}, &SubscribedTopic{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(SubscribedTopicORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []SubscribedTopicORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(SubscribedTopicORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*SubscribedTopic{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type SubscribedTopicORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type SubscribedTopicORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type SubscribedTopicORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm1.DB, *[]SubscribedTopicORM) error
}

// DefaultCreateTopic executes a basic gorm create call
func DefaultCreateTopic(ctx context.Context, in *Topic, db *gorm1.DB) (*Topic, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TopicORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TopicORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type TopicORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type TopicORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm1.DB) error
}

// DefaultReadTopic executes a basic gorm read call
func DefaultReadTopic(ctx context.Context, in *Topic, db *gorm1.DB) (*Topic, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(TopicORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm2.ApplyFieldSelection(ctx, db, nil, &TopicORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TopicORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := TopicORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(TopicORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type TopicORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type TopicORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type TopicORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm1.DB) error
}

func DefaultDeleteTopic(ctx context.Context, in *Topic, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(TopicORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&TopicORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(TopicORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type TopicORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type TopicORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm1.DB) error
}

func DefaultDeleteTopicSet(ctx context.Context, in []*Topic, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	var err error
	keys := []uint32{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors1.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&TopicORM{})).(TopicORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&TopicORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&TopicORM{})).(TopicORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type TopicORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*Topic, *gorm1.DB) (*gorm1.DB, error)
}
type TopicORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*Topic, *gorm1.DB) error
}

// DefaultStrictUpdateTopic clears first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateTopic(ctx context.Context, in *Topic, db *gorm1.DB) (*Topic, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateTopic")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &TopicORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(TopicORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	filterTopicCoverImage := ImageORM{}
	if ormObj.Id == 0 {
		return nil, errors1.EmptyIdError
	}
	filterTopicCoverImage.TopicId = ormObj.Id
	if err = db.Where(filterTopicCoverImage).Delete(ImageORM{}).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TopicORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TopicORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type TopicORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type TopicORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type TopicORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm1.DB) error
}

// DefaultPatchTopic executes a basic gorm update call with patch behavior
func DefaultPatchTopic(ctx context.Context, in *Topic, updateMask *field_mask1.FieldMask, db *gorm1.DB) (*Topic, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	var pbObj Topic
	var err error
	if hook, ok := interface{}(&pbObj).(TopicWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadTopic(ctx, &Topic{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(TopicWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskTopic(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(TopicWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateTopic(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(TopicWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type TopicWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *Topic, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type TopicWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *Topic, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type TopicWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *Topic, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type TopicWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *Topic, *field_mask1.FieldMask, *gorm1.DB) error
}

// DefaultPatchSetTopic executes a bulk gorm update call with patch behavior
func DefaultPatchSetTopic(ctx context.Context, objects []*Topic, updateMasks []*field_mask1.FieldMask, db *gorm1.DB) ([]*Topic, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors1.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*Topic, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchTopic(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskTopic patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskTopic(ctx context.Context, patchee *Topic, patcher *Topic, updateMask *field_mask1.FieldMask, prefix string, db *gorm1.DB) (*Topic, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors1.NilArgumentError
	}
	var err error
	var updatedTopicCoverImage bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"Name" {
			patchee.Name = patcher.Name
			continue
		}
		if f == prefix+"Tags" {
			patchee.Tags = patcher.Tags
			continue
		}
		if !updatedTopicCoverImage && strings.HasPrefix(f, prefix+"TopicCoverImage.") {
			updatedTopicCoverImage = true
			if patcher.TopicCoverImage == nil {
				patchee.TopicCoverImage = nil
				continue
			}
			if patchee.TopicCoverImage == nil {
				patchee.TopicCoverImage = &Image{}
			}
			if o, err := DefaultApplyFieldMaskImage(ctx, patchee.TopicCoverImage, patcher.TopicCoverImage, &field_mask1.FieldMask{Paths: updateMask.Paths[i:]}, prefix+"TopicCoverImage.", db); err != nil {
				return nil, err
			} else {
				patchee.TopicCoverImage = o
			}
			continue
		}
		if f == prefix+"TopicCoverImage" {
			updatedTopicCoverImage = true
			patchee.TopicCoverImage = patcher.TopicCoverImage
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListTopic executes a gorm list call
func DefaultListTopic(ctx context.Context, db *gorm1.DB) ([]*Topic, error) {
	in := Topic{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TopicORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm2.ApplyCollectionOperators(ctx, db, &TopicORM{}, &Topic{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TopicORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []TopicORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TopicORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*Topic{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type TopicORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type TopicORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type TopicORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm1.DB, *[]TopicORM) error
}

// DefaultCreateImage executes a basic gorm create call
func DefaultCreateImage(ctx context.Context, in *Image, db *gorm1.DB) (*Image, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ImageORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ImageORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type ImageORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ImageORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm1.DB) error
}

// DefaultReadImage executes a basic gorm read call
func DefaultReadImage(ctx context.Context, in *Image, db *gorm1.DB) (*Image, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(ImageORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm2.ApplyFieldSelection(ctx, db, nil, &ImageORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ImageORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := ImageORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(ImageORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type ImageORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ImageORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ImageORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm1.DB) error
}

func DefaultDeleteImage(ctx context.Context, in *Image, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(ImageORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&ImageORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(ImageORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type ImageORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ImageORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm1.DB) error
}

func DefaultDeleteImageSet(ctx context.Context, in []*Image, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	var err error
	keys := []uint32{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors1.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&ImageORM{})).(ImageORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&ImageORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&ImageORM{})).(ImageORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type ImageORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*Image, *gorm1.DB) (*gorm1.DB, error)
}
type ImageORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*Image, *gorm1.DB) error
}

// DefaultStrictUpdateImage clears first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateImage(ctx context.Context, in *Image, db *gorm1.DB) (*Image, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateImage")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &ImageORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(ImageORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(ImageORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ImageORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type ImageORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ImageORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ImageORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm1.DB) error
}

// DefaultPatchImage executes a basic gorm update call with patch behavior
func DefaultPatchImage(ctx context.Context, in *Image, updateMask *field_mask1.FieldMask, db *gorm1.DB) (*Image, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	var pbObj Image
	var err error
	if hook, ok := interface{}(&pbObj).(ImageWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadImage(ctx, &Image{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(ImageWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskImage(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(ImageWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateImage(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(ImageWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type ImageWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *Image, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type ImageWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *Image, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type ImageWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *Image, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type ImageWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *Image, *field_mask1.FieldMask, *gorm1.DB) error
}

// DefaultPatchSetImage executes a bulk gorm update call with patch behavior
func DefaultPatchSetImage(ctx context.Context, objects []*Image, updateMasks []*field_mask1.FieldMask, db *gorm1.DB) ([]*Image, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors1.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*Image, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchImage(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskImage patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskImage(ctx context.Context, patchee *Image, patcher *Image, updateMask *field_mask1.FieldMask, prefix string, db *gorm1.DB) (*Image, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors1.NilArgumentError
	}
	var err error
	var updatedMetadata bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if !updatedMetadata && strings.HasPrefix(f, prefix+"Metadata.") {
			if patcher.Metadata == nil {
				patchee.Metadata = nil
				continue
			}
			if patchee.Metadata == nil {
				patchee.Metadata = &ImageMeta{}
			}
			childMask := &field_mask1.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"Metadata."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm2.MergeWithMask(patcher.Metadata, patchee.Metadata, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"Metadata" {
			updatedMetadata = true
			patchee.Metadata = patcher.Metadata
			continue
		}
		if f == prefix+"BlobUrl" {
			patchee.BlobUrl = patcher.BlobUrl
			continue
		}
		if f == prefix+"AltText" {
			patchee.AltText = patcher.AltText
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListImage executes a gorm list call
func DefaultListImage(ctx context.Context, db *gorm1.DB) ([]*Image, error) {
	in := Image{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ImageORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm2.ApplyCollectionOperators(ctx, db, &ImageORM{}, &Image{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ImageORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []ImageORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ImageORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*Image{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type ImageORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ImageORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ImageORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm1.DB, *[]ImageORM) error
}
