(window.webpackJsonp=window.webpackJsonp||[]).push([[21],{82:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return o})),n.d(t,"metadata",(function(){return s})),n.d(t,"rightToc",(function(){return l})),n.d(t,"default",(function(){return u}));var a=n(2),r=n(6),i=(n(0),n(244)),o={title:"Clean Go Code"},s={unversionedId:"__guidelines/style_guide/golang/clean-code",id:"__guidelines/style_guide/golang/clean-code",isDocsHomePage:!1,title:"Clean Go Code",description:"This document is a reference for the Go community that aims to help developers write cleaner code. Whether you're working on a personal project or as part of a larger team, writing clean code is an important skill to have. Establishing good paradigms and consistent, accessible standards for writing clean code can help prevent developers from wasting many meaningless hours on trying to understand their own (or others') work.",source:"@site/docs/__guidelines/style_guide/golang/clean-code.md",slug:"/__guidelines/style_guide/golang/clean-code",permalink:"/docs/__guidelines/style_guide/golang/clean-code",version:"current",sidebar:"docs",previous:{title:"Security Policy",permalink:"/docs/__guidelines/security"},next:{title:"Common Golang P.R. Reviews",permalink:"/docs/__guidelines/style_guide/golang/common-review-comments"}},l=[{value:"Table of Contents",id:"table-of-contents",children:[]},{value:"Introduction to Clean Code",id:"introduction-to-clean-code",children:[{value:"Test-Driven Development",id:"test-driven-development",children:[]},{value:"Naming Conventions",id:"naming-conventions",children:[]},{value:"Cleaning Functions",id:"cleaning-functions",children:[]},{value:"Variable Scope",id:"variable-scope",children:[]},{value:"Variable Declaration",id:"variable-declaration",children:[]}]},{value:"Clean Go",id:"clean-go",children:[{value:"Return Values",id:"return-values",children:[]},{value:"Nil Values",id:"nil-values",children:[]},{value:"Pointers in Go",id:"pointers-in-go",children:[]},{value:"Closures Are Function Pointers",id:"closures-are-function-pointers",children:[]},{value:"Interfaces in Go",id:"interfaces-in-go",children:[]},{value:"The Empty <code>interface{}</code>",id:"the-empty-interface",children:[]}]},{value:"Summary",id:"summary",children:[]}],c={rightToc:l};function u(e){var t=e.components,n=Object(r.a)(e,["components"]);return Object(i.b)("wrapper",Object(a.a)({},c,n,{components:t,mdxType:"MDXLayout"}),Object(i.b)("p",null,"This document is a reference for the Go community that aims to help developers write cleaner code. Whether you're working on a personal project or as part of a larger team, writing clean code is an important skill to have. Establishing good paradigms and consistent, accessible standards for writing clean code can help prevent developers from wasting many meaningless hours on trying to understand their own (or others') work."),Object(i.b)("blockquote",null,Object(i.b)("em",null,"We don\u2019t read code, we ",Object(i.b)("b",null,"decode")," it \u2013 Peter Seibel")),Object(i.b)("p",null,"As developers, we're sometimes tempted to write code in a way that's convenient for the time being without regard for best practices; this makes code reviews and testing more difficult. In a sense, we're ",Object(i.b)("em",null,"encoding"),"\u2014","and, in doing so, making it more difficult for others to decode our work. But we want our code to be usable, readable, and maintainable. And that requires coding the ",Object(i.b)("em",null,"right")," way, not the easy way."),Object(i.b)("p",null,"This document begins with a simple and short introduction to the fundamentals of writing clean code. Later, we'll discuss concrete refactoring examples specific to Go."),Object(i.b)("h5",{id:"a-short-word-on-gofmt"},"A short word on ",Object(i.b)("inlineCode",{parentName:"h5"},"gofmt")),Object(i.b)("p",null,"I'd like to take a few sentences to clarify my stance on ",Object(i.b)("inlineCode",{parentName:"p"},"gofmt")," because there are plenty of things I disagree with when it comes to this tool. I prefer snake case over camel case, and I quite like my constant variables to be uppercase. And, naturally, I also have many opinions on bracket placement. ",Object(i.b)("em",{parentName:"p"},"That being said"),", ",Object(i.b)("inlineCode",{parentName:"p"},"gofmt")," does allow us to have a common standard for writing Go code, and that's a great thing. As a developer myself, I can certainly appreciate that Go programmers may feel somewhat restricted by ",Object(i.b)("inlineCode",{parentName:"p"},"gofmt"),", especially if they disagree with some of its rules. But in my opinion, homogeneous code is more important than having complete expressive freedom."),Object(i.b)("h2",{id:"table-of-contents"},"Table of Contents"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("a",Object(a.a)({parentName:"li"},{href:"#table-of-contents"}),"Table of Contents")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("a",Object(a.a)({parentName:"li"},{href:"#introduction-to-clean-code"}),"Introduction to Clean Code"),Object(i.b)("ul",{parentName:"li"},Object(i.b)("li",{parentName:"ul"},Object(i.b)("a",Object(a.a)({parentName:"li"},{href:"#test-driven-development"}),"Test-Driven Development")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("a",Object(a.a)({parentName:"li"},{href:"#naming-conventions"}),"Naming Conventions"),Object(i.b)("ul",{parentName:"li"},Object(i.b)("li",{parentName:"ul"},Object(i.b)("a",Object(a.a)({parentName:"li"},{href:"#comments"}),"Comments")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("a",Object(a.a)({parentName:"li"},{href:"#function-naming"}),"Function Naming")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("a",Object(a.a)({parentName:"li"},{href:"#variable-naming"}),"Variable Naming")))),Object(i.b)("li",{parentName:"ul"},Object(i.b)("a",Object(a.a)({parentName:"li"},{href:"#cleaning-functions"}),"Cleaning Functions"),Object(i.b)("ul",{parentName:"li"},Object(i.b)("li",{parentName:"ul"},Object(i.b)("a",Object(a.a)({parentName:"li"},{href:"#function-length"}),"Function Length")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("a",Object(a.a)({parentName:"li"},{href:"#function-signatures"}),"Function Signatures")))),Object(i.b)("li",{parentName:"ul"},Object(i.b)("a",Object(a.a)({parentName:"li"},{href:"#variable-scope"}),"Variable Scope")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("a",Object(a.a)({parentName:"li"},{href:"#variable-declaration"}),"Variable Declaration")))),Object(i.b)("li",{parentName:"ul"},Object(i.b)("a",Object(a.a)({parentName:"li"},{href:"#clean-go"}),"Clean Go"),Object(i.b)("ul",{parentName:"li"},Object(i.b)("li",{parentName:"ul"},Object(i.b)("a",Object(a.a)({parentName:"li"},{href:"#return-values"}),"Return Values"),Object(i.b)("ul",{parentName:"li"},Object(i.b)("li",{parentName:"ul"},Object(i.b)("a",Object(a.a)({parentName:"li"},{href:"#returning-defined-errors"}),"Returning Defined Errors")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("a",Object(a.a)({parentName:"li"},{href:"#returning-dynamic-errors"}),"Returning Dynamic Errors")))),Object(i.b)("li",{parentName:"ul"},Object(i.b)("a",Object(a.a)({parentName:"li"},{href:"#nil-values"}),"Nil Values")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("a",Object(a.a)({parentName:"li"},{href:"#pointers-in-go"}),"Pointers in Go"),Object(i.b)("ul",{parentName:"li"},Object(i.b)("li",{parentName:"ul"},Object(i.b)("a",Object(a.a)({parentName:"li"},{href:"#pointer-mutability"}),"Pointer Mutability")))),Object(i.b)("li",{parentName:"ul"},Object(i.b)("a",Object(a.a)({parentName:"li"},{href:"#closures-are-function-pointers"}),"Closures Are Function Pointers")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("a",Object(a.a)({parentName:"li"},{href:"#interfaces-in-go"}),"Interfaces in Go")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("a",Object(a.a)({parentName:"li"},{href:"#the-empty-interface"}),"The Empty ",Object(i.b)("inlineCode",{parentName:"a"},"interface{}"))))),Object(i.b)("li",{parentName:"ul"},Object(i.b)("a",Object(a.a)({parentName:"li"},{href:"#summary"}),"Summary"))),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("a",Object(a.a)({parentName:"li"},{href:"#Clean-Go"}),"Clean Go"),Object(i.b)("ul",{parentName:"li"},Object(i.b)("li",{parentName:"ul"},Object(i.b)("a",Object(a.a)({parentName:"li"},{href:"#Return-Values"}),"Return Values")," ",Object(i.b)("ul",{parentName:"li"},Object(i.b)("li",{parentName:"ul"},Object(i.b)("a",Object(a.a)({parentName:"li"},{href:"#Returning-Defined-Errors"}),"Returning Defined Errors")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("a",Object(a.a)({parentName:"li"},{href:"#Returning-Dynamic-Errors"}),"Returning Dynamic Errors")))),Object(i.b)("li",{parentName:"ul"},Object(i.b)("a",Object(a.a)({parentName:"li"},{href:"#Pointers-in-Go"}),"Pointers in Go")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("a",Object(a.a)({parentName:"li"},{href:"#Closures-are-Function-Pointers"}),"Closures Are Function Pointers")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("a",Object(a.a)({parentName:"li"},{href:"#Interfaces-in-Go"}),"Interfaces in Go")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("a",Object(a.a)({parentName:"li"},{href:"#The-Empty-Interface"}),"The Empty ",Object(i.b)("inlineCode",{parentName:"a"},"interface{}"))))),Object(i.b)("li",{parentName:"ul"},Object(i.b)("a",Object(a.a)({parentName:"li"},{href:"#Summary"}),"Summary"))),Object(i.b)("h2",{id:"introduction-to-clean-code"},"Introduction to Clean Code"),Object(i.b)("p",null,"Clean code is the pragmatic concept of promoting readable and maintainable software. Clean code establishes trust in the codebase and helps minimize the chances of careless bugs being introduced. It also helps developers maintain their agility, which typically plummets as the codebase expands due to the increased risk of introducing bugs."),Object(i.b)("h3",{id:"test-driven-development"},"Test-Driven Development"),Object(i.b)("p",null,"Test-driven development is the practice of testing your code frequently throughout short development cycles or sprints. It ultimately contributes to code cleanliness by inviting developers to question the functionality and purpose of their code. To make testing easier, developers are encouraged to write short functions that only do one thing. For example, it's arguably much easier to test (and understand) a function that's only 4 lines long than one that's 40."),Object(i.b)("p",null,"Test-driven development consists of the following cycle:"),Object(i.b)("ol",null,Object(i.b)("li",{parentName:"ol"},"Write (or execute) a test"),Object(i.b)("li",{parentName:"ol"},"If the test fails, make it pass"),Object(i.b)("li",{parentName:"ol"},"Refactor your code accordingly"),Object(i.b)("li",{parentName:"ol"},"Repeat")),Object(i.b)("p",null,"Testing and refactoring are intertwined in this process. As you refactor your code to make it more understandable or maintainable, you need to test your changes thoroughly to ensure that you haven't altered the behavior of your functions. This can be incredibly useful as the codebase grows."),Object(i.b)("h3",{id:"naming-conventions"},"Naming Conventions"),Object(i.b)("h4",{id:"comments"},"Comments"),Object(i.b)("p",null,'I\'d like to first address the topic of commenting code, which is an essential practice but tends to be misapplied. Unnecessary comments can indicate problems with the underlying code, such as the use of poor naming conventions. However, whether or not a particular comment is "necessary" is somewhat subjective and depends on how legibly the code was written. For example, the logic of well-written code may still be so complex that it requires a comment to clarify what is going on. In that case, one might argue that the comment is ',Object(i.b)("em",null,"helpful")," and therefore necessary."),Object(i.b)("p",null,"In Go, according to ",Object(i.b)("inlineCode",{parentName:"p"},"gofmt"),", ",Object(i.b)("em",null,"all")," public variables and functions should be annotated. I think this is absolutely fine, as it gives us consistent rules for documenting our code. However, I always want to distinguish between comments that enable auto-generated documentation and ",Object(i.b)("em",null,"all other")," comments. Annotation comments, for documentation, should be written like documentation","\u2014","they should be at a high level of abstraction and concern the logical implementation of the code as little as possible."),Object(i.b)("p",null,"I say this because there are other ways to explain code and ensure that it's being written comprehensibly and expressively. If the code is neither of those, some people find it acceptable to introduce a comment explaining the convoluted logic. Unfortunately, that doesn't really help. For one, most people simply won't read comments, as they tend to be very intrusive to the experience of reviewing code. Additionally, as you can imagine, a developer won't be too happy if they're forced to review unclear code that's been slathered with comments. The less that people have to read to understand what your code is doing, the better off they'll be."),Object(i.b)("p",null,"Let's take a step back and look at some concrete examples. Here's how you ",Object(i.b)("em",null,"shouldn't")," comment your code:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-go"}),"// iterate over the range 0 to 9 \n// and invoke the doSomething function\n// for each iteration\nfor i := 0; i < 10; i++ {\n  doSomething(i)\n}\n")),Object(i.b)("p",null,"This is what I like to call a ",Object(i.b)("strong",null,"tutorial comment"),"; it's fairly common in tutorials, which often explain the low-level functionality of a language (or programming in general). While these comments may be helpful for beginners, they're absolutely useless in production code. Hopefully, we aren't collaborating with programmers who don't understand something as simple as a looping construct by the time they've begun working on a development team. As programmers, we shouldn't have to read the comment to understand what's going on","\u2014","we know that we're iterating over the range 0 to 9 because we can simply read the code. Hence the proverb:"),Object(i.b)("blockquote",null,Object(i.b)("em",null,"Document why, not how. \u2013 Venkat Subramaniam")),Object(i.b)("p",null,"Following this logic, we can now change our comment to explain ",Object(i.b)("em",null,"why")," we are iterating from the range 0 to 9:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-go"}),"// instatiate 10 threads to handle upcoming work load\nfor i := 0; i < 10; i++ {\n  doSomething(i)\n}\n")),Object(i.b)("p",null,"Now we understand ",Object(i.b)("em",null,"why")," we have a loop and can tell ",Object(i.b)("em",null,"what")," we're doing by simply reading the code... Sort of."),Object(i.b)("p",null,"This still isn't what I'd consider clean code. The comment is worrying because it probably should not be necessary to express such an explanation in prose, assuming the code is well written (which it isn't). Technically, we're still saying what we're doing, not why we're doing it. We can easily express this \"what\" directly in our code by using more meaningful names:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-go"}),"for workerID := 0; workerID < 10; workerID++ {\n  instantiateThread(workerID)\n}\n")),Object(i.b)("p",null,"With just a few changes to our variable and function names, we've managed to explain what we're doing directly in our code. This is much clearer for the reader because they won't have to read the comment and then map the prose to the code. Instead, they can simply read the code to understand what it's doing."),Object(i.b)("p",null,"Of course, this was a relatively trivial example. Writing clear and expressive code is unfortunately not always so easy; it can become increasingly difficult as the codebase itself grows in complexity. The more you practice writing comments in this mindset and avoid explaining what you're doing, the cleaner your code will become."),Object(i.b)("h4",{id:"function-naming"},"Function Naming"),Object(i.b)("p",null,"Let's now move on to function naming conventions. The general rule here is really simple: the more specific the function, the more general its name. In other words, we want to start with a very broad and short function name, such as ",Object(i.b)("inlineCode",{parentName:"p"},"Run")," or ",Object(i.b)("inlineCode",{parentName:"p"},"Parse"),", that describes the general functionality. Let's imagine that we are creating a configuration parser. Following this naming convention, our top level of abstraction might look something like the following:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-go"}),'func main() {\n    configpath := flag.String("config-path", "", "configuration file path")\n    flag.Parse()\n\n    config, err := configuration.Parse(*configpath)\n    \n    ...\n}\n')),Object(i.b)("p",null,"We'll focus on the naming of the ",Object(i.b)("inlineCode",{parentName:"p"},"Parse")," function. Despite this function's very short and general name, it's actually quite clear what it attempts to achieve."),Object(i.b)("p",null,"When we go one layer deeper, our function naming will become slightly more specific:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-go"}),'func Parse(filepath string) (Config, error) {\n    switch fileExtension(filepath) {\n    case "json":\n        return parseJSON(filepath)\n    case "yaml":\n        return parseYAML(filepath)\n    case "toml":\n        return parseTOML(filepath)\n    default:\n        return Config{}, ErrUnknownFileExtension\n    }\n}\n')),Object(i.b)("p",null,"Here, we've clearly distinguished the nested function calls from their parent without being overly specific. This allows each nested function call to make sense on its own as well as within the context of the parent. On the other hand, if we had named the ",Object(i.b)("inlineCode",{parentName:"p"},"parseJSON")," function ",Object(i.b)("inlineCode",{parentName:"p"},"json")," instead, it couldn't possibly stand on its own. The functionality would become lost in the name, and we would no longer be able to tell whether this function is parsing, creating, or marshalling JSON. "),Object(i.b)("p",null,"Notice that ",Object(i.b)("inlineCode",{parentName:"p"},"fileExtension")," is actually a little more specific. However, this is because its functionality is in fact quite specific in nature:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-go"}),'func fileExtension(filepath string) string {\n    segments := strings.Split(filepath, ".")\n    return segments[len(segments)-1]\n}\n')),Object(i.b)("p",null,"This kind of logical progression in our function names","\u2014","from a high level of abstraction to a lower, more specific one","\u2014","makes the code easier to follow and read. Consider the alternative: If our highest level of abstraction is too specific, then we'll end up with a name that attempts to cover all bases, like ",Object(i.b)("inlineCode",{parentName:"p"},"DetermineFileExtensionAndParseConfigurationFile"),". This is horrendously difficult to read; we are trying to be too specific too soon and end up confusing the reader, despite trying to be clear! "),Object(i.b)("h4",{id:"variable-naming"},"Variable Naming"),Object(i.b)("p",null,"Rather interestingly, the opposite is true for variables. Unlike functions, our variables should be named from more to less specific the deeper we go into nested scopes."),Object(i.b)("blockquote",null,Object(i.b)("em",null,"You shouldn\u2019t name your variables after their types for the same reason you wouldn\u2019t name your pets 'dog' or 'cat'. \u2013 Dave Cheney")),Object(i.b)("p",null,"Why should our variable names become less specific as we travel deeper into a function's scope? Simply put, as a variable's scope becomes smaller, it becomes increasingly clear for the reader what that variable represents, thereby eliminating the need for specific naming. In the example of the previous function ",Object(i.b)("inlineCode",{parentName:"p"},"fileExtension"),", we could even shorten the name of the variable ",Object(i.b)("inlineCode",{parentName:"p"},"segments")," to ",Object(i.b)("inlineCode",{parentName:"p"},"s")," if we wanted to. The context of the variable is so clear that it's unnecessary to explain it any further with longer variable names. Another good example of this is in nested for loops:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-go"}),"func PrintBrandsInList(brands []BeerBrand) {\n    for _, b := range brands { \n        fmt.Println(b)\n    }\n}\n")),Object(i.b)("p",null,"In the above example, the scope of the variable ",Object(i.b)("inlineCode",{parentName:"p"},"b")," is so small that we don't need to spend any additional brain power on remembering what exactly it represents. However, because the scope of ",Object(i.b)("inlineCode",{parentName:"p"},"brands")," is slightly larger, it helps for it to be more specific. When expanding the variable scope in the function below, this distinction becomes even more apparent:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-go"}),"func BeerBrandListToBeerList(beerBrands []BeerBrand) []Beer {\n    var beerList []Beer\n    for _, brand := range beerBrands {\n        for _, beer := range brand {\n            beerList = append(beerList, beer)\n        }\n    }\n    return beerList\n}\n")),Object(i.b)("p",null,"Great! This function is easy to read. Now, let's apply the opposite (i.e., wrong) logic when naming our variables:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-go"}),"func BeerBrandListToBeerList(b []BeerBrand) []Beer {\n    var bl []Beer\n    for _, beerBrand := range b {\n        for _, beerBrandBeerName := range beerBrand {\n            bl = append(bl, beerBrandBeerName)\n        }\n    }\n    return bl\n}\n")),Object(i.b)("p",null,"Even though it's possible to figure out what this function is doing, the excessive brevity of the variable names makes it difficult to follow the logic as we travel deeper. This could very well spiral into full-blown confusion because we're mixing short and long variable names inconsistently."),Object(i.b)("h3",{id:"cleaning-functions"},"Cleaning Functions"),Object(i.b)("p",null,"Now that we know some best practices for naming our variables and functions, as well as clarifying our code with comments, let's dive into some specifics of how we can refactor functions to make them cleaner."),Object(i.b)("h4",{id:"function-length"},"Function Length"),Object(i.b)("blockquote",null,Object(i.b)("em",null,"How small should a function be? Smaller than that! \u2013 Robert C. Martin")),Object(i.b)("p",null,"When writing clean code, our primary goal is to make our code easily digestible. The most effective way to do this is to make our functions as short as possible. It's important to understand that we don't necessarily do this to avoid code duplication. The more important reason is to improve ",Object(i.b)("em",null,"code comprehension"),"."),Object(i.b)("p",null,"It can help to look at a function's description at a very high level to understand this better:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{}),"fn GetItem:\n    - parse json input for order id\n    - get user from context\n    - check user has appropriate role\n    - get order from database\n")),Object(i.b)("p",null,"By writing short functions (which are typically 5","\u2013","8 lines in Go), we can create code that reads almost as naturally as our description above:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-go"}),'var (\n    NullItem = Item{}\n    ErrInsufficientPrivileges = errors.New("user does not have sufficient privileges")\n)\n\nfunc GetItem(ctx context.Context, json []bytes) (Item, error) {\n    order, err := NewItemFromJSON(json)\n    if err != nil {\n        return NullItem, err\n    }\n    if !GetUserFromContext(ctx).IsAdmin() {\n          return NullItem, ErrInsufficientPrivileges\n    }\n    return db.GetItem(order.ItemID)\n}\n')),Object(i.b)("p",null,"Using smaller functions also eliminates another horrible habit of writing code: indentation hell. ",Object(i.b)("strong",null,"Indentation hell")," typically occurs when a chain of ",Object(i.b)("inlineCode",{parentName:"p"},"if")," statements are carelessly nested in a function. This makes it ",Object(i.b)("em",null,"very")," difficult for human beings to parse the code and should be eliminated whenever spotted. Indentation hell is particularly common when working with ",Object(i.b)("inlineCode",{parentName:"p"},"interface{}")," and using type casting:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-go"}),'func GetItem(extension string) (Item, error) {\n    if refIface, ok := db.ReferenceCache.Get(extension); ok {\n        if ref, ok := refIface.(string); ok {\n            if itemIface, ok := db.ItemCache.Get(ref); ok {\n                if item, ok := itemIface.(Item); ok {\n                    if item.Active {\n                        return Item, nil\n                    } else {\n                      return EmptyItem, errors.New("no active item found in cache")\n                    }\n                } else {\n                  return EmptyItem, errors.New("could not cast cache interface to Item")\n                }\n            } else {\n              return EmptyItem, errors.New("extension was not found in cache reference")\n            }\n        } else {\n          return EmptyItem, errors.New("could not cast cache reference interface to Item")\n        }\n    }\n    return EmptyItem, errors.New("reference not found in cache")\n}\n')),Object(i.b)("p",null,"First, indentation hell makes it difficult for other developers to understand the flow of your code. Second, if the logic in our ",Object(i.b)("inlineCode",{parentName:"p"},"if")," statements expands, it'll become exponentially more difficult to figure out which statement returns what (and to ensure that all paths return some value). Yet another problem is that this deep nesting of conditional statements forces the reader to frequently scroll and keep track of many logical states in their head. It also makes it more difficult to test the code and catch bugs because there are so many different nested possibilities that you have to account for."),Object(i.b)("p",null,"Indentation hell can result in reader fatigue if a developer has to constantly parse unwieldy code like the sample above. Naturally, this is something we want to avoid at all costs."),Object(i.b)("p",null,"So, how do we clean this function? Fortunately, it's actually quite simple. On our first iteration, we will try to ensure that we are returning an error as soon as possible. Instead of nesting the ",Object(i.b)("inlineCode",{parentName:"p"},"if")," and ",Object(i.b)("inlineCode",{parentName:"p"},"else"),' statements, we want to "push our code to the left," so to speak. Take a look:'),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-go"}),'func GetItem(extension string) (Item, error) {\n    refIface, ok := db.ReferenceCache.Get(extension)\n    if !ok {\n        return EmptyItem, errors.New("reference not found in cache")\n    }\n\n    ref, ok := refIface.(string)\n    if !ok {\n        // return cast error on reference \n    }\n\n    itemIface, ok := db.ItemCache.Get(ref)\n    if !ok {\n        // return no item found in cache by reference\n    }\n\n    item, ok := itemIface.(Item)\n    if !ok {\n        // return cast error on item interface\n    }\n\n    if !item.Active {\n        // return no item active\n    }\n\n    return Item, nil\n}\n')),Object(i.b)("p",null,"Once we're done with our first attempt at refactoring the function, we can proceed to split up the function into smaller functions. Here's a good rule of thumb:  If the ",Object(i.b)("inlineCode",{parentName:"p"},"value, err :=")," pattern is repeated more than once in a function, this is an indication that we can split the logic of our code into smaller pieces:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-go"}),"func GetItem(extension string) (Item, error) {\n    ref, ok := getReference(extension)\n    if !ok {\n        return EmptyItem, ErrReferenceNotFound\n    }\n    return getItemByReference(ref)\n}\n\nfunc getReference(extension string) (string, bool) {\n    refIface, ok := db.ReferenceCache.Get(extension)\n    if !ok {\n        return EmptyItem, false\n    }\n    return refIface.(string)\n}\n\nfunc getItemByReference(reference string) (Item, error) {\n    item, ok := getItemFromCache(reference)\n    if !item.Active || !ok {\n        return EmptyItem, ErrItemNotFound\n    }\n    return Item, nil\n}\n\nfunc getItemFromCache(reference string) (Item, bool) {\n    if itemIface, ok := db.ItemCache.Get(ref); ok {\n        return EmptyItem, false\n    }\n    return itemIface.(Item), true\n}\n")),Object(i.b)("p",null,"As mentioned previously, indentation hell can make it difficult to test our code. When we split up our ",Object(i.b)("inlineCode",{parentName:"p"},"GetItem")," function into several helpers, we make it easier to track down bugs when testing our code. Unlike the original version, which consisted of several ",Object(i.b)("inlineCode",{parentName:"p"},"if")," statements in the same scope, the refactored version of ",Object(i.b)("inlineCode",{parentName:"p"},"GetItem")," has just two branching paths that we must consider. The helper functions are also short and digestible, making them easier to read."),Object(i.b)("blockquote",null,Object(i.b)("p",{parentName:"blockquote"},"Note: For production code, one should elaborate on the code even further by returning errors instead of ",Object(i.b)("inlineCode",{parentName:"p"},"bool")," values. This makes it much easier to understand where the error is originating from. However, as these are just example functions, returning ",Object(i.b)("inlineCode",{parentName:"p"},"bool")," values will suffice for now. Examples of returning errors more explicitly will be explained in more detail later.")),Object(i.b)("p",null,"Notice that cleaning the ",Object(i.b)("inlineCode",{parentName:"p"},"GetItem")," function resulted in more lines of code overall. However, the code itself is now much easier to read. It's layered in an onion-style fashion, where we can ignore \"layers\" that we aren't interested in and simply peel back the ones that we do want to examine. This makes it easier to understand low-level functionality because we only have to read maybe 3","\u2013","5 lines at a time."),Object(i.b)("p",null,"This example illustrates that we cannot measure the cleanliness of our code by the number of lines it uses. The first version of the code was certainly much shorter. However, it was ",Object(i.b)("em",null,"artificially")," short and very difficult to read. In most cases, cleaning code will initially expand the existing codebase in terms of the number of lines. But this is highly preferable to the alternative of having messy, convoluted logic. If you're ever in doubt about this, just consider how you feel about the following function, which does exactly the same thing as our code but only uses two lines:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-go"}),'func GetItemIfActive(extension string) (Item, error) {\n    if refIface,ok := db.ReferenceCache.Get(extension); ok {if ref,ok := refIface.(string); ok { if itemIface,ok := db.ItemCache.Get(ref); ok { if item,ok := itemIface.(Item); ok { if item.Active { return Item,nil }}}}} return EmptyItem, errors.New("reference not found in cache")\n}\n')),Object(i.b)("h4",{id:"function-signatures"},"Function Signatures"),Object(i.b)("p",null,"Creating a good function naming structure makes it easier to read and understand the intent of the code. As we saw above, making our functions shorter helps us understand the function's logic. The last part of cleaning our functions involves understanding the context of the function input. With this comes another easy-to-follow rule: ",Object(i.b)("strong",null,"Function signatures should only contain one or two input parameters"),". In certain exceptional cases, three can be acceptable, but this is where we should start considering a refactor. Much like the rule that our functions should only be 5","\u2013","8 lines long, this can seem quite extreme at first. However, I feel that this rule is much easier to justify."),Object(i.b)("p",null,"Take the following function from ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"https://www.rabbitmq.com/tutorials/tutorial-one-go.html"}),"RabbitMQ's introduction tutorial to its Go library"),":"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-go"}),'q, err := ch.QueueDeclare(\n  "hello", // name\n  false,   // durable\n  false,   // delete when unused\n  false,   // exclusive\n  false,   // no-wait\n  nil,     // arguments\n)\n')),Object(i.b)("p",null,"The function ",Object(i.b)("inlineCode",{parentName:"p"},"QueueDeclare")," takes six input parameters, which is quite a lot. With some effort, it's possible to understand what this code does thanks to the comments. However, the comments are actually part of the problem","\u2014","as mentioned earlier, they should be substituted with descriptive code whenever possible. After all, there's nothing preventing us from invoking the ",Object(i.b)("inlineCode",{parentName:"p"},"QueueDeclare")," function ",Object(i.b)("em",null,"without")," comments:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-go"}),'q, err := ch.QueueDeclare("hello", false, false, false, false, nil)\n')),Object(i.b)("p",null,"Now, without looking at the commented version, try to remember what the fourth and fifth ",Object(i.b)("inlineCode",{parentName:"p"},"false")," arguments represent. It's impossible, right? You will inevitably forget at some point. This can lead to costly mistakes and bugs that are difficult to correct. The mistakes might even occur through incorrect comments","\u2014","imagine labeling the wrong input parameter. Correcting this mistake will be unbearably difficult to correct, especially when familiarity with the code has deteriorated over time or was low to begin with. Therefore, it is recommended to replace these input parameters with an 'Options' ",Object(i.b)("inlineCode",{parentName:"p"},"struct")," instead:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-go"}),'type QueueOptions struct {\n    Name string\n    Durable bool\n    DeleteOnExit bool\n    Exclusive bool\n    NoWait bool\n    Arguments []interface{} \n}\n\nq, err := ch.QueueDeclare(QueueOptions{\n    Name: "hello",\n    Durable: false,\n    DeleteOnExit: false,\n    Exclusive: false,\n    NoWait: false,\n    Arguments: nil,\n})\n')),Object(i.b)("p",null,"This solves two problems: misusing comments, and accidentally labeling the variables incorrectly. Of course, we can still confuse properties with the wrong value, but in these cases, it will be much easier to determine where our mistake lies within the code. The ordering of the properties also doesn't matter anymore, so incorrectly ordering the input values is no longer a concern. The last added bonus of this technique is that we can use our ",Object(i.b)("inlineCode",{parentName:"p"},"QueueOptions")," struct to infer the default values of our function's input parameters. When structures in Go are declared, all properties are initialised to their default value. This means that our ",Object(i.b)("inlineCode",{parentName:"p"},"QueueDeclare")," option can actually be invoked in the following way:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-go"}),'q, err := ch.QueueDeclare(QueueOptions{\n    Name: "hello",\n})\n')),Object(i.b)("p",null,"The rest of the values are initialised to their default value of ",Object(i.b)("inlineCode",{parentName:"p"},"false")," (except for ",Object(i.b)("inlineCode",{parentName:"p"},"Arguments"),", which as an interface has a default value of ",Object(i.b)("inlineCode",{parentName:"p"},"nil"),"). Not only are we much safer with this approach, but we are also much clearer with our intentions. In this case, we could actually write less code. This is an all-around win for everyone on the project."),Object(i.b)("p",null,"One final note on this: It's not always possible to change a function's signature. In this case, for example, we don't actually have control over our ",Object(i.b)("inlineCode",{parentName:"p"},"QueueDeclare")," function signature because it's from the RabbitMQ library. It's not our code, so we can't change it. However, we can wrap these functions to suit our purposes:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-go"}),"type RMQChannel struct {\n    channel *amqp.Channel\n}\n\nfunc (rmqch *RMQChannel) QueueDeclare(opts QueueOptions) (Queue, error) {\n    return rmqch.channel.QueueDeclare(\n        opts.Name,\n        opts.Durable,\n        opts.DeleteOnExit,\n        opts.Exclusive,\n        opts.NoWait,\n        opts.Arguments, \n    )\n} \n")),Object(i.b)("p",null,"Basically, we create a new structure named ",Object(i.b)("inlineCode",{parentName:"p"},"RMQChannel")," that contains the ",Object(i.b)("inlineCode",{parentName:"p"},"amqp.Channel")," type, which has the ",Object(i.b)("inlineCode",{parentName:"p"},"QueueDeclare")," method. We then create our own version of this method, which essentially just calls the old version of the RabbitMQ library function. Our new method has all the advantages described before, and we achieved this without actually having to change any of the code in the RabbitMQ library."),Object(i.b)("p",null,"We'll use this idea of wrapping functions to introduce more clean and safe code later when discussing ",Object(i.b)("inlineCode",{parentName:"p"},"interface{}"),"."),Object(i.b)("h3",{id:"variable-scope"},"Variable Scope"),Object(i.b)("p",null,"Now, let's take a step back and revisit the idea of writing smaller functions. This has another nice side effect that we didn't cover in the previous chapter: Writing smaller functions can typically eliminate reliance on mutable variables that leak into the global scope. "),Object(i.b)("p",null,"Global variables are problematic and don't belong in clean code; they make it very difficult for programmers to understand the current state of a variable. If a variable is global and mutable, then by definition, its value can be changed by any part of the codebase. At no point can you guarantee that this variable is going to be a specific value... And that's a headache for everyone. This is yet another example of a trivial problem that's exacerbated when the codebase expands."),Object(i.b)("p",null,"Let's look at a short example of how non-global variables with a large scope can cause problems. These variables also introduce the issue of ",Object(i.b)("strong",null,"variable shadowing"),", as demonstrated in the code taken from an article titled ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"https://idiallo.com/blog/golang-scopes"}),"Golang scope issue"),":"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-go"}),'func doComplex() (string, error) {\n    return "Success", nil\n}\n\nfunc main() {\n    var val string\n    num := 32\n\n    switch num {\n    case 16:\n    // do nothing\n    case 32:\n        val, err := doComplex()\n        if err != nil {\n            panic(err)\n        }\n        if val == "" {\n            // do something else\n        }\n    case 64:\n        // do nothing\n    }\n    \n    fmt.Println(val)\n}\n')),Object(i.b)("p",null,"What's the problem with this code? From a quick skim, it seems the ",Object(i.b)("inlineCode",{parentName:"p"},"var val string")," value should be printed out as ",Object(i.b)("inlineCode",{parentName:"p"},"Success")," by the end of the ",Object(i.b)("inlineCode",{parentName:"p"},"main")," function. Unfortunately, this is not the case. The reason for this lies in the following line:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-go"}),"val, err := doComplex()\n")),Object(i.b)("p",null,"This declares a new variable ",Object(i.b)("inlineCode",{parentName:"p"},"val")," in the switch's ",Object(i.b)("inlineCode",{parentName:"p"},"case 32")," scope and has nothing to do with the variable declared in the first line of ",Object(i.b)("inlineCode",{parentName:"p"},"main"),". Of course, it can be argued that Go syntax is a little tricky, which I don't necessarily disagree with, but there is a much worse issue at hand. The declaration of ",Object(i.b)("inlineCode",{parentName:"p"},"var val string")," as a mutable, largely scoped variable is completely unnecessary. If we do a ",Object(i.b)("strong",null,"very")," simple refactor, we will no longer have this issue:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-go"}),'func getStringResult(num int) (string, error) {\n    switch num {\n    case 16:\n    // do nothing\n    case 32:\n       return doComplex()\n    case 64:\n        // do nothing\n    }\n    return "" \n}\n\nfunc main() {\n    val, err := getStringResult(32)\n    if err != nil {\n        panic(err)\n    }\n    if val == "" {\n        // do something else\n    }\n    fmt.Println(val)\n}\n')),Object(i.b)("p",null,"After our refactor, ",Object(i.b)("inlineCode",{parentName:"p"},"val")," is no longer modified, and the scope has been reduced. Again, keep in mind that these functions are very simple. Once this kind of code style becomes a part of larger, more complex systems, it can be impossible to figure out why errors are occurring. We don't want this to happen","\u2014","not only because we generally dislike software errors but also because it's disrespectful to our colleagues, and ourselves; we are potentially wasting each other's time having to debug this type of code. Developers need to take responsibility for their own code rather than blaming these issues on the variable declaration syntax of a particular language like Go."),Object(i.b)("p",null,"On a side note, if the ",Object(i.b)("inlineCode",{parentName:"p"},"// do something else")," part is another attempt to mutate the ",Object(i.b)("inlineCode",{parentName:"p"},"val")," variable, we should extract that logic out as its own self-contained function, as well as the previous part of it. This way, instead of expanding the mutable scope of our variables, we can just return a new value:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-go"}),'func getVal(num int) (string, error) {\n    val, err := getStringResult(32)\n    if err != nil {\n        return "", err\n    }\n    if val == "" {\n        return NewValue() // pretend function\n    }\n}\n\nfunc main() {\n    val, err := getVal(32)\n    if err != nil {\n        panic(err)\n    }\n    fmt.Println(val)\n}\n')),Object(i.b)("h3",{id:"variable-declaration"},"Variable Declaration"),Object(i.b)("p",null,"Other than avoiding issues with variable scope and mutability, we can also improve readability by declaring variables as close to their usage as possible. In C programming, it's common to see the following approach to declaring variables:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-go"}),"func main() {\n  var err error\n  var items []Item\n  var sender, receiver chan Item\n  \n  items = store.GetItems()\n  sender = make(chan Item)\n  receiver = make(chan Item)\n  \n  for _, item := range items {\n    ...\n  }\n}\n")),Object(i.b)("p",null,"This suffers from the same symptom as described in our discussion of variable scope. Even though these variables might not actually be reassigned at any point, this kind of coding style keeps the readers on their toes, in all the wrong ways. Much like computer memory, our brain's short-term memory has a limited capacity. Having to keep track of which variables are mutable and whether or not a particular fragment of code will mutate them makes it more difficult to understand what the code is doing. Figuring out the eventually returned value can be a nightmare. Therefore, to makes this easier for our readers (and our future selves), it's recommended that you declare variables as close to their usage as possible:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-go"}),"func main() {\n    var sender chan Item\n    sender = make(chan Item)\n\n    go func() {\n        for {\n            select {\n            case item := <-sender:\n                // do something\n            }\n        }\n    }()\n}\n")),Object(i.b)("p",null,"However, we can do even better by invoking the function directly after its declaration. This makes it much clearer that the function logic is associated with the declared variable:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-go"}),"func main() {\n  sender := func() chan Item {\n    channel := make(chan Item)\n    go func() {\n      for {\n        select { ... }\n      }\n    }()\n    return channel\n  }\n}\n")),Object(i.b)("p",null,"And coming full circle, we can move the anonymous function to make it a named function instead:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-go"}),"func main() {\n  sender := NewSenderChannel()\n}\n\nfunc NewSenderChannel() chan Item {\n  channel := make(chan Item)\n  go func() {\n    for {\n      select { ... }\n    }\n  }()\n  return channel\n}\n")),Object(i.b)("p",null,"It is still clear that we are declaring a variable, and the logic associated with the returned channel is simple, unlike in the first example. This makes it easier to traverse the code and understand the role of each variable."),Object(i.b)("p",null,"Of course, this doesn't actually prevent us from mutating our ",Object(i.b)("inlineCode",{parentName:"p"},"sender")," variable. There is nothing that we can do about this, as there is no way of declaring a ",Object(i.b)("inlineCode",{parentName:"p"},"const struct")," or ",Object(i.b)("inlineCode",{parentName:"p"},"static")," variables in Go. This means that we'll have to restrain ourselves from modifying this variable at a later point in the code."),Object(i.b)("blockquote",null,Object(i.b)("p",{parentName:"blockquote"},"NOTE: The keyword ",Object(i.b)("inlineCode",{parentName:"p"},"const")," does exist but is limited in use to primitive types only.")),Object(i.b)("p",null,"One way of getting around this can at least limit the mutability of a variable to the package level. The trick involves creating a structure with the variable as a private property. This private property is thenceforth only accessible through other methods provided by this wrapping structure. Expanding on our channel example, this would look something like the following:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-go"}),"type Sender struct {\n  sender chan Item\n}\n\nfunc NewSender() *Sender {\n  return &Sender{\n    sender: NewSenderChannel(),\n  }\n}\n\nfunc (s *Sender) Send(item Item) {\n  s.sender <- item\n}\n")),Object(i.b)("p",null,"We have now ensured that the ",Object(i.b)("inlineCode",{parentName:"p"},"sender")," property of our ",Object(i.b)("inlineCode",{parentName:"p"},"Sender")," struct is never mutated","\u2014","at least not from outside of the package. As of writing this document, this is the only way of creating publicly immutable non-primitive variables. It's a little verbose, but it's truly worth the effort to ensure that we don't end up with strange bugs resulting from accidental variable modification. "),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-go"}),"func main() {\n  sender := NewSender()\n  sender.Send(&Item{})\n}\n")),Object(i.b)("p",null,"Looking at the example above, it's clear how this also simplifies the usage of our package. This way of hiding the implementation is beneficial not only for the maintainers of the package but also for the users. Now, when initialising and using the ",Object(i.b)("inlineCode",{parentName:"p"},"Sender")," structure, there is no concern over its implementation. This opens up for a much looser architecture. Because our users aren't concerned with the implementation, we are free to change it at any point, since we have reduced the point of contact that users have with the package. If we no longer wish to use a channel implementation in our package, we can easily change this without breaking the usage of the ",Object(i.b)("inlineCode",{parentName:"p"},"Send")," method (as long as we adhere to its current function signature)."),Object(i.b)("blockquote",null,Object(i.b)("p",{parentName:"blockquote"}," NOTE: There is a fantastic explanation of how to handle the abstraction in client libraries, taken from the talk ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"https://www.youtube.com/watch?v=kJq81Y7OEx4"}),"AWS re:Invent 2017: Embracing Change without Breaking the World (DEV319)"),".")),Object(i.b)("h2",{id:"clean-go"},"Clean Go"),Object(i.b)("p",null,"This section focuses less on the generic aspects of writing clean Go code and more on the specifics, with an emphasis on the underlying clean code principles."),Object(i.b)("h3",{id:"return-values"},"Return Values"),Object(i.b)("h4",{id:"returning-defined-errors"},"Returning Defined Errors"),Object(i.b)("p",null,"We'll start things off nice and easy by describing a cleaner way to return errors. As we discussed earlier, our main goal with writing clean code is to ensure readability, testability, and maintainability of the codebase. The technique for returning errors that we'll discuss here will achieve all three of those goals with very little effort."),Object(i.b)("p",null,"Let's consider the normal way to return a custom error. This is a hypothetical example taken from a thread-safe map implementation that we've named ",Object(i.b)("inlineCode",{parentName:"p"},"Store"),":"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-go"}),'package smelly\n\nfunc (store *Store) GetItem(id string) (Item, error) {\n    store.mtx.Lock()\n    defer store.mtx.Unlock()\n\n    item, ok := store.items[id]\n    if !ok {\n        return Item{}, errors.New("item could not be found in the store") \n    }\n    return item, nil\n}\n')),Object(i.b)("p",null,"There is nothing inherently smelly about this function when we consider it in isolation. We look into the ",Object(i.b)("inlineCode",{parentName:"p"},"items")," map of our ",Object(i.b)("inlineCode",{parentName:"p"},"Store")," struct to see if we already have an item with the given ",Object(i.b)("inlineCode",{parentName:"p"},"id"),". If we do, we return it; otherwise, we return an error. Pretty standard. So, what is the issue with returning custom errors as string values? Well, let's look at what happens when we use this function inside another package:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-go"}),'func GetItemHandler(w http.ReponseWriter, r http.Request) {\n    item, err := smelly.GetItem("123")\n    if err != nil {\n        if err.Error() == "item could not be found in the store" {\n            http.Error(w, err.Error(), http.StatusNotFound)\n            return\n        }\n        http.Error(w, errr.Error(), http.StatusInternalServerError)\n        return\n    } \n    json.NewEncoder(w).Encode(item)\n}\n')),Object(i.b)("p",null,"This is actually not too bad. However, there is one glaring problem: An error in Go is simply an ",Object(i.b)("inlineCode",{parentName:"p"},"interface")," that implements a function (",Object(i.b)("inlineCode",{parentName:"p"},"Error()"),") returning a string; thus, we are now hardcoding the expected error code into our codebase, which isn't ideal. This hardcoded string is known as a ",Object(i.b)("strong",null,"magic string"),". And its main problem is flexibility: If at some point we decide to change the string value used to represent an error, our code will break (softly) unless we update it in possibly many different places. Our code is tightly coupled","\u2014","it relies on that specific magic string and the assumption that it will never change as the codebase grows."),Object(i.b)("p",null,"An even worse situation would arise if a client were to use our package in their own code. Imagine that we decided to update our package and changed the string that represents an error","\u2014","the client's software would now suddenly break. This is quite obviously something that we want to avoid. Fortunately, the fix is very simple:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-go"}),'package clean\n\nvar (\n    NullItem = Item{}\n\n    ErrItemNotFound = errors.New("item could not be found in the store") \n)\n\nfunc (store *Store) GetItem(id string) (Item, error) {\n    store.mtx.Lock()\n    defer store.mtx.Unlock()\n\n    item, ok := store.items[id]\n    if !ok {\n        return NullItem, ErrItemNotFound\n    }\n    return item, nil\n}\n')),Object(i.b)("p",null,"By simply representing the error as a variable (",Object(i.b)("inlineCode",{parentName:"p"},"ErrItemNotFound"),"), we've ensured that anyone using this package can check against the variable rather than the actual string that it returns:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-go"}),'func GetItemHandler(w http.ReponseWriter, r http.Request) {\n    item, err := clean.GetItem("123")\n    if err != nil {\n        if err == clean.ErrItemNotFound {\n           http.Error(w, err.Error(), http.StatusNotFound)\n            return\n        }\n        http.Error(w, err.Error(), http.StatusInternalServerError)\n        return\n    } \n    json.NewEncoder(w).Encode(item)\n}\n')),Object(i.b)("p",null,"This feels much nicer and is also much safer. Some would even say that it's easier to read as well. In the case of a more verbose error message, it certainly would be preferable for a developer to simply read ",Object(i.b)("inlineCode",{parentName:"p"},"ErrItemNotFound")," rather than a novel on why a certain error has been returned."),Object(i.b)("p",null,"This approach is not limited to errors and can be used for other returned values. As an example, we are also returning a ",Object(i.b)("inlineCode",{parentName:"p"},"NullItem")," instead of ",Object(i.b)("inlineCode",{parentName:"p"},"Item{}")," as we did before. There are many different scenarios in which it might be preferable to return a defined object, rather than initialising it on return."),Object(i.b)("p",null,"Returning default ",Object(i.b)("inlineCode",{parentName:"p"},"NullItem")," values like we did in the previous examples can also be safer in certain cases. As an example, a user of our package could forget to check for errors and end up initialising a variable that points to an empty struct containing a default value of ",Object(i.b)("inlineCode",{parentName:"p"},"nil")," as one or more property values. When attempting to access this ",Object(i.b)("inlineCode",{parentName:"p"},"nil")," value later in the code, the client software would panic. However, when we return our custom default value instead, we can ensure that all values that would otherwise default to ",Object(i.b)("inlineCode",{parentName:"p"},"nil")," are initialised. Thus, we'd ensure that we do not cause panics in our users' software."),Object(i.b)("p",null,"This also benefits us. Consider this: If we wanted to achieve the same safety without returning a default value, we would have to change our code everywhere we return this type of empty value. However, with our default value approach, we now only have to change our code in a single place:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-go"}),"var NullItem = Item{\n    itemMap: map[string]Item{},\n}\n")),Object(i.b)("blockquote",null,Object(i.b)("p",{parentName:"blockquote"},"NOTE: In many scenarios, invoking a panic will actually be preferable to indicate that there is an error check missing.")),Object(i.b)("blockquote",null,Object(i.b)("p",{parentName:"blockquote"},"NOTE: Every interface property in Go has a default value of ",Object(i.b)("inlineCode",{parentName:"p"},"nil"),". This means that this is useful for any struct that has an interface property. This is also true for structs that contain channels, maps, and slices, which could potentially also have a ",Object(i.b)("inlineCode",{parentName:"p"},"nil")," value.")),Object(i.b)("h4",{id:"returning-dynamic-errors"},"Returning Dynamic Errors"),Object(i.b)("p",null,"There are certainly some scenarios where returning an error variable might not actually be viable. In cases where the information in customised errors is dynamic, if we want to describe error events more specifically, we can no longer define and return our static errors. Here's an example:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-go"}),'func (store *Store) GetItem(id string) (Item, error) {\n    store.mtx.Lock()\n    defer store.mtx.Unlock()\n\n    item, ok := store.items[id]\n    if !ok {\n        return NullItem, fmt.Errorf("Could not find item with ID: %s", id)\n    }\n    return item, nil\n}\n')),Object(i.b)("p",null,"So, what to do? There is no well-defined or standard method for handling and returning these kinds of dynamic errors. My personal preference is to return a new interface, with a bit of added functionality:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-go"}),'type ErrorDetails interface {\n    Error() string\n    Type() string\n}\n\ntype errDetails struct {\n    errtype error\n    details interface{}\n}\n\nfunc NewErrorDetails(err error, details ...interface{}) ErrorDetails {\n    return &errDetails{\n        errtype: err,\n        details: details,\n    }\n}\n\nfunc (err *errDetails) Error() string {\n    return fmt.Sprintf("%v: %v", err.errtype, err.details)\n}\n\nfunc (err *errDetails) Type() error {\n    return err.errtype\n}\n')),Object(i.b)("p",null,"This new data structure still works as our standard error. We can still compare it to ",Object(i.b)("inlineCode",{parentName:"p"},"nil")," since it's an interface implementation, and we can still call ",Object(i.b)("inlineCode",{parentName:"p"},".Error()")," on it, so it won't break any existing implementations. However, the advantage is that we can now check our error type as we could previously, despite our error now containing the ",Object(i.b)("em",null,"dynamic")," details:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-go"}),'func (store *Store) GetItem(id string) (Item, error) {\n    store.mtx.Lock()\n    defer store.mtx.Unlock()\n\n    item, ok := store.items[id]\n    if !ok {\n        return NullItem, NewErrorDetails(\n            ErrItemNotFound,\n            fmt.Sprintf("could not find item with id: %s", id))\n    }\n    return item, nil\n}\n')),Object(i.b)("p",null,"And our HTTP handler function can then be refactored to check for a specific error again:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-go"}),'func GetItemHandler(w http.ReponseWriter, r http.Request) {\n    item, err := clean.GetItem("123")\n    if err != nil {\n        if err.Type() == clean.ErrItemNotFound {\n            http.Error(w, err.Error(), http.StatusNotFound)\n            return\n        }\n        http.Error(w, err.Error(), http.StatusInternalServerError)\n        return\n    } \n    json.NewEncoder(w).Encode(item)\n}\n')),Object(i.b)("h3",{id:"nil-values"},"Nil Values"),Object(i.b)("p",null,"A controversial aspect of Go is the addition of ",Object(i.b)("inlineCode",{parentName:"p"},"nil"),". This value corresponds to the value ",Object(i.b)("inlineCode",{parentName:"p"},"NULL")," in C and is essentially an uninitialised pointer. We've already seen some of the problems that ",Object(i.b)("inlineCode",{parentName:"p"},"nil")," can cause, but to sum up: Things break when you try to access methods or properties of a ",Object(i.b)("inlineCode",{parentName:"p"},"nil")," value. Thus, it's recommended to avoid returning a  ",Object(i.b)("inlineCode",{parentName:"p"},"nil")," value when possible. This way, the users of our code are less likely to accidentally access ",Object(i.b)("inlineCode",{parentName:"p"},"nil")," values. "),Object(i.b)("p",null,"There are other scenarios in which it is common to find ",Object(i.b)("inlineCode",{parentName:"p"},"nil")," values that can cause some unnecessary pain. An example of this is incorrectly initialising a ",Object(i.b)("inlineCode",{parentName:"p"},"struct")," (as in the example below), which can lead to it containing ",Object(i.b)("inlineCode",{parentName:"p"},"nil")," properties. If accessed, those ",Object(i.b)("inlineCode",{parentName:"p"},"nil"),"s will cause a panic."),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-go"}),"type App struct {\n    Cache *KVCache\n}\n\ntype KVCache struct {\n  mtx sync.RWMutex\n    store map[string]string\n}\n\nfunc (cache *KVCache) Add(key, value string) {\n  cache.mtx.Lock()\n  defer cache.mtx.Unlock()\n  \n    cache.store[key] = value\n}\n")),Object(i.b)("p",null,"This code is absolutely fine. However, the danger is that our ",Object(i.b)("inlineCode",{parentName:"p"},"App")," can be initialised incorrectly, without initialising the ",Object(i.b)("inlineCode",{parentName:"p"},"Cache")," property within. Should the following code be invoked, our application will panic:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-go"}),'    app := App{}\n    app.Cache.Add("panic", "now")\n')),Object(i.b)("p",null,"The ",Object(i.b)("inlineCode",{parentName:"p"},"Cache")," property has never been initialised and is therefore a ",Object(i.b)("inlineCode",{parentName:"p"},"nil")," pointer. Thus, invoking the ",Object(i.b)("inlineCode",{parentName:"p"},"Add")," method like we did here will cause a panic, with the following message:"),Object(i.b)("blockquote",null,Object(i.b)("p",{parentName:"blockquote"},"panic: runtime error: invalid memory address or nil pointer dereference")),Object(i.b)("p",null,"Instead, we can turn the ",Object(i.b)("inlineCode",{parentName:"p"},"Cache")," property of our ",Object(i.b)("inlineCode",{parentName:"p"},"App")," structure into a private property and create a getter-like method to access it. This gives us more control over what we are returning; specifically, it ensures that we aren't returning a ",Object(i.b)("inlineCode",{parentName:"p"},"nil")," value:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-go"}),"type App struct {\n    cache *KVCache\n}\n\nfunc (app *App) Cache() *KVCache {\n    if app.cache == nil {\n        app.cache = NewKVCache()\n    }\n    return app.cache\n}\n")),Object(i.b)("p",null,"The code that previously panicked will now be refactored to the following:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-go"}),'app := App{}\napp.Cache().Add("panic", "now")\n')),Object(i.b)("p",null,"This ensures that users of our package don't have to worry about the implementation and whether they're using our package in an unsafe manner. All they need to worry about is writing their own clean code."),Object(i.b)("blockquote",null,Object(i.b)("p",{parentName:"blockquote"},"NOTE: There are other methods of achieving a similarly safe outcome. However, I believe this is the most straightforward approach.")),Object(i.b)("h3",{id:"pointers-in-go"},"Pointers in Go"),Object(i.b)("p",null,"Pointers in Go are a rather extensive topic. They're a very big part of working with the language","\u2014","so much so that it is essentially impossible to write Go without some knowledge of pointers and their workings in the language. Therefore, it is important to understand how to use pointers without adding unnecessary complexity (and thereby keeping your codebase clean). Note that we will not review the details of how pointers are implemented in Go. Instead, we will focus on the quirks of Go pointers and how we can handle them."),Object(i.b)("p",null,"Pointers add complexity to code. If we aren't cautious, incorrectly using pointers can introduce nasty side effects or bugs that are particularly difficult to debug. By sticking to the basic principles of writing clean code that we covered in the first part of this document, we can at least reduce the chances of introducing unnecessary complexity to our code."),Object(i.b)("h4",{id:"pointer-mutability"},"Pointer Mutability"),Object(i.b)("p",null,"We've already looked at the problem of mutability in the context of globally or largely scoped variables. However, mutability is not necessarily always a bad thing, and I am by no means an advocate for writing 100% pure functional programs. Mutability is a powerful tool, but we should really only ever use it when it's necessary. Let's have a look at a code example illustrating why:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-go"}),"func (store *UserStore) Insert(user *User) error {\n    if store.userExists(user.ID) {\n        return ErrItemAlreaydExists\n    }\n    store.users[user.ID] = user\n    return nil\n}\n\nfunc (store *UserStore) userExists(id int64) bool {\n    _, ok := store.users[id]\n    return ok\n}\n")),Object(i.b)("p",null,"At first glance, this doesn't seem too bad. In fact, it might even seem like a rather simple insert function for a common list structure. We accept a pointer as input, and if no other users with this ",Object(i.b)("inlineCode",{parentName:"p"},"id")," exist, then we insert the provided user pointer into our list. Then, we use this functionality in our public API for creating new users:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-go"}),'func CreateUser(w http.ResponseWriter, r *http.Request) {\n    user, err := parseUserFromRequest(r)\n    if err != nil {\n        http.Error(w, err, http.StatusBadRequest)\n        return\n    }\n    if err := insertUser(w, user); err != nil {\n      http.Error(w, err, http.StatusInternalServerError)\n      return\n    }\n}\n\nfunc insertUser(w http.ResponseWriter, user User) error {\n    if err := store.Insert(user); err != nil {\n        return err\n    }\n    user.Password = ""\n      return json.NewEncoder(w).Encode(user)\n}\n')),Object(i.b)("p",null,"Once again, at first glance, everything looks fine. We parse the user from the received request and insert the user struct into our store. Once we have successfully inserted our user into the store, we then set the password to be an empty string before returning the user as a JSON object to our client. This is all quite common practice, typically when returning a user object whose password has been hashed, since we don't want to return the hashed password."),Object(i.b)("p",null,"However, imagine that we are using an in-memory store based on a ",Object(i.b)("inlineCode",{parentName:"p"},"map"),". This code will produce some unexpected results. If we check our user store, we'll see that the change we made to the users password in the HTTP handler function also affected the object in our store. This is because the pointer address returned by ",Object(i.b)("inlineCode",{parentName:"p"},"parseUserFromRequest")," is what we populated our store with, rather than an actual value. Therefore, when making changes to the dereferenced password value, we end up changing the value of the object we are pointing to in our store."),Object(i.b)("p",null,"This is a great example of why both mutability and variable scope can cause some serious issues and bugs when used incorrectly. When passing pointers as an input parameter of a function, we are expanding the scope of the variable whose data is being pointed to. Even more worrying is the fact that we are expanding the scope to an undefined level. We are ",Object(i.b)("em",{parentName:"p"},"almost")," expanding the scope of the variable to the global level. As demonstrated by the above example, this can lead to disastrous bugs that are particularly difficult to find and eradicate."),Object(i.b)("p",null,"Fortunately, the fix for this is rather simple:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-go"}),"func (store *UserStore) Insert(user User) error {\n    if store.userExists(user.ID) {\n        return ErrItemAlreaydExists\n    }\n    store.users[user.ID] = &user\n    return nil\n}\n")),Object(i.b)("p",null,"Instead of passing a pointer to a ",Object(i.b)("inlineCode",{parentName:"p"},"User")," struct, we are now passing in a copy of a ",Object(i.b)("inlineCode",{parentName:"p"},"User"),". We are still storing a pointer to our store; however, instead of storing the pointer from outside of the function, we are storing the pointer to the copied value, whose scope is inside the function. This fixes the immediate problem but might still cause issues further down the line if we aren't careful. Consider this code:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-go"}),"func (store *UserStore) Get(id int64) (*User, error) {\n    user, ok := store.users[id]\n    if !ok {\n        return EmptyUser, ErrUserNotFound\n    }\n    return store.users[id], nil\n}\n")),Object(i.b)("p",null,"Again, this is a very standard implementation of a getter function for our store. However, it's still bad code because we are once again expanding the scope of our pointer, which may end up causing unexpected side effects. When returning the actual pointer value, which we are storing in our user store, we are essentially giving other parts of our application the ability to change our store values. This is bound to cause confusion. Our store should be the only entity allowed to make changes to its values. The easiest fix for this is to return a value of ",Object(i.b)("inlineCode",{parentName:"p"},"User")," rather than returning a pointer."),Object(i.b)("blockquote",null,Object(i.b)("p",{parentName:"blockquote"},"NOTE: Consider the case where our application uses multiple threads. In this scenario, passing pointers to the same memory location can also potentially result in a race condition. In other words, we aren't only potentially corrupting our data","\u2014","we could also cause a panic from a data race.")),Object(i.b)("p",null,"Please keep in mind that there is intrinsically nothing wrong with returning pointers. However, the expanded scope of variables (and the number of owners pointing to those variables) is the most important consideration when working with pointers. This is what categorises our previous example as a smelly operation. This is also why common Go constructors are absolutely fine:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-go"}),"func AddName(user *User, name string) {\n    user.Name = name\n}\n")),Object(i.b)("p",null,"This is ",Object(i.b)("em",{parentName:"p"},"okay")," because the variable scope, which is defined by whoever invokes the function, remains the same after the function returns. Combined with the fact that the function invoker remains the sole owner of the variable, this means that the pointer cannot be manipulated in an unexpected manner."),Object(i.b)("h3",{id:"closures-are-function-pointers"},"Closures Are Function Pointers"),Object(i.b)("p",null,'Before we get into the next topic of using interfaces in Go, I would like to introduce a common alternative. It\'s what C programmers know as "function pointers" and what most other programming languages call ',Object(i.b)("strong",null,"closures"),". A closure is simply an input parameter like any other, except it represents (points to) a function that can be invoked. In JavaScript, it's quite common to use closures as callbacks, which are just functions that are invoked after some asynchronous operation has finished. In Go, we don't really have this notion. We can, however, use closures to partially overcome a different hurdle: The lack of generics."),Object(i.b)("p",null,"Consider the following function signature:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-go"}),"func something(closure func(float64) float64) float64 { ... }\n")),Object(i.b)("p",null,"Here, ",Object(i.b)("inlineCode",{parentName:"p"},"something")," takes another function (a closure) as input and returns a ",Object(i.b)("inlineCode",{parentName:"p"},"float64"),". The input function takes a ",Object(i.b)("inlineCode",{parentName:"p"},"float64")," as input and also returns a ",Object(i.b)("inlineCode",{parentName:"p"},"float64"),". This pattern can be particularly useful for creating a loosely coupled architecture, making it easier to to add functionality without affecting other parts of the code. Suppose we have a struct containing data that we want to manipulate in some form. Through this structure's ",Object(i.b)("inlineCode",{parentName:"p"},"Do()")," method, we can perform operations on that data. If we know the operation ahead of time, we can obviously handle that logic directly in our ",Object(i.b)("inlineCode",{parentName:"p"},"Do()")," method:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-go"}),"func (datastore *Datastore) Do(operation Operation, data []byte) error {\n  switch(operation) {\n  case COMPARE:\n    return datastore.compare(data)\n  case CONCAT:\n    return datastore.add(data)\n  default:\n    return ErrUnknownOperation\n  }\n}\n")),Object(i.b)("p",null,"But as you can imagine, this function is quite rigid","\u2014","it performs a predetermined operation on the data contained in the ",Object(i.b)("inlineCode",{parentName:"p"},"Datastore")," struct. If at some point we would like to introduce more operations, we'd end up bloating our ",Object(i.b)("inlineCode",{parentName:"p"},"Do")," method with quite a lot of irrelevant logic that would be hard to maintain. The function would have to always care about what operation it's performing and to cycle through a number of nested options for each operation. It might also be an issue for developers wanting to use our ",Object(i.b)("inlineCode",{parentName:"p"},"Datastore")," object who don't have access to edit our package code, since there is no way of extending structure methods in Go as there is in most OOP languages."),Object(i.b)("p",null,"So instead, let's try a different approach using closures:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-go"}),"func (datastore *Datastore) Do(operation func(data []byte, data []byte) ([]byte, error), data []byte) error {\n  result, err := operation(datastore.data, data)\n  if err != nil {\n    return err\n  }\n  datastore.data = result\n  return nil\n}\n\nfunc concat(a []byte, b []byte) ([]byte, error) {\n  ...\n}\n\nfunc main() {\n  ...\n  datastore.Do(concat, data)\n  ...\n}\n")),Object(i.b)("p",null,"You'll notice immediately that the function signature for ",Object(i.b)("inlineCode",{parentName:"p"},"Do")," ends up being quite messy. We also have another issue: The closure isn't particularly generic. What happens if we find out that we actually want the ",Object(i.b)("inlineCode",{parentName:"p"},"concat")," to be able to take more than just two byte arrays as input? Or if we want to add some completely new functionality that may also need more or fewer input values than ",Object(i.b)("inlineCode",{parentName:"p"},"(data []byte, data []byte)"),"?"),Object(i.b)("p",null,"One way to solve this issue is to change our ",Object(i.b)("inlineCode",{parentName:"p"},"concat")," function. In the example below, I have changed it to only take a single byte array as an input argument, but it could just as well have been the opposite case:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-go"}),"func concat(data []byte) func(data []byte) ([]byte, error) {\n  return func(concatting []byte) ([]byte, error) {\n    return append(data, concatting), nil\n  }\n}\n\nfunc (datastore *Datastore) Do(operation func(data []byte) ([]byte, error)) error {\n  result, err := operation(datastore.data)\n  if err != nil {\n    return err\n  }\n  datastore.data = result\n  return nil\n}\n\nfunc main() {\n  ...\n  datastore.Do(compare(data))\n  ...\n}\n")),Object(i.b)("p",null,"Notice how we've effectively moved some of the clutter out of the ",Object(i.b)("inlineCode",{parentName:"p"},"Do")," method signature and into the ",Object(i.b)("inlineCode",{parentName:"p"},"concat")," method signature. Here, the ",Object(i.b)("inlineCode",{parentName:"p"},"concat")," function returns yet another function. Within the returned function, we store the input values originally passed in to our ",Object(i.b)("inlineCode",{parentName:"p"},"concat")," function. The returned function can therefore now take a single input parameter; within our function logic, we will append it to our original input value. As a newly introduced concept, this may seem quite strange. However, it's good to get used to having this as an option; it can help loosen up logic coupling and get rid of bloated functions."),Object(i.b)("p",null,"In the next section, we'll get into interfaces. Before we do so, let's take a short moment to discuss the difference between interfaces and closures. First, it's worth noting that interfaces and closures definitely solve some common problems. However, the way that interfaces are implemented in Go can sometimes make it tricky to decide whether to use interfaces or closures for a particular problem. Usually, whether an interface or a closure is used isn't really of importance; the right choice is whichever one solves the problem at hand. Typically, closures will be simpler to implement if the operation is simple by nature. However, as soon as the logic contained within a closure becomes complex, one should strongly consider using an interface instead.  "),Object(i.b)("p",null,"Dave Cheney has an excellent write-up on this topic, as well as a talk:"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("a",Object(a.a)({parentName:"li"},{href:"https://dave.cheney.net/2016/11/13/do-not-fear-first-class-functions"}),"https://dave.cheney.net/2016/11/13/do-not-fear-first-class-functions")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("a",Object(a.a)({parentName:"li"},{href:"https://www.youtube.com/watch?v=5buaPyJ0XeQ&t=9s"}),"https://www.youtube.com/watch?v=5buaPyJ0XeQ&t=9s"))),Object(i.b)("p",null,"Jon Bodner also has a related talk:"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("a",Object(a.a)({parentName:"li"},{href:"https://www.youtube.com/watch?v=5IKcPMJXkKs"}),"https://www.youtube.com/watch?v=5IKcPMJXkKs"))),Object(i.b)("h3",{id:"interfaces-in-go"},"Interfaces in Go"),Object(i.b)("p",null,"In general, Go's approach to handling ",Object(i.b)("inlineCode",{parentName:"p"},"interface"),"s is quite different from those of other languages. Interfaces aren't explicitly implemented like they would be in Java or C#; rather, they are implicitly created if they fulfill the contract of the interface. As an example, this means that any ",Object(i.b)("inlineCode",{parentName:"p"},"struct")," that has an ",Object(i.b)("inlineCode",{parentName:"p"},"Error()"),' method implements (or "fulfills") the ',Object(i.b)("inlineCode",{parentName:"p"},"Error")," interface and can be returned as an ",Object(i.b)("inlineCode",{parentName:"p"},"error"),". This manner of implementing interfaces is extremely easy and makes Go feel more fast paced and dynamic."),Object(i.b)("p",null,"However, there are certainly disadvantages with this approach. As the interface implementation is no longer explicit, it can be difficult to see which interfaces are implemented by a struct. Therefore, it's common to define interfaces with as few methods as possible; this makes it easier to understand whether a particular struct fulfills the contract of the interface."),Object(i.b)("p",null,"An alternative is to create constructors that return an interface rather than the concrete type:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-go"}),"type Writer interface {\n    Write(p []byte) (n int, err error)\n}\n\ntype NullWriter struct {}\n\nfunc (writer *NullWriter) Write(data []byte) (n int, err error) {\n    // do nothing\n    return len(data), nil\n}\n\nfunc NewNullWriter() io.Writer {\n    return &NullWriter{}\n}\n")),Object(i.b)("p",null,"The above function ensures that the ",Object(i.b)("inlineCode",{parentName:"p"},"NullWriter")," struct implements the ",Object(i.b)("inlineCode",{parentName:"p"},"Writer")," interface. If we were to delete the ",Object(i.b)("inlineCode",{parentName:"p"},"Write")," method from ",Object(i.b)("inlineCode",{parentName:"p"},"NullWriter"),", we would get a compilation error. This is a good way of ensuring that our code behaves as expected and that we can rely on the compiler as a safety net in case we try to write invalid code."),Object(i.b)("p",null,"In certain cases, it might not be desirable to write a constructor, or perhaps we would like for our constructor to return the concrete type, rather than the interface. As an example, the ",Object(i.b)("inlineCode",{parentName:"p"},"NullWriter")," struct has no properties to populate on initialisation, so writing a constructor is a little redundant. Therefore, we can use the less verbose method of checking interface compatibility:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-go"}),"type Writer interface {\n    Write(p []byte) (n int, err error)\n}\n\ntype NullWriter struct {}\nvar _ io.Writer = &NullWriter{}\n")),Object(i.b)("p",null,"In the above code, we are initialising a variable with the Go ",Object(i.b)("inlineCode",{parentName:"p"},"blank identifier"),", with the type assignment of ",Object(i.b)("inlineCode",{parentName:"p"},"io.Writer"),". This results in our variable being checked to fulfill the ",Object(i.b)("inlineCode",{parentName:"p"},"io.Writer")," interface contract, before being discarded. This method of checking interface fulfillment also makes it possible to check that several interface contracts are fulfilled:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-go"}),"type NullReaderWriter struct{}\nvar _ io.Writer = &NullWriter{}\nvar _ io.Reader = &NullWriter{}\n")),Object(i.b)("p",null,"From the above code, it's very easy to understand which interfaces must be fulfilled; this ensures that the compiler will help us out during compile time. Therefore, this is generally the preferred solution for checking interface contract fulfillment."),Object(i.b)("p",null,"There's yet another method of trying to be more explicit about which interfaces a given struct implements. However, this third method actually achieves the opposite of what we want. It involves using embedded interfaces as a struct property."),Object(i.b)("blockquote",null,Object(i.b)("em",null,"Wait what? \u2013 Presumably most people")),Object(i.b)("p",null,"Let's rewind a bit before we dive deep into the forbidden forest of smelly Go. In Go, we can use embedded structs as a type of inheritance in our struct definitions. This is really nice, as we can decouple our code by defining reusable structs."),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-go"}),"type Metadata struct {\n    CreatedBy types.User\n}\n\ntype Document struct {\n    *Metadata\n    Title string\n    Body string\n}\n\ntype AudioFile struct {\n    *Metadata\n    Title string\n    Body string\n}\n")),Object(i.b)("p",null,"Above, we are defining a ",Object(i.b)("inlineCode",{parentName:"p"},"Metadata")," object that will provide us with property fields that we are likely to use on many different struct types. The neat thing about using the embedded struct, rather than explicitly defining the properties directly in our struct, is that it has decoupled the ",Object(i.b)("inlineCode",{parentName:"p"},"Metadata")," fields. Should we choose to update our ",Object(i.b)("inlineCode",{parentName:"p"},"Metadata")," object, we can change it in just a single place. As we've seen several times so far, we want to ensure that a change in one place in our code doesn't break other parts. Keeping these properties centralised makes it clear that structures with an embedded ",Object(i.b)("inlineCode",{parentName:"p"},"Metadata")," have the same properties","\u2014","much like how structures that fulfill interfaces have the same methods."),Object(i.b)("p",null,"Now, let's look at an example of how we can use a constructor to further prevent breaking our code when making changes to our ",Object(i.b)("inlineCode",{parentName:"p"},"Metadata")," struct:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-go"}),"func NewMetadata(user types.User) Metadata {\n    return &Metadata{\n        CreatedBy: user,\n    }\n}\n\nfunc NewDocument(title string, body string) Document {\n    return Document{\n        Metadata: NewMetadata(),\n        Title: title,\n        Body: body,\n    }\n}\n")),Object(i.b)("p",null,"Suppose that at a later point in time, we decide that we'd also like a ",Object(i.b)("inlineCode",{parentName:"p"},"CreatedAt")," field on our ",Object(i.b)("inlineCode",{parentName:"p"},"Metadata")," object. We can now easily achieve this by simply updating our ",Object(i.b)("inlineCode",{parentName:"p"},"NewMetadata")," constructor:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-go"}),"func NewMetadata(user types.User) Metadata {\n    return &Metadata{\n        CreatedBy: user,\n        CreatedAt: time.Now(),\n    }\n}\n")),Object(i.b)("p",null,"Now, both our ",Object(i.b)("inlineCode",{parentName:"p"},"Document")," and ",Object(i.b)("inlineCode",{parentName:"p"},"AudioFile")," structures are updated to also populate these fields on construction. This is the core principle behind decoupling and an excellent example of ensuring maintainability of code. We can also add new methods without breaking our existing code:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-go"}),"type Metadata struct {\n    CreatedBy types.User\n    CreatedAt time.Time\n    UpdatedBy types.User\n    UpdatedAt time.Time\n}\n\nfunc (metadata *Metadata) AddUpdateInfo(user types.User) {\n    metadata.UpdatedBy = user\n    metadata.UpdatedAt = time.Now()\n}\n")),Object(i.b)("p",null,"Again, without breaking the rest of our codebase, we've managed to introduce new functionality. This kind of programming makes implementing new features very quick and painless, which is exactly what we are trying to achieve by writing clean code."),Object(i.b)("p",null,"Let's return to the topic of interface contract fulfillment using embedded interfaces. Consider the following code as an example:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-go"}),"type NullWriter struct {\n    Writer\n}\n\nfunc NewNullWriter() io.Writer {\n    return &NullWriter{}\n}\n")),Object(i.b)("p",null,"The above code compiles. Technically, we are implementing the interface of ",Object(i.b)("inlineCode",{parentName:"p"},"Writer")," in our ",Object(i.b)("inlineCode",{parentName:"p"},"NullWriter"),", as ",Object(i.b)("inlineCode",{parentName:"p"},"NullWriter")," will inherit all the functions that are associated with this interface. Some see this as a clear way of showing that our ",Object(i.b)("inlineCode",{parentName:"p"},"NullWriter")," is implementing the ",Object(i.b)("inlineCode",{parentName:"p"},"Writer")," interface. However, we must be careful when using this technique."),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-go"}),"func main() {\n    w := NewNullWriter()\n\n    w.Write([]byte{1, 2, 3})\n}\n")),Object(i.b)("p",null,"As mentioned before, the above code will compile. The ",Object(i.b)("inlineCode",{parentName:"p"},"NewNullWriter")," returns a ",Object(i.b)("inlineCode",{parentName:"p"},"Writer"),", and everything is hunky-dory according to the compiler because ",Object(i.b)("inlineCode",{parentName:"p"},"NullWriter")," fulfills the contract of ",Object(i.b)("inlineCode",{parentName:"p"},"io.Writer"),", via the embedded interface. However, running the code above will result in the following:"),Object(i.b)("blockquote",null,Object(i.b)("p",{parentName:"blockquote"},"panic: runtime error: invalid memory address or nil pointer dereference")),Object(i.b)("p",null,"What happened? An interface method in Go is essentially a function pointer. In this case, since we are pointing to the function of an interface, rather than an actual method implementation, we are trying to invoke a function that's actually a ",Object(i.b)("inlineCode",{parentName:"p"},"nil")," pointer. To prevent this from happening, we would have to provide the ",Object(i.b)("inlineCode",{parentName:"p"},"NulllWriter")," with a struct that fulfills the interface contract, with actual implemented methods."),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-go"}),"func main() {\n  w := NullWriter{\n    Writer: &bytes.Buffer{},\n  }\n\n    w.Write([]byte{1, 2, 3})\n}\n")),Object(i.b)("blockquote",null,Object(i.b)("p",{parentName:"blockquote"},"NOTE: In the above example, ",Object(i.b)("inlineCode",{parentName:"p"},"Writer")," is referring to the embedded ",Object(i.b)("inlineCode",{parentName:"p"},"io.Writer")," interface. It is also possible to invoke the ",Object(i.b)("inlineCode",{parentName:"p"},"Write")," method by accessing this property with ",Object(i.b)("inlineCode",{parentName:"p"},"w.Writer.Write()"),".")),Object(i.b)("p",null,"We are no longer triggering a panic and can now use the ",Object(i.b)("inlineCode",{parentName:"p"},"NullWriter")," as a ",Object(i.b)("inlineCode",{parentName:"p"},"Writer"),". This initialisation process is not much different from having properties that are initialised as ",Object(i.b)("inlineCode",{parentName:"p"},"nil"),", as discussed previously. Therefore, logically, we should try to handle them in a similar way. However, this is where embedded interfaces become a little difficult to work with. In a previous section, it was explained that the best way to handle potential ",Object(i.b)("inlineCode",{parentName:"p"},"nil")," values is to make the property in question private and create a public ",Object(i.b)("em",{parentName:"p"},"getter")," method. This way, we could ensure that our property is, in fact, not ",Object(i.b)("inlineCode",{parentName:"p"},"nil"),". Unfortunately, this is simply not possible with embedded interfaces, as they are by nature always public."),Object(i.b)("p",null,"Another concern raised by using embedded interfaces is the potential confusion caused by partially overwritten interface methods: "),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-go"}),"type MyReadCloser struct {\n  io.ReadCloser\n}\n\nfunc (closer *ReadCloser) Read(data []byte) { ... }\n\nfunc main() {\n  closer := MyReadCloser{}\n  \n  closer.Read([]byte{1, 2, 3})  // works fine\n  closer.Close()        // causes panic\n  closer.ReadCloser.Closer()        // no panic \n}\n")),Object(i.b)("p",null,"Even though this might look like we're overriding methods, which is common in languages such as C# and Java, we actually aren't. Go doesn't support inheritance (and thus has no notion of a superclass). We can imitate the behaviour, but it is not a built-in part of the language. By using methods such as interface embedding without caution, we can create confusing and potentially buggy code, just to save a few more lines."),Object(i.b)("blockquote",null,Object(i.b)("p",{parentName:"blockquote"},"NOTE: Some argue that using embedded interfaces is a good way of creating a mock structure for testing a subset of interface methods. Essentially, by using an embedded interface, you won't have to implement all of the methods of the interface; rather, you can choose to implement only the few methods that you'd like to test. Within the context of testing/mocking, I can see this argument, but I am still not a fan of this approach.")),Object(i.b)("p",null,"Let's quickly get back to clean code and proper usage of interfaces. It's time to discuss using interfaces as function parameters and return values. The most common proverb for interface usage with functions in Go is the following:"),Object(i.b)("blockquote",null,Object(i.b)("em",null,"Be conservative in what you do; be liberal in what you accept from others \u2013 Jon Postel")),Object(i.b)("blockquote",null,Object(i.b)("p",{parentName:"blockquote"},"FUN FACT: This proverb actually has nothing to do with Go. It's taken from an early specification of the TCP networking protocol.")),Object(i.b)("p",null,"In other words, you should write functions that accept an interface and return a concrete type. This is generally good practice and is especially useful when doing tests with mocking. As an example, we can create a function that takes a writer interface as its input and invokes the ",Object(i.b)("inlineCode",{parentName:"p"},"Write")," method of that interface:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-go"}),"type Pipe struct {\n    writer io.Writer\n    buffer bytes.Buffer\n}\n\nfunc NewPipe(w io.Writer) *Pipe {\n    return &Pipe{\n        writer: w,\n    }\n} \n\nfunc (pipe *Pipe) Save() error {\n    if _, err := pipe.writer.Write(pipe.FlushBuffer()); err != nil {\n        return err\n    }\n    return nil\n}\n")),Object(i.b)("p",null,"Let's assume that we are writing to a file when our application is running, but we don't want to write to a new file for all tests that invoke this function. We can implement a new mock type that will basically do nothing. Essentially, this is just basic dependency injection and mocking, but the point is that it is extremely easy to achieve in Go:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-go"}),"type NullWriter struct {}\n\nfunc (w *NullWriter) Write(data []byte) (int, error) {\n    return len(data), nil\n}\n\nfunc TestFn(t *testing.T) {\n    ...\n    pipe := NewPipe(NullWriter{})\n    ...\n}\n")),Object(i.b)("blockquote",null,Object(i.b)("p",{parentName:"blockquote"},"NOTE: There is actually already a null writer implementation built into the ",Object(i.b)("inlineCode",{parentName:"p"},"ioutil")," package named ",Object(i.b)("inlineCode",{parentName:"p"},"Discard"),".")),Object(i.b)("p",null,"When constructing our ",Object(i.b)("inlineCode",{parentName:"p"},"Pipe")," struct with ",Object(i.b)("inlineCode",{parentName:"p"},"NullWriter")," (rather than a different writer), when invoking our ",Object(i.b)("inlineCode",{parentName:"p"},"Save")," function, nothing will happen. The only thing we had to do was add four lines of code. This is why it is encouraged to make interfaces as small as possible in idiomatic Go","\u2014","it makes it especially easy to implement patterns like the one we just saw. However, this implementation of interfaces also comes with a ",Object(i.b)("em",null,"huge")," downside."),Object(i.b)("h3",{id:"the-empty-interface"},"The Empty ",Object(i.b)("inlineCode",{parentName:"h3"},"interface{}")),Object(i.b)("p",null,"Unlike other languages, Go does not have an implementation for generics. There have been many proposals for one, but all have been turned down by the Go language team. Unfortunately, without generics, developers must try to find creative alternatives, which very often involves using the empty ",Object(i.b)("inlineCode",{parentName:"p"},"interface{}"),". This section describes why these often ",Object(i.b)("em",null,"too")," creative implementations should be considered bad practice and unclean code. There will also be examples of appropriate usage of the empty ",Object(i.b)("inlineCode",{parentName:"p"},"interface{}")," and how to avoid some pitfalls of writing code with it."),Object(i.b)("p",null,"As mentioned in a previous section, Go determines whether a concrete type implements a particular interface by checking whether the type implements the ",Object(i.b)("em",null,"methods")," of that interface. So what happens if our interface declares no methods, as is the case with the empty interface?"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-go"}),"type EmptyInterface interface {}\n")),Object(i.b)("p",null,"The above is equivalent to the built-in type ",Object(i.b)("inlineCode",{parentName:"p"},"interface{}"),". A natural consequence of this is that we can write generic functions that accept any type as arguments. This is extremely useful for certain kinds of functions, such as print helpers. Interestingly, this is actually what makes it possible to pass in any type to the ",Object(i.b)("inlineCode",{parentName:"p"},"Println")," function from the ",Object(i.b)("inlineCode",{parentName:"p"},"fmt")," package:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-go"}),"func Println(v ...interface{}) {\n    ...\n}\n")),Object(i.b)("p",null,"In this case, ",Object(i.b)("inlineCode",{parentName:"p"},"Println")," isn't just accepting a single ",Object(i.b)("inlineCode",{parentName:"p"},"interface{}"),"; rather, the function accepts a ",Object(i.b)("em",null,"slice")," of types that implement the empty ",Object(i.b)("inlineCode",{parentName:"p"},"interface{}"),". As there are no methods associated with the empty ",Object(i.b)("inlineCode",{parentName:"p"},"interface{}"),", ",Object(i.b)("em",null,"all")," types are accepted, even making it possible to feed ",Object(i.b)("inlineCode",{parentName:"p"},"Println")," with a slice of different types. This is a very common pattern when handling string conversion (both from and to a string). Good examples of this come from the ",Object(i.b)("inlineCode",{parentName:"p"},"json")," standard library package:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-go"}),"func InsertItemHandler(w http.ResponseWriter, r *http.Request) {\n    var item Item\n    if err := json.NewDecoder(r.Body).Decode(&item); err != nil {\n        http.Error(w, err.Error(), http.StatusBadRequest)\n        return\n    }\n\n    if err := db.InsertItem(item); err != nil {\n        http.Error(w, err.Error(), http.StatusInternalServerError)\n        return\n    }\n    w.WriteHeader(http.StatsOK)\n}\n")),Object(i.b)("p",null,"All the less elegant code is contained within the ",Object(i.b)("inlineCode",{parentName:"p"},"Decode")," function. Thus, developers using this functionality won't have to worry about type reflection or type casting; we just have to worry about providing a pointer to a concrete type. This is good because the ",Object(i.b)("inlineCode",{parentName:"p"},"Decode()")," function is technically returning a concrete type. We are passing in our ",Object(i.b)("inlineCode",{parentName:"p"},"Item")," value, which will be populated from the body of the HTTP request. This means we won't have to deal with the potential risks of handling the ",Object(i.b)("inlineCode",{parentName:"p"},"interface{}")," value ourselves."),Object(i.b)("p",null,"However, even when using the empty ",Object(i.b)("inlineCode",{parentName:"p"},"interface{}")," with good programming practices, we still have some issues. If we pass in a JSON string that has nothing to do with our ",Object(i.b)("inlineCode",{parentName:"p"},"Item")," type but is still valid JSON, we won't receive an error","\u2014","our ",Object(i.b)("inlineCode",{parentName:"p"},"item")," variable will just be left with the default values. So, while we don't have to worry about reflection and casting errors, we will still have to make sure that the message sent from our client is a valid ",Object(i.b)("inlineCode",{parentName:"p"},"Item")," type. Unfortunately, as of writing this document, there is no simple or good way to implement these types of generic decoders without using the empty ",Object(i.b)("inlineCode",{parentName:"p"},"interface{}")," type."),Object(i.b)("p",null,"The problem with using ",Object(i.b)("inlineCode",{parentName:"p"},"interface{}")," in this manner is that we are leaning towards using Go, a statically typed language, as a dynamically typed language. This becomes even clearer when looking at poor implementations of the ",Object(i.b)("inlineCode",{parentName:"p"},"interface{}")," type. The most common example of this comes from developers trying to implement a generic store or list of some sort."),Object(i.b)("p",null,"Let's look at an example of trying to implement a generic HashMap package that can store any type using ",Object(i.b)("inlineCode",{parentName:"p"},"interface{}"),". "),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-go"}),"type HashMap struct {\n    store map[string]interface{}\n}\n\nfunc (hashmap *HashMap) Insert(key string, value interface{}) {\n    hashmap.store[key] = value\n}\n\nfunc (hashmap *HashMap) Get(key string) (interface{}, error) {\n    value, ok := hashmap.store[key]\n    if !ok {\n        return nil, ErrKeyNotFoundInHashMap\n    }\n    return value\n}\n")),Object(i.b)("blockquote",null,Object(i.b)("p",{parentName:"blockquote"},"NOTE: I have omitted thread safety from this example to keep it simple.")),Object(i.b)("p",null,"Please keep in mind that the implementation pattern shown above is actually used in quite a lot of Go packages. It is even used in the standard library ",Object(i.b)("inlineCode",{parentName:"p"},"sync")," package for the ",Object(i.b)("inlineCode",{parentName:"p"},"sync.Map")," type. So what's the problem with this implementation? Well, let's have a look at an example of using the package:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-go"}),"func SomeFunction(id string) (Item, error) {\n    itemIface, err := hashmap.Get(id)\n    if err != nil {\n        return EmptyItem, err\n    }\n    item, ok := itemIface.(Item)\n    if !ok {\n        return EmptyItem, ErrCastingItem\n    }\n    return item, nil\n}\n")),Object(i.b)("p",null,"At first glance, this looks fine. However, we'll start getting into trouble if we add ",Object(i.b)("em",null,"different")," types to our store, something that's currently allowed. There is nothing preventing us from adding something other than the ",Object(i.b)("inlineCode",{parentName:"p"},"Item")," type. So what happens when someone starts adding other types into our HashMap, like a pointer ",Object(i.b)("inlineCode",{parentName:"p"},"*Item")," instead of an ",Object(i.b)("inlineCode",{parentName:"p"},"Item"),"? Our function now might return an error. Worst of all, this might not even be caught by our tests. Depending on the complexity of the system, this could introduce some bugs that are particularly difficult to debug."),Object(i.b)("p",null,"This type of code should never reach production. Remember: Go does not (yet) support generics. That's just a fact that developers must accept for the time being. If we want to use generics, then we should use a different language that does support generics rather than relying on dangerous hacks."),Object(i.b)("p",null,"So, how do we prevent this code from reaching production? The simplest solution is to just write the functions with concrete types instead of using ",Object(i.b)("inlineCode",{parentName:"p"},"interface{}")," values. Of course, this is not always the best approach, as there might be some functionality within the package that is not trivial to implement ourselves. Therefore, a better approach may be to create wrappers that expose the functionality we need but still ensure type safety:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-go"}),"type ItemCache struct {\n  kv tinykv.KV\n} \n\nfunc (cache *ItemCache) Get(id string) (Item, error) {\n  value, ok := cache.kv.Get(id)\n  if !ok {\n    return EmptyItem, ErrItemNotFound\n  }\n  return interfaceToItem(value)\n}\n\nfunc interfaceToItem(v interface{}) (Item, error) {\n  item, ok := v.(Item)\n  if !ok {\n    return EmptyItem, ErrCouldNotCastItem\n  }\n  return item, nil\n}\n\nfunc (cache *ItemCache) Put(id string, item Item) error {\n  return cache.kv.Put(id, item)\n}\n")),Object(i.b)("blockquote",null,Object(i.b)("p",{parentName:"blockquote"},"NOTE: Implementations of other functionalities of the ",Object(i.b)("inlineCode",{parentName:"p"},"tinykv.KV")," cache have been omitted for the sake of brevity.")),Object(i.b)("p",null,"The wrapper above now ensures that we are using the actual types and that we are no longer passing in ",Object(i.b)("inlineCode",{parentName:"p"},"interface{}")," types. It is therefore no longer possible to accidentally populate our store with a wrong value type, and we have restricted our casting of types as much as possible. This is a very straightforward way of solving our issue, even if somewhat manually."),Object(i.b)("h2",{id:"summary"},"Summary"),Object(i.b)("p",null,"First of all, thank you for making it all the way through this article! I hope it has provided some insight into clean code and how it helps ensure maintainability, readability, and stability in any codebase."),Object(i.b)("p",null,"Let's briefly sum up all the topics we've covered:"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("strong",null,"Functions"),"\u2014A function's name should reflect its scope; the smaller the scope of a function, the more specific its name. Ensure that all functions serve a single purpose in as few lines as possible. A good rule of thumb is to limit your functions to 5\u20138 lines and to only accept 2\u20133 arguments."),Object(i.b)("li",{parentName:"ul"},Object(i.b)("strong",null,"Variables"),"\u2014Unlike functions, variables should assume more generic names as their scope becomes smaller. It's also recommended that you limit the scope of a variable as much as possible to prevent unintentional modification. On a similar note, you should keep the modification of variables to a minimum; this becomes an especially important consideration as the scope of a variable grows."),Object(i.b)("li",{parentName:"ul"},Object(i.b)("strong",null,"Return Values"),"\u2014Concrete types should be returned whenever possible. Make it as difficult as possible for users of your package to make mistakes and as easy as possible for them to understand the values returned by your functions."),Object(i.b)("li",{parentName:"ul"},Object(i.b)("strong",null,"Pointers"),"\u2014Use pointers with caution, and limit their scope and mutability to an absolute minimum. Remember: Garbage collection only assists with memory management; it does not assist with all of the other complexities associated with pointers."),Object(i.b)("li",{parentName:"ul"},Object(i.b)("strong",null,"Interfaces"),"\u2014Use interfaces as much as possible to loosen the coupling of your code. Hide any code using the empty `interface","` as much as possible from end users to prevent it from being exposed.")),Object(i.b)("p",null,"As a final note, it's worth mentioning that the notion of clean code is particularly subjective, and that likely won't ever change. However, much like my statement concerning ",Object(i.b)("inlineCode",{parentName:"p"},"gofmt"),", I think it's more important to find a common standard than something that everyone agrees with; the latter is extremely difficult to achieve."),Object(i.b)("p",null,"It's also important to understand that fanaticism is never the goal with clean code. A codebase will most likely never be fully 'clean,' in the same way that your office desk probably isn't either. There's certainly room for you to step outside the rules and boundaries covered in this article. However, remember that the most important reason for writing clean code is to help yourself and other developers. We support engineers by ensuring stability in the software we produce and by making it easier to debug faulty code. We help our fellow developers by ensuring that our code is readable and easily digestible. We help ",Object(i.b)("em",null,"everyone")," involved in the project by establishing a flexible codebase that allows us to quickly introduce new features without breaking our current platform. We move quickly by going slowly, and everyone is satisfied."),Object(i.b)("p",null,"I hope you will join this discussion to help the Go community define (and refine) the concept of clean code. Let's establish a common ground so that we can improve software","\u2014","not only for ourselves but for the sake of everyone."))}u.isMDXComponent=!0}}]);