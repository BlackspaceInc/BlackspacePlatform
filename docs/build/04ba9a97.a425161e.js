(window.webpackJsonp=window.webpackJsonp||[]).push([[8],{62:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return i})),n.d(t,"metadata",(function(){return r})),n.d(t,"rightToc",(function(){return l})),n.d(t,"default",(function(){return u}));var a=n(2),o=n(6),s=(n(0),n(236)),i={title:"Application Development"},r={unversionedId:"checklists/backend/backend-kubernetes/application-development",id:"checklists/backend/backend-kubernetes/application-development",isDocsHomePage:!1,title:"Application Development",description:"Best practices for application development on Kubernetes.",source:"@site/docs/checklists/backend/backend-kubernetes/application-development.md",slug:"/checklists/backend/backend-kubernetes/application-development",permalink:"/docs/checklists/backend/backend-kubernetes/application-development",version:"current",sidebar:"docs",previous:{title:"Scalable Systems Resources",permalink:"/docs/learning/scalability/scalability"},next:{title:"Best Practices",permalink:"/docs/checklists/backend/backend-kubernetes/best-practices"}},l=[{value:"Health checks",id:"health-checks",children:[{value:"Containers have Readiness probes",id:"containers-have-readiness-probes",children:[]},{value:"Containers crash when there&#39;s a fatal error",id:"containers-crash-when-theres-a-fatal-error",children:[]},{value:"Configure a passive Liveness probe",id:"configure-a-passive-liveness-probe",children:[]},{value:"Liveness probes values aren&#39;t the same as the Readiness",id:"liveness-probes-values-arent-the-same-as-the-readiness",children:[]}]},{value:"Apps are independent",id:"apps-are-independent",children:[{value:"The Readiness probes are independent",id:"the-readiness-probes-are-independent",children:[]},{value:"The app retries connecting to dependent services",id:"the-app-retries-connecting-to-dependent-services",children:[]}]},{value:"Graceful shutdown",id:"graceful-shutdown",children:[{value:"The app doesn&#39;t shut down on SIGTERM, but it gracefully terminates connections",id:"the-app-doesnt-shut-down-on-sigterm-but-it-gracefully-terminates-connections",children:[]},{value:"The app still processes incoming requests in the grace period",id:"the-app-still-processes-incoming-requests-in-the-grace-period",children:[]},{value:"The CMD in the <code>Dockerfile</code> forwards the SIGTERM to the process",id:"the-cmd-in-the-dockerfile-forwards-the-sigterm-to-the-process",children:[]},{value:"Close all idle keep-alive sockets",id:"close-all-idle-keep-alive-sockets",children:[]}]},{value:"Fault tolerance",id:"fault-tolerance",children:[{value:"Run more than one replica for your Deployment",id:"run-more-than-one-replica-for-your-deployment",children:[]},{value:"Avoid Pods being placed into a single node",id:"avoid-pods-being-placed-into-a-single-node",children:[]},{value:"Set Pod disruption budgets",id:"set-pod-disruption-budgets",children:[]}]},{value:"Resources utilisation",id:"resources-utilisation",children:[{value:"Set memory limits and requests for all containers",id:"set-memory-limits-and-requests-for-all-containers",children:[]},{value:"Set CPU request to 1 CPU or below",id:"set-cpu-request-to-1-cpu-or-below",children:[]},{value:"Disable CPU limits \u2014 unless you have a good use case",id:"disable-cpu-limits--unless-you-have-a-good-use-case",children:[]},{value:"The namespace has a LimitRange",id:"the-namespace-has-a-limitrange",children:[]},{value:"Set an appropriate Quality of Service (QoS) for Pods",id:"set-an-appropriate-quality-of-service-qos-for-pods",children:[]}]},{value:"Tagging resources",id:"tagging-resources",children:[{value:"Resources have technical labels defined",id:"resources-have-technical-labels-defined",children:[]},{value:"Resources have business labels defined",id:"resources-have-business-labels-defined",children:[]},{value:"Resources have security labels defined",id:"resources-have-security-labels-defined",children:[]}]},{value:"Logging",id:"logging",children:[{value:"The application logs to <code>stdout</code> and <code>stderr</code>",id:"the-application-logs-to-stdout-and-stderr",children:[]},{value:"Avoid sidecars for logging (if you can)",id:"avoid-sidecars-for-logging-if-you-can",children:[]}]},{value:"Scaling",id:"scaling",children:[{value:"Containers do not store any state in their local filesystem",id:"containers-do-not-store-any-state-in-their-local-filesystem",children:[]},{value:"Use the Horizontal Pod Autoscaler for apps with variable usage patterns",id:"use-the-horizontal-pod-autoscaler-for-apps-with-variable-usage-patterns",children:[]},{value:"Don&#39;t use the Vertical Pod Autoscaler while it&#39;s still in beta",id:"dont-use-the-vertical-pod-autoscaler-while-its-still-in-beta",children:[]},{value:"Use the Cluster Autoscaler if you have highly varying workloads",id:"use-the-cluster-autoscaler-if-you-have-highly-varying-workloads",children:[]}]},{value:"Configuration and secrets",id:"configuration-and-secrets",children:[{value:"Externalise all configuration",id:"externalise-all-configuration",children:[]},{value:"Mount Secrets as volumes, not enviroment variables",id:"mount-secrets-as-volumes-not-enviroment-variables",children:[]}]}],c={rightToc:l};function u(e){var t=e.components,n=Object(o.a)(e,["components"]);return Object(s.b)("wrapper",Object(a.a)({},c,n,{components:t,mdxType:"MDXLayout"}),Object(s.b)("p",null,"Best practices for application development on Kubernetes."),Object(s.b)("h2",{id:"health-checks"},"Health checks"),Object(s.b)("p",null,"Kubernetes offers two mechanisms to track the lifecycle of your containers and Pods: liveness and readiness probes."),Object(s.b)("p",null,Object(s.b)("strong",{parentName:"p"},"The readiness probe determines when a container can receive traffic.")),Object(s.b)("p",null,"The kubelet executes the checks and decides if the app can receive traffic or not."),Object(s.b)("p",null,Object(s.b)("strong",{parentName:"p"},"The liveness probe determines when a container should be restarted.")),Object(s.b)("p",null,"The kubelet executes the check and decides if the container should be restarted."),Object(s.b)("p",null,Object(s.b)("strong",{parentName:"p"},"Resources:")),Object(s.b)("ul",null,Object(s.b)("li",{parentName:"ul"},"The official Kubernetes documentation offers some practical advice on how to ",Object(s.b)("a",Object(a.a)({parentName:"li"},{href:"https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes/"}),"configure Liveness, Readiness and Startup Probes"),"."),Object(s.b)("li",{parentName:"ul"},Object(s.b)("a",Object(a.a)({parentName:"li"},{href:"https://srcco.de/posts/kubernetes-liveness-probes-are-dangerous.html"}),"Liveness probes are dangerous")," has some information on how to set (or not) dependencies in your readiness probes.")),Object(s.b)("h3",{id:"containers-have-readiness-probes"},"Containers have Readiness probes"),Object(s.b)("blockquote",null,Object(s.b)("p",{parentName:"blockquote"},"Please note that there's no default value for readiness and liveness.")),Object(s.b)("p",null,"If you don't set the readiness probe, the kubelet assumes that the app is ready to receive traffic as soon as the container starts."),Object(s.b)("p",null,"If the container takes 2 minutes to start, all the requests to it will fail for those 2 minutes."),Object(s.b)("h3",{id:"containers-crash-when-theres-a-fatal-error"},"Containers crash when there's a fatal error"),Object(s.b)("p",null,"If the application reaches an unrecoverable error, ",Object(s.b)("a",Object(a.a)({parentName:"p"},{href:"https://blog.colinbreck.com/kubernetes-liveness-and-readiness-probes-revisited-how-to-avoid-shooting-yourself-in-the-other-foot/#letitcrash"}),"you should let it crash"),"."),Object(s.b)("p",null,"Examples of such unrecoverable errors are:"),Object(s.b)("ul",null,Object(s.b)("li",{parentName:"ul"},"an uncaught exception"),Object(s.b)("li",{parentName:"ul"},"a typo in the code (for dynamic languages)"),Object(s.b)("li",{parentName:"ul"},"unable to load a header or dependency")),Object(s.b)("p",null,"Please note that you should not signal a failing Liveness probe."),Object(s.b)("p",null,"Instead, you should immediately exit the process and let the kubelet restart the container."),Object(s.b)("h3",{id:"configure-a-passive-liveness-probe"},"Configure a passive Liveness probe"),Object(s.b)("p",null,"The Liveness probe is designed to restart your container when it's stuck."),Object(s.b)("p",null,"Consider the following scenario: if your application is processing an infinite loop, there's no way to exit or ask for help."),Object(s.b)("p",null,"When the process is consuming 100% CPU, it won't have time to reply to the (other) Readiness probe checks, and it will be eventually removed from the Service."),Object(s.b)("p",null,"However, the Pod is still registered as an active replica for the current Deployment."),Object(s.b)("p",null,"If you don't have a Liveness probe, it stays ",Object(s.b)("em",{parentName:"p"},"Running")," but detached from the Service."),Object(s.b)("p",null,"In other words, not only is the process not serving any requests, but it is also consuming resources."),Object(s.b)("p",null,Object(s.b)("em",{parentName:"p"},"What should you do?")),Object(s.b)("ol",null,Object(s.b)("li",{parentName:"ol"},"Expose an endpoint from your app"),Object(s.b)("li",{parentName:"ol"},"The endpoint always replies with a success response"),Object(s.b)("li",{parentName:"ol"},"Consume the endpoint from the Liveness probe")),Object(s.b)("p",null,"Please note that you should not use the Liveness probe to handle fatal errors in your app and request Kubernetes to restart the app."),Object(s.b)("p",null,"Instead, you should let the app crash."),Object(s.b)("p",null,"The Liveness probe should be used as a recovery mechanism only in case the process is not responsive."),Object(s.b)("h3",{id:"liveness-probes-values-arent-the-same-as-the-readiness"},"Liveness probes values aren't the same as the Readiness"),Object(s.b)("p",null,"When Liveness and Readiness probes are pointing to the same endpoint, the effects of the probes are combined."),Object(s.b)("p",null,"When the app signals that it's not ready or live, the kubelet detaches the container from the Service and delete it ",Object(s.b)("strong",{parentName:"p"},"at the same time"),"."),Object(s.b)("p",null,"You might notice dropping connections because the container does not have enough time to drain the current connections or process the incoming ones."),Object(s.b)("p",null,"You can dig deeper in the following ",Object(s.b)("a",Object(a.a)({parentName:"p"},{href:"https://freecontent.manning.com/handling-client-requests-properly-with-kubernetes/"}),"article that discussed graceful shutdown"),"."),Object(s.b)("h2",{id:"apps-are-independent"},"Apps are independent"),Object(s.b)("p",null,"You might be tempted to signal the readiness of your app only if all of the dependencies such as databases or backend API are also ready."),Object(s.b)("p",null,"If the app connects to a database, you might think that returning a failing readiness probe until the database is ",Object(s.b)("em",{parentName:"p"},"ready")," is a good idea \u2014 it is not."),Object(s.b)("p",null,"Consider the following scenario: you have one front-end app that depends on a backend API."),Object(s.b)("p",null,"If the API is flaky (e.g. it's unavailable from time to time due to a bug), the readiness probe fails, and the dependent readiness in the front-end app fail as well."),Object(s.b)("p",null,"And you have downtime."),Object(s.b)("p",null,"More in general, ",Object(s.b)("strong",{parentName:"p"},"a failure in a dependency downstream could propagate to all apps upstream")," and eventually, bring down your front-end facing layer as well."),Object(s.b)("h3",{id:"the-readiness-probes-are-independent"},"The Readiness probes are independent"),Object(s.b)("p",null,"The readiness probe doesn't include dependencies to services such as:"),Object(s.b)("ul",null,Object(s.b)("li",{parentName:"ul"},"databases"),Object(s.b)("li",{parentName:"ul"},"database migrations"),Object(s.b)("li",{parentName:"ul"},"APIs"),Object(s.b)("li",{parentName:"ul"},"third party services")),Object(s.b)("p",null,"You can ",Object(s.b)("a",Object(a.a)({parentName:"p"},{href:"https://blog.colinbreck.com/kubernetes-liveness-and-readiness-probes-how-to-avoid-shooting-yourself-in-the-foot/#shootingyourselfinthefootwithreadinessprobes"}),"explore what happens when there're dependencies in the readiness probes in this essay"),"."),Object(s.b)("h3",{id:"the-app-retries-connecting-to-dependent-services"},"The app retries connecting to dependent services"),Object(s.b)("p",null,"When the app starts, it shouldn't crash because a dependency such as a database isn't ready."),Object(s.b)("p",null,"Instead, the app should keep retrying to connect to the database until it succeeds."),Object(s.b)("p",null,"Kubernetes expects that application components can be started in any order."),Object(s.b)("p",null,"When you make sure that your app can reconnect to a dependency such as a database you know you can deliver a more robust and resilient service."),Object(s.b)("h2",{id:"graceful-shutdown"},"Graceful shutdown"),Object(s.b)("p",null,"When a Pod is deleted, you don't want to terminate all connections abruptly."),Object(s.b)("p",null,"Instead, you should wait for the existing connection to drain and stop processing new ones."),Object(s.b)("p",null,"Please notice that, when a Pod is terminated, the endpoints for that Pod are removed from the Service."),Object(s.b)("p",null,"However, it might take some time before component such as kube-proxy or the Ingress controller is notified of the change."),Object(s.b)("p",null,"You can find a detail explanation on how graceful shutdown works in ",Object(s.b)("a",Object(a.a)({parentName:"p"},{href:"https://freecontent.manning.com/handling-client-requests-properly-with-kubernetes/"}),"handling client requests correctly with Kubernetes"),"."),Object(s.b)("p",null,"The correct graceful shutdown sequence is:"),Object(s.b)("ol",null,Object(s.b)("li",{parentName:"ol"},"upon receiving SIGTERM"),Object(s.b)("li",{parentName:"ol"},"the server stops accepting new connections"),Object(s.b)("li",{parentName:"ol"},"completes all active requests"),Object(s.b)("li",{parentName:"ol"},"then immediately kills all keepalive connections and"),Object(s.b)("li",{parentName:"ol"},"the process exits")),Object(s.b)("p",null,"You can ",Object(s.b)("a",Object(a.a)({parentName:"p"},{href:"https://github.com/mikkeloscar/kube-sigterm-test"}),"test that your app gracefully shuts down with this tool: kube-sigterm-test"),"."),Object(s.b)("h3",{id:"the-app-doesnt-shut-down-on-sigterm-but-it-gracefully-terminates-connections"},"The app doesn't shut down on SIGTERM, but it gracefully terminates connections"),Object(s.b)("p",null,"It might take some time before a component such as kube-proxy or the Ingress controller is notified of the endpoint changes."),Object(s.b)("p",null,"Hence, traffic might still flow to the Pod despite it being marked as terminated."),Object(s.b)("p",null,"The app should stop accepting new requests on all remaining connections, and close these once the outgoing queue is drained."),Object(s.b)("p",null,"If you need a refresher on how endpoints are propagated in your cluster, ",Object(s.b)("a",Object(a.a)({parentName:"p"},{href:"https://freecontent.manning.com/handling-client-requests-properly-with-kubernetes/"}),"read this article on how to handle client requests properly"),"."),Object(s.b)("h3",{id:"the-app-still-processes-incoming-requests-in-the-grace-period"},"The app still processes incoming requests in the grace period"),Object(s.b)("p",null,"You might want to consider using the container lifecycle events such as ",Object(s.b)("a",Object(a.a)({parentName:"p"},{href:"https://kubernetes.io/docs/tasks/configure-pod-container/attach-handler-lifecycle-event/#define-poststart-and-prestop-handlers"}),"the preStop handler")," to customize what happened before a Pod is deleted."),Object(s.b)("h3",{id:"the-cmd-in-the-dockerfile-forwards-the-sigterm-to-the-process"},"The CMD in the ",Object(s.b)("inlineCode",{parentName:"h3"},"Dockerfile")," forwards the SIGTERM to the process"),Object(s.b)("p",null,"You can be notified when the Pod is about to be terminated by capturing the SIGTERM signal in your app."),Object(s.b)("p",null,"You should also pay attention to ",Object(s.b)("a",Object(a.a)({parentName:"p"},{href:"https://pracucci.com/graceful-shutdown-of-kubernetes-pods.html"}),"forwarding the signal to the right process in your container"),"."),Object(s.b)("h3",{id:"close-all-idle-keep-alive-sockets"},"Close all idle keep-alive sockets"),Object(s.b)("p",null,"If the calling app is not closing the TCP connection (e.g. using TCP keep-alive or a connection pool) it will connect to one Pod and not use the other Pods in that Service."),Object(s.b)("p",null,Object(s.b)("em",{parentName:"p"},"But what happens when a Pod is deleted?")),Object(s.b)("p",null,"Ideally, the request should go to another Pod."),Object(s.b)("p",null,"However, the calling app has a long-lived connection open with the Pod that is about to be terminated, and it will keep using it."),Object(s.b)("p",null,"On the other hand, you shouldn't abruptly terminate long-lived connections."),Object(s.b)("p",null,"Instead, you should terminate them before shutting down the app."),Object(s.b)("p",null,"You can read about keep-alive connections on this article about ",Object(s.b)("a",Object(a.a)({parentName:"p"},{href:"http://dillonbuchanan.com/programming/gracefully-shutting-down-a-nodejs-http-server/"}),"gracefully shutting down a Nodejs HTTP server"),"."),Object(s.b)("h2",{id:"fault-tolerance"},"Fault tolerance"),Object(s.b)("p",null,"Your cluster nodes could disappear at any time for several reasons:"),Object(s.b)("ul",null,Object(s.b)("li",{parentName:"ul"},"a hardware failure of the physical machine"),Object(s.b)("li",{parentName:"ul"},"cloud provider or hypervisor failure"),Object(s.b)("li",{parentName:"ul"},"a kernel panic")),Object(s.b)("p",null,"Pods deployed in those nodes are lost too."),Object(s.b)("p",null,"Also, there are other scenarios where Pods could be deleted:"),Object(s.b)("ul",null,Object(s.b)("li",{parentName:"ul"},"directly deleting a pod (accident)"),Object(s.b)("li",{parentName:"ul"},"draining a node"),Object(s.b)("li",{parentName:"ul"},"removing a pod from a node to permit another Pod to fit on that node")),Object(s.b)("p",null,"Any of the above scenarios could affect the availability of your app and potentially cause downtime."),Object(s.b)("p",null,"You should protect from a scenario where all of your Pods are made unavailable, and you aren't able to serve live traffic."),Object(s.b)("h3",{id:"run-more-than-one-replica-for-your-deployment"},"Run more than one replica for your Deployment"),Object(s.b)("p",null,"Never run a single Pod individually."),Object(s.b)("p",null,"Instead consider deploying your Pod as part of a Deployment, DaemonSet, ReplicaSet or StatefulSet."),Object(s.b)("p",null,Object(s.b)("a",Object(a.a)({parentName:"p"},{href:"https://cloudmark.github.io/Node-Management-In-GKE/#replicas"}),"Running more than one instance your of your Pods guarantees that deleting a single Pod won't cause downtime"),"."),Object(s.b)("h3",{id:"avoid-pods-being-placed-into-a-single-node"},"Avoid Pods being placed into a single node"),Object(s.b)("p",null,Object(s.b)("strong",{parentName:"p"},"Even if you run several copies of your Pods, there are no guarantees that losing a node won't take down your service.")),Object(s.b)("p",null,"Consider the following scenario: you have 11 replicas on a single cluster node."),Object(s.b)("p",null,"If the node is made unavailable, the 11 replicas are lost, and you have downtime."),Object(s.b)("p",null,Object(s.b)("a",Object(a.a)({parentName:"p"},{href:"https://cloudmark.github.io/Node-Management-In-GKE/#pod-anti-affinity-rules"}),"You should apply anti-affinity rules to your Deployments so that Pods are spread in all the nodes of your cluster"),"."),Object(s.b)("p",null,"The ",Object(s.b)("a",Object(a.a)({parentName:"p"},{href:"https://kubernetes.io/docs/concepts/configuration/assign-pod-node/#inter-pod-affinity-and-anti-affinity"}),"inter-pod affinity and anti-affinity")," documentation describe how you can you could change your Pod to be located (or not) in the same node."),Object(s.b)("h3",{id:"set-pod-disruption-budgets"},"Set Pod disruption budgets"),Object(s.b)("p",null,"When a node is drained, all the Pods on that node are deleted and rescheduled."),Object(s.b)("p",null,Object(s.b)("em",{parentName:"p"},"But what if you are under heavy load and you can't lose more than 50% of your Pods?")),Object(s.b)("p",null,"The drain event could affect your availability."),Object(s.b)("p",null,"To protect the Deployments from unexpected events that could take down several Pods at the same time, you can define Pod Disruption Budget."),Object(s.b)("p",null,"Imagine saying: ",Object(s.b)("em",{parentName:"p"},'"Kubernetes, please make sure that there are always at least 5 Pods running for my app".')),Object(s.b)("p",null,"Kubernetes will prevent the drain event if the final state results in less than 5 Pods for that Deployment."),Object(s.b)("p",null,"The official documentation is an excellent place to start to understand ",Object(s.b)("a",Object(a.a)({parentName:"p"},{href:"https://kubernetes.io/docs/concepts/workloads/pods/disruptions/"}),"Pod Disruption Budgets"),"."),Object(s.b)("h2",{id:"resources-utilisation"},"Resources utilisation"),Object(s.b)("p",null,"You can think about the Kubernetes as a skilled Tetris player."),Object(s.b)("p",null,"Docker containers are the blocks; servers are the boards, and the scheduler is the player."),Object(s.b)("p",null,"To maximise the efficiency of the scheduler, you should share with Kubernetes details such as resource utilisation, workload priorities and overheads."),Object(s.b)("h3",{id:"set-memory-limits-and-requests-for-all-containers"},"Set memory limits and requests for all containers"),Object(s.b)("p",null,"Resource limits are used to constrain how much CPU and memory your containers can utilise and are set using the resources property of a ",Object(s.b)("inlineCode",{parentName:"p"},"containerSpec"),"."),Object(s.b)("p",null,"The scheduler uses those as one of metrics to decide which node is best suited for the current Pod."),Object(s.b)("p",null,"A container without a memory limit has memory utilisation of zero \u2014 according to the scheduler."),Object(s.b)("p",null,"An unlimited number of Pods if schedulable on any nodes leading to resource overcommitment and potential node (and kubelet) crashes."),Object(s.b)("p",null,"The same applies to CPU limits."),Object(s.b)("p",null,Object(s.b)("em",{parentName:"p"},"But should you always set limits and requests for memory and CPU?")),Object(s.b)("p",null,"Yes and no."),Object(s.b)("p",null,"If your process goes over the memory limit, the process is terminated."),Object(s.b)("p",null,"Since CPU is a compressible resource, if your container goes over the limit, the process is throttled."),Object(s.b)("p",null,"Even if it could have used some of the CPU that was available at that moment."),Object(s.b)("p",null,Object(s.b)("strong",{parentName:"p"},Object(s.b)("a",Object(a.a)({parentName:"strong"},{href:"https://www.reddit.com/r/kubernetes/comments/cmp7jj/multithreading_in_a_container_with_limited/ew52fcj/"}),"CPU limits are hard.")),"s"),Object(s.b)("p",null,"If you wish to dig deeper into CPU and memory limits you should check out the following articles:"),Object(s.b)("ul",null,Object(s.b)("li",{parentName:"ul"},Object(s.b)("a",Object(a.a)({parentName:"li"},{href:"https://medium.com/@betz.mark/understanding-resource-limits-in-kubernetes-memory-6b41e9a955f9"}),"Understanding resource limits in kubernetes: memory")),Object(s.b)("li",{parentName:"ul"},Object(s.b)("a",Object(a.a)({parentName:"li"},{href:"https://medium.com/@betz.mark/understanding-resource-limits-in-kubernetes-cpu-time-9eff74d3161b"}),"Understanding resource limits in kubernetes: cpu time"))),Object(s.b)("blockquote",null,Object(s.b)("p",{parentName:"blockquote"},"Please note that if you are not sure what should be the ",Object(s.b)("em",{parentName:"p"},"right")," CPU or memory limit, you can use the ",Object(s.b)("a",Object(a.a)({parentName:"p"},{href:"https://github.com/kubernetes/autoscaler/tree/master/vertical-pod-autoscaler"}),"Vertical Pod Autoscaler")," in Kubernetes with the recommendation mode turned on. The autoscaler profiles your app and recommends limits for it.")),Object(s.b)("h3",{id:"set-cpu-request-to-1-cpu-or-below"},"Set CPU request to 1 CPU or below"),Object(s.b)("p",null,"Unless you have computational intensive jobs, ",Object(s.b)("a",Object(a.a)({parentName:"p"},{href:"https://www.youtube.com/watch?v=xjpHggHKm78"}),"it is recommended to set the request to 1 CPU or below"),"."),Object(s.b)("h3",{id:"disable-cpu-limits--unless-you-have-a-good-use-case"},"Disable CPU limits \u2014 unless you have a good use case"),Object(s.b)("p",null,"CPU is measured as CPU timeunits per timeunit."),Object(s.b)("p",null,Object(s.b)("inlineCode",{parentName:"p"},"cpu: 1")," means 1 CPU second per second."),Object(s.b)("p",null,"If you have 1 thread, you can't consume more than 1 CPU second per second."),Object(s.b)("p",null,"If you have 2 threads, you can consume 1 CPU second in 0.5 seconds."),Object(s.b)("p",null,"8 threads can consume 1 CPU second in 0.125 seconds."),Object(s.b)("p",null,"After that, your process is throttled."),Object(s.b)("p",null,"If you're not sure about what's the best settings for your app, it's better not to set the CPU limits."),Object(s.b)("p",null,"If you wish to learn more, ",Object(s.b)("a",Object(a.a)({parentName:"p"},{href:"https://medium.com/@betz.mark/understanding-resource-limits-in-kubernetes-cpu-time-9eff74d3161b"}),"this article digs deeper in CPU requests and limits"),"."),Object(s.b)("h3",{id:"the-namespace-has-a-limitrange"},"The namespace has a LimitRange"),Object(s.b)("p",null,"If you think you might forget to set memory and CPU limits, you should consider using a LimitRange object to define the standard size for a container deployed in the current namespace."),Object(s.b)("p",null,Object(s.b)("a",Object(a.a)({parentName:"p"},{href:"https://kubernetes.io/docs/concepts/policy/limit-range/"}),"The official documentation about LimitRange")," is an excellent place to start."),Object(s.b)("h3",{id:"set-an-appropriate-quality-of-service-qos-for-pods"},"Set an appropriate Quality of Service (QoS) for Pods"),Object(s.b)("p",null,"When a node goes into an overcommitted state (i.e. using too many resources) Kubernetes tries to evict some of the Pod in that Node."),Object(s.b)("p",null,"Kubernetes ranks and evicts the Pods according to a well-defined logic."),Object(s.b)("p",null,"You can find more about ",Object(s.b)("a",Object(a.a)({parentName:"p"},{href:"https://kubernetes.io/docs/tasks/configure-pod-container/quality-service-pod/"}),"configuring the quality of service for your Pods")," on the official documentation."),Object(s.b)("h2",{id:"tagging-resources"},"Tagging resources"),Object(s.b)("p",null,"Labels are the mechanism you use to organize Kubernetes objects."),Object(s.b)("p",null,"A label is a key-value pair without any pre-defined meaning."),Object(s.b)("p",null,"They can be applied to all resources in your cluster from Pods to Service, Ingress manifests, Endpoints, etc."),Object(s.b)("p",null,"You can use labels to categorize resources by purpose, owner, environment, or other criteria."),Object(s.b)("p",null,'So you could choose a label to tag a Pod in an environment such as "this pod is running in production" or "the payment team owns that Deployment".'),Object(s.b)("p",null,"You can also omit labels altogether."),Object(s.b)("p",null,"However, you might want to consider using labels to cover the following categories:"),Object(s.b)("ul",null,Object(s.b)("li",{parentName:"ul"},"technical labels such as the environment"),Object(s.b)("li",{parentName:"ul"},"labels for automation"),Object(s.b)("li",{parentName:"ul"},"label related to your business such as cost-centre allocation"),Object(s.b)("li",{parentName:"ul"},"label related to security such as compliance requirements")),Object(s.b)("h3",{id:"resources-have-technical-labels-defined"},"Resources have technical labels defined"),Object(s.b)("p",null,"You could tag your Pods with:"),Object(s.b)("ul",null,Object(s.b)("li",{parentName:"ul"},Object(s.b)("inlineCode",{parentName:"li"},"name"),', the name of the application such "User API"'),Object(s.b)("li",{parentName:"ul"},Object(s.b)("inlineCode",{parentName:"li"},"instance"),", a unique name identifying the instance of an application (you could use the container image tag)"),Object(s.b)("li",{parentName:"ul"},Object(s.b)("inlineCode",{parentName:"li"},"version"),", the current version of the appl (an incremental counter)"),Object(s.b)("li",{parentName:"ul"},Object(s.b)("inlineCode",{parentName:"li"},"component"),', the component within the architecture such as "API" or "database"'),Object(s.b)("li",{parentName:"ul"},Object(s.b)("inlineCode",{parentName:"li"},"part-of"),', the name of a higher-level application this one is part of such as "payment gateway"'),Object(s.b)("li",{parentName:"ul"},Object(s.b)("inlineCode",{parentName:"li"},"managed-by"),', the tool being used to manage the operation of an application such as "kubectl" or "Helm"')),Object(s.b)("p",null,"Here's an example on how you could use such labels in a Deployment:"),Object(s.b)("pre",null,Object(s.b)("code",Object(a.a)({parentName:"pre"},{className:"language-yaml|highlight=6-11,20-24|title=deployment.yaml"}),'apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: deployment\n  labels:\n    app.kubernetes.io/name: user-api\n    app.kubernetes.io/instance: user-api-5fa65d2\n    app.kubernetes.io/version: "42"\n    app.kubernetes.io/component: api\n    app.kubernetes.io/part-of: payment-gateway\n    app.kubernetes.io/managed-by: kubectl\nspec:\n  replicas: 3\n  selector:\n    matchLabels:\n      application: my-app\n  template:\n    metadata:\n      labels:\n        app.kubernetes.io/name: user-api\n        app.kubernetes.io/instance: user-api-5fa65d2\n        app.kubernetes.io/version: "42"\n        app.kubernetes.io/component: api\n        app.kubernetes.io/part-of: payment-gateway\n    spec:\n      containers:\n      - name: app\n        image: myapp\n')),Object(s.b)("p",null,"Those labels are ",Object(s.b)("a",Object(a.a)({parentName:"p"},{href:"https://kubernetes.io/docs/concepts/overview/working-with-objects/common-labels/"}),"recommended by the official documentation"),"."),Object(s.b)("blockquote",null,Object(s.b)("p",{parentName:"blockquote"},"Please not that you're recommended to tag ",Object(s.b)("strong",{parentName:"p"},"all resources"),".")),Object(s.b)("h3",{id:"resources-have-business-labels-defined"},"Resources have business labels defined"),Object(s.b)("p",null,"You could tag your Pods with:"),Object(s.b)("ul",null,Object(s.b)("li",{parentName:"ul"},Object(s.b)("inlineCode",{parentName:"li"},"owner"),", used to identify who is responsible for the resource"),Object(s.b)("li",{parentName:"ul"},Object(s.b)("inlineCode",{parentName:"li"},"project"),", used to determine the project that the resource belongs to"),Object(s.b)("li",{parentName:"ul"},Object(s.b)("inlineCode",{parentName:"li"},"business-unit"),", used to identify the cost centre or business unit associated with a resource; typically for cost allocation and tracking")),Object(s.b)("p",null,"Here's an example on how you could use such labels in a Deployment:"),Object(s.b)("pre",null,Object(s.b)("code",Object(a.a)({parentName:"pre"},{className:"language-yaml|highlight=6-8,17-19|title=deployment.yaml"}),'apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: deployment\n  labels:\n    owner: payment-team\n    project: fraud-detection\n    business-unit: "80432"\nspec:\n  replicas: 3\n  selector:\n    matchLabels:\n      application: my-app\n  template:\n    metadata:\n      labels:\n        owner: payment-team\n        project: fraud-detection\n        business-unit: "80432"\n    spec:\n      containers:\n      - name: app\n        image: myapp\n')),Object(s.b)("p",null,"You can explore labels and ",Object(s.b)("a",Object(a.a)({parentName:"p"},{href:"https://aws.amazon.com/answers/account-management/aws-tagging-strategies/"}),"tagging for resources on the AWS tagging strategy page"),"."),Object(s.b)("p",null,"The article isn't specific to Kubernetes but explores some of the most common strategies for tagging resources."),Object(s.b)("blockquote",null,Object(s.b)("p",{parentName:"blockquote"},"Please not that you're recommended to tag ",Object(s.b)("strong",{parentName:"p"},"all resources"),".")),Object(s.b)("h3",{id:"resources-have-security-labels-defined"},"Resources have security labels defined"),Object(s.b)("p",null,"You could tag your Pods with:"),Object(s.b)("ul",null,Object(s.b)("li",{parentName:"ul"},Object(s.b)("inlineCode",{parentName:"li"},"confidentiality"),", an identifier for the specific data-confidentiality level a resource supports"),Object(s.b)("li",{parentName:"ul"},Object(s.b)("inlineCode",{parentName:"li"},"compliance"),", an identifier for workloads designed to adhere to specific compliance requirements")),Object(s.b)("p",null,"Here's an example on how you could use such labels in a Deployment:"),Object(s.b)("pre",null,Object(s.b)("code",Object(a.a)({parentName:"pre"},{className:"language-yaml|highlight=6-11,20-24|title=deployment.yaml"}),"apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: deployment\n  labels:\n    confidentiality: official\n    compliance: pci\nspec:\n  replicas: 3\n  selector:\n    matchLabels:\n      application: my-app\n  template:\n    metadata:\n      labels:\n        confidentiality: official\n        compliance: pci\n    spec:\n      containers:\n      - name: app\n        image: myapp\n")),Object(s.b)("p",null,"You can explore label and ",Object(s.b)("a",Object(a.a)({parentName:"p"},{href:"https://aws.amazon.com/answers/account-management/aws-tagging-strategies/"}),"tagging for resources on the AWS tagging strategy page"),"."),Object(s.b)("p",null,"The article isn't specific to Kubernetes but explores some of the most common strategies for tagging resources."),Object(s.b)("blockquote",null,Object(s.b)("p",{parentName:"blockquote"},"Please not that you're recommended to tag ",Object(s.b)("strong",{parentName:"p"},"all resources"),".")),Object(s.b)("h2",{id:"logging"},"Logging"),Object(s.b)("p",null,"Application logs can help you understand what is happening inside your app."),Object(s.b)("p",null,"The logs are particularly useful for debugging problems and monitoring app activity."),Object(s.b)("h3",{id:"the-application-logs-to-stdout-and-stderr"},"The application logs to ",Object(s.b)("inlineCode",{parentName:"h3"},"stdout")," and ",Object(s.b)("inlineCode",{parentName:"h3"},"stderr")),Object(s.b)("p",null,"There are two logging strategies: ",Object(s.b)("em",{parentName:"p"},"passive")," and ",Object(s.b)("em",{parentName:"p"},"active"),"."),Object(s.b)("p",null,"Apps that use passive logging are unaware of the logging infrastructure and log messages to standard outputs."),Object(s.b)("p",null,"This best practice is part of ",Object(s.b)("a",Object(a.a)({parentName:"p"},{href:"https://12factor.net/logs"}),"the twelve-factor app"),"."),Object(s.b)("p",null,"In active logging, the app makes network connections to intermediate aggregators, sends data to third-party logging services, or writes directly to a database or index."),Object(s.b)("p",null,"Active logging is considered an antipattern, and it should be avoided."),Object(s.b)("h3",{id:"avoid-sidecars-for-logging-if-you-can"},"Avoid sidecars for logging (if you can)"),Object(s.b)("p",null,"If you wish to ",Object(s.b)("a",Object(a.a)({parentName:"p"},{href:"https://rclayton.silvrback.com/container-services-logging-with-docker#effective-logging-infrastructure"}),"apply log transformations to an application with a non-standard log event model"),", you may want to use a sidecar container."),Object(s.b)("p",null,"With a sidecar container, you can normalise the log entries before they are shipped elsewhere."),Object(s.b)("p",null,"For example, you may want to transform Apache logs into Logstash JSON format before shipping it to the logging infrastructure."),Object(s.b)("p",null,"However, if you have control over the application, you could output the right format, to begin with."),Object(s.b)("p",null,"You could save on running an extra container for each Pod in your cluster."),Object(s.b)("h2",{id:"scaling"},"Scaling"),Object(s.b)("h3",{id:"containers-do-not-store-any-state-in-their-local-filesystem"},"Containers do not store any state in their local filesystem"),Object(s.b)("p",null,"Containers have a local filesystem and you might be tempted to use it for persisting data."),Object(s.b)("p",null,"However, storing persistent data in a container's local filesystem prevents the encompassing Pod from being scaled horizontally (that is, by adding or removing replicas of the Pod)."),Object(s.b)("p",null,'This is because, by using the local filesystem, each container maintains its own "state", which means that the states of Pod replicas may diverge over time. This results in inconsistent behaviour from the user\'s point of view (for example, a specific piece of user information is available when the request hits one Pod, but not when the request hits another Pod).'),Object(s.b)("p",null,"Instead, any persistent information should be saved at a central place outside the Pods. For example, in a PersistentVolume in the cluster, or even better in some storage service outside the cluster."),Object(s.b)("h3",{id:"use-the-horizontal-pod-autoscaler-for-apps-with-variable-usage-patterns"},"Use the Horizontal Pod Autoscaler for apps with variable usage patterns"),Object(s.b)("p",null,"The ",Object(s.b)("a",Object(a.a)({parentName:"p"},{href:"https://kubernetes.io/docs/tasks/run-application/horizontal-pod-autoscale/"}),"Horizontal Pod Autoscaler (HPA)")," is a built-in Kubernetes feature that monitors your application and automatically adds or removes Pod replicas based on the current usage."),Object(s.b)("p",null,"Configuring the HPA allows your app to stay available and responsive under any traffic conditions, including unexpected spikes."),Object(s.b)("p",null,"To configure the HPA to autoscale your app, you have to create a ",Object(s.b)("a",Object(a.a)({parentName:"p"},{href:"https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.16/#horizontalpodautoscaler-v1-autoscaling"}),"HorizontalPodAutoscaler")," resource, which defines what metric to monitor for your app."),Object(s.b)("p",null,"The HPA can monitor either built-in resource metric (CPU and memory usage of your Pods) or custom metrics. In the case of custom metrics, you are also responsible for collecting and exposing these metrics, which you can do, for example, with ",Object(s.b)("a",Object(a.a)({parentName:"p"},{href:"https://prometheus.io/"}),"Prometheus")," and the ",Object(s.b)("a",Object(a.a)({parentName:"p"},{href:"https://github.com/DirectXMan12/k8s-prometheus-adapter"}),"Prometheus Adapter"),"."),Object(s.b)("h3",{id:"dont-use-the-vertical-pod-autoscaler-while-its-still-in-beta"},"Don't use the Vertical Pod Autoscaler while it's still in beta"),Object(s.b)("p",null,"Analogous to the ",Object(s.b)("a",Object(a.a)({parentName:"p"},{href:"https://kubernetes.io/docs/tasks/run-application/horizontal-pod-autoscale/"}),"Horizontal Pod Autoscaler (HPA)"),", there exists the ",Object(s.b)("a",Object(a.a)({parentName:"p"},{href:"https://github.com/kubernetes/autoscaler/tree/master/vertical-pod-autoscaler"}),"Vertical Pod Autoscaler (VPA)"),"."),Object(s.b)("p",null,"The VPA can automatically adapt the resource requests and limits of your Pods so that when a Pod needs more resources, it can get them (increasing/decreasing the resources of a single Pod is called ",Object(s.b)("em",{parentName:"p"},"vertical scaling"),", as opposed to ",Object(s.b)("em",{parentName:"p"},"horizontal scaling"),", which means increasing/decreasing the number of replicas of a Pod)."),Object(s.b)("p",null,"This can be useful for scaling applications that can't be scaled horizontally."),Object(s.b)("p",null,"However, the VPA is curently in beta and it has ",Object(s.b)("a",Object(a.a)({parentName:"p"},{href:"https://github.com/kubernetes/autoscaler/tree/master/vertical-pod-autoscaler#limitations-of-beta-version"}),"some known limitations")," (for example, scaling a Pod by changing its resource requirements, requires the Pod to be killed and restarted)."),Object(s.b)("p",null,"Given these limitations, and the fact that most applications on Kubernetes can be scaled horizontally anyway, it is recommended to not use the VPA in production (at least until there is a stable version)."),Object(s.b)("h3",{id:"use-the-cluster-autoscaler-if-you-have-highly-varying-workloads"},"Use the Cluster Autoscaler if you have highly varying workloads"),Object(s.b)("p",null,"The ",Object(s.b)("a",Object(a.a)({parentName:"p"},{href:"https://github.com/kubernetes/autoscaler/tree/master/cluster-autoscaler"}),"Cluster Autoscaler"),' is another type of "autoscaler" (besides the ',Object(s.b)("a",Object(a.a)({parentName:"p"},{href:"https://kubernetes.io/docs/tasks/run-application/horizontal-pod-autoscale/"}),"Horizontal Pod Autoscaler")," and ",Object(s.b)("a",Object(a.a)({parentName:"p"},{href:"https://github.com/kubernetes/autoscaler/tree/master/vertical-pod-autoscaler"}),"Vertical Pod Autoscaler"),")."),Object(s.b)("p",null,"The Cluster Autoscaler can automatically scale the size of your cluster by adding or removing worker nodes."),Object(s.b)("p",null,"A scale-up operation happens when a Pod fails to be scheduled because of insufficient resources on the existing worker nodes. In this case, the Cluster Autoscaler creates a new worker node, so that the Pod can be scheduled. Similarly, when the utilisation of the existing worker nodes is low, the Cluster Autoscaler can scale down by evicting all the workloads from one of the worker nodes and removing it."),Object(s.b)("p",null,"Using the Cluster Autoscaler makes sense for highly variable workloads, for example, when the number of Pods may multiply in a short time, and then go back to the previous value. In such scenarios, the Cluster Autoscaler allows you to meet the demand spikes without wasting resources by overprovisioning worker nodes."),Object(s.b)("p",null,"However, if your workloads do not vary so much, it may not be worth to set up the Cluster Autoscaler, as it may never be triggered. If your workloads grow slowly and monotonically, it may be enough to monitor the utilisations of your existing worker nodes and add an additional worker node manually when they reach a critical value."),Object(s.b)("h2",{id:"configuration-and-secrets"},"Configuration and secrets"),Object(s.b)("h3",{id:"externalise-all-configuration"},"Externalise all configuration"),Object(s.b)("p",null,"Configuration should be maintained outside the application code."),Object(s.b)("p",null,"This has several benefits. First, changing the configuration does not require recompiling the application. Second, the configuration can be updated when the application is running. Third, the same code can be used in different environments."),Object(s.b)("p",null,"In Kubernetes, the configuration can be saved in ConfigMaps, which can then be mounted into containers as volumes are passed in as environment variables."),Object(s.b)("p",null,"Save only non-sensitive configuration in ConfigMaps. For sensitive information (such as credentials), use the Secret resource."),Object(s.b)("h3",{id:"mount-secrets-as-volumes-not-enviroment-variables"},"Mount Secrets as volumes, not enviroment variables"),Object(s.b)("p",null,"The content of Secret resources should be mounted into containers as volumes rather than passed in as environment variables."),Object(s.b)("p",null,"This is to prevent that the secret values appear in the command that was used to start the container, which may be inspected by individuals that shouldn't have access to the secret values."))}u.isMDXComponent=!0}}]);