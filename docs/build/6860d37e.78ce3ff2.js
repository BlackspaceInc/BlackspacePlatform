(window.webpackJsonp=window.webpackJsonp||[]).push([[70],{137:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return b})),n.d(t,"metadata",(function(){return i})),n.d(t,"rightToc",(function(){return o})),n.d(t,"default",(function(){return s}));var a=n(2),l=n(6),r=(n(0),n(244)),b={title:"Blackspace Golang Style Guide"},i={unversionedId:"__guidelines/style_guide/golang/golang-styleguide",id:"__guidelines/style_guide/golang/golang-styleguide",isDocsHomePage:!1,title:"Blackspace Golang Style Guide",description:"\x3c!--",source:"@site/docs/__guidelines/style_guide/golang/golang-styleguide.md",slug:"/__guidelines/style_guide/golang/golang-styleguide",permalink:"/docs/__guidelines/style_guide/golang/golang-styleguide",version:"current",sidebar:"docs",previous:{title:"Common Golang P.R. Reviews",permalink:"/docs/__guidelines/style_guide/golang/common-review-comments"},next:{title:"Naming convention",permalink:"/docs/__guidelines/naming-convention"}},o=[{value:"Table of Contents",id:"table-of-contents",children:[]},{value:"Introduction",id:"introduction",children:[]},{value:"Guidelines",id:"guidelines",children:[{value:"Pointers to Interfaces",id:"pointers-to-interfaces",children:[]},{value:"Verify Interface Compliance",id:"verify-interface-compliance",children:[]},{value:"Receivers and Interfaces",id:"receivers-and-interfaces",children:[]},{value:"Zero-value Mutexes are Valid",id:"zero-value-mutexes-are-valid",children:[]},{value:"Copy Slices and Maps at Boundaries",id:"copy-slices-and-maps-at-boundaries",children:[]},{value:"Defer to Clean Up",id:"defer-to-clean-up",children:[]},{value:"Channel Size is One or None",id:"channel-size-is-one-or-none",children:[]},{value:"Start Enums at One",id:"start-enums-at-one",children:[]},{value:"Use <code>&quot;time&quot;</code> to handle time",id:"use-time-to-handle-time",children:[]},{value:"Error Types",id:"error-types",children:[]},{value:"Error Wrapping",id:"error-wrapping",children:[]},{value:"Handle Type Assertion Failures",id:"handle-type-assertion-failures",children:[]},{value:"Don&#39;t Panic",id:"dont-panic",children:[]},{value:"Use go.uber.org/atomic",id:"use-gouberorgatomic",children:[]},{value:"Avoid Mutable Globals",id:"avoid-mutable-globals",children:[]},{value:"Avoid Embedding Types in Public Structs",id:"avoid-embedding-types-in-public-structs",children:[]},{value:"Avoid Using Built-In Names",id:"avoid-using-built-in-names",children:[]},{value:"Avoid <code>init()</code>",id:"avoid-init",children:[]}]},{value:"Performance",id:"performance",children:[{value:"Prefer strconv over fmt",id:"prefer-strconv-over-fmt",children:[]},{value:"Avoid string-to-byte conversion",id:"avoid-string-to-byte-conversion",children:[]},{value:"Prefer Specifying Container Capacity",id:"prefer-specifying-container-capacity",children:[]}]},{value:"Style",id:"style",children:[{value:"Be Consistent",id:"be-consistent",children:[]},{value:"Group Similar Declarations",id:"group-similar-declarations",children:[]},{value:"Import Group Ordering",id:"import-group-ordering",children:[]},{value:"Package Names",id:"package-names",children:[]},{value:"Function Names",id:"function-names",children:[]},{value:"Import Aliasing",id:"import-aliasing",children:[]},{value:"Function Grouping and Ordering",id:"function-grouping-and-ordering",children:[]},{value:"Reduce Nesting",id:"reduce-nesting",children:[]},{value:"Unnecessary Else",id:"unnecessary-else",children:[]},{value:"Top-level Variable Declarations",id:"top-level-variable-declarations",children:[]},{value:"Prefix Unexported Globals with _",id:"prefix-unexported-globals-with-_",children:[]},{value:"Embedding in Structs",id:"embedding-in-structs",children:[]},{value:"Use Field Names to Initialize Structs",id:"use-field-names-to-initialize-structs",children:[]},{value:"Local Variable Declarations",id:"local-variable-declarations",children:[]},{value:"nil is a valid slice",id:"nil-is-a-valid-slice",children:[]},{value:"Reduce Scope of Variables",id:"reduce-scope-of-variables",children:[]},{value:"Avoid Naked Parameters",id:"avoid-naked-parameters",children:[]},{value:"Use Raw String Literals to Avoid Escaping",id:"use-raw-string-literals-to-avoid-escaping",children:[]},{value:"Initializing Struct References",id:"initializing-struct-references",children:[]},{value:"Initializing Maps",id:"initializing-maps",children:[]},{value:"Format Strings outside Printf",id:"format-strings-outside-printf",children:[]},{value:"Naming Printf-style Functions",id:"naming-printf-style-functions",children:[]}]},{value:"Patterns",id:"patterns",children:[{value:"Test Tables",id:"test-tables",children:[]},{value:"Functional Options",id:"functional-options",children:[]}]}],c={rightToc:o};function s(e){var t=e.components,n=Object(l.a)(e,["components"]);return Object(r.b)("wrapper",Object(a.a)({},c,n,{components:t,mdxType:"MDXLayout"}),Object(r.b)("h2",{id:"table-of-contents"},"Table of Contents"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("a",Object(a.a)({parentName:"li"},{href:"#table-of-contents"}),"Table of Contents")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("a",Object(a.a)({parentName:"li"},{href:"#introduction"}),"Introduction")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("a",Object(a.a)({parentName:"li"},{href:"#guidelines"}),"Guidelines"),Object(r.b)("ul",{parentName:"li"},Object(r.b)("li",{parentName:"ul"},Object(r.b)("a",Object(a.a)({parentName:"li"},{href:"#pointers-to-interfaces"}),"Pointers to Interfaces")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("a",Object(a.a)({parentName:"li"},{href:"#verify-interface-compliance"}),"Verify Interface Compliance")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("a",Object(a.a)({parentName:"li"},{href:"#receivers-and-interfaces"}),"Receivers and Interfaces")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("a",Object(a.a)({parentName:"li"},{href:"#zero-value-mutexes-are-valid"}),"Zero-value Mutexes are Valid")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("a",Object(a.a)({parentName:"li"},{href:"#copy-slices-and-maps-at-boundaries"}),"Copy Slices and Maps at Boundaries"),Object(r.b)("ul",{parentName:"li"},Object(r.b)("li",{parentName:"ul"},Object(r.b)("a",Object(a.a)({parentName:"li"},{href:"#receiving-slices-and-maps"}),"Receiving Slices and Maps")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("a",Object(a.a)({parentName:"li"},{href:"#returning-slices-and-maps"}),"Returning Slices and Maps")))),Object(r.b)("li",{parentName:"ul"},Object(r.b)("a",Object(a.a)({parentName:"li"},{href:"#defer-to-clean-up"}),"Defer to Clean Up")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("a",Object(a.a)({parentName:"li"},{href:"#channel-size-is-one-or-none"}),"Channel Size is One or None")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("a",Object(a.a)({parentName:"li"},{href:"#start-enums-at-one"}),"Start Enums at One")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("a",Object(a.a)({parentName:"li"},{href:"#use-time-to-handle-time"}),"Use ",Object(r.b)("inlineCode",{parentName:"a"},'"time"')," to handle time"),Object(r.b)("ul",{parentName:"li"},Object(r.b)("li",{parentName:"ul"},Object(r.b)("a",Object(a.a)({parentName:"li"},{href:"#use-timetime-for-instants-of-time"}),"Use ",Object(r.b)("inlineCode",{parentName:"a"},"time.Time")," for instants of time")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("a",Object(a.a)({parentName:"li"},{href:"#use-timeduration-for-periods-of-time"}),"Use ",Object(r.b)("inlineCode",{parentName:"a"},"time.Duration")," for periods of time")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("a",Object(a.a)({parentName:"li"},{href:"#use-timetime-and-timeduration-with-external-systems"}),"Use ",Object(r.b)("inlineCode",{parentName:"a"},"time.Time")," and ",Object(r.b)("inlineCode",{parentName:"a"},"time.Duration")," with external systems")))),Object(r.b)("li",{parentName:"ul"},Object(r.b)("a",Object(a.a)({parentName:"li"},{href:"#error-types"}),"Error Types")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("a",Object(a.a)({parentName:"li"},{href:"#error-wrapping"}),"Error Wrapping")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("a",Object(a.a)({parentName:"li"},{href:"#handle-type-assertion-failures"}),"Handle Type Assertion Failures")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("a",Object(a.a)({parentName:"li"},{href:"#dont-panic"}),"Don't Panic")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("a",Object(a.a)({parentName:"li"},{href:"#use-gouberorgatomic"}),"Use go.uber.org/atomic")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("a",Object(a.a)({parentName:"li"},{href:"#avoid-mutable-globals"}),"Avoid Mutable Globals")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("a",Object(a.a)({parentName:"li"},{href:"#avoid-embedding-types-in-public-structs"}),"Avoid Embedding Types in Public Structs")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("a",Object(a.a)({parentName:"li"},{href:"#avoid-using-built-in-names"}),"Avoid Using Built-In Names")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("a",Object(a.a)({parentName:"li"},{href:"#avoid-init"}),"Avoid ",Object(r.b)("inlineCode",{parentName:"a"},"init()"))))),Object(r.b)("li",{parentName:"ul"},Object(r.b)("a",Object(a.a)({parentName:"li"},{href:"#performance"}),"Performance"),Object(r.b)("ul",{parentName:"li"},Object(r.b)("li",{parentName:"ul"},Object(r.b)("a",Object(a.a)({parentName:"li"},{href:"#prefer-strconv-over-fmt"}),"Prefer strconv over fmt")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("a",Object(a.a)({parentName:"li"},{href:"#avoid-string-to-byte-conversion"}),"Avoid string-to-byte conversion")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("a",Object(a.a)({parentName:"li"},{href:"#prefer-specifying-container-capacity"}),"Prefer Specifying Container Capacity"),Object(r.b)("ul",{parentName:"li"},Object(r.b)("li",{parentName:"ul"},Object(r.b)("a",Object(a.a)({parentName:"li"},{href:"#specifying-map-capacity-hints"}),"Specifying Map Capacity Hints")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("a",Object(a.a)({parentName:"li"},{href:"#specifying-slice-capacity"}),"Specifying Slice Capacity")))))),Object(r.b)("li",{parentName:"ul"},Object(r.b)("a",Object(a.a)({parentName:"li"},{href:"#style"}),"Style"),Object(r.b)("ul",{parentName:"li"},Object(r.b)("li",{parentName:"ul"},Object(r.b)("a",Object(a.a)({parentName:"li"},{href:"#be-consistent"}),"Be Consistent")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("a",Object(a.a)({parentName:"li"},{href:"#group-similar-declarations"}),"Group Similar Declarations")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("a",Object(a.a)({parentName:"li"},{href:"#import-group-ordering"}),"Import Group Ordering")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("a",Object(a.a)({parentName:"li"},{href:"#package-names"}),"Package Names")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("a",Object(a.a)({parentName:"li"},{href:"#function-names"}),"Function Names")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("a",Object(a.a)({parentName:"li"},{href:"#import-aliasing"}),"Import Aliasing")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("a",Object(a.a)({parentName:"li"},{href:"#function-grouping-and-ordering"}),"Function Grouping and Ordering")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("a",Object(a.a)({parentName:"li"},{href:"#reduce-nesting"}),"Reduce Nesting")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("a",Object(a.a)({parentName:"li"},{href:"#unnecessary-else"}),"Unnecessary Else")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("a",Object(a.a)({parentName:"li"},{href:"#top-level-variable-declarations"}),"Top-level Variable Declarations")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("a",Object(a.a)({parentName:"li"},{href:"#prefix-unexported-globals-with-_"}),"Prefix Unexported Globals with _")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("a",Object(a.a)({parentName:"li"},{href:"#embedding-in-structs"}),"Embedding in Structs")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("a",Object(a.a)({parentName:"li"},{href:"#use-field-names-to-initialize-structs"}),"Use Field Names to Initialize Structs")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("a",Object(a.a)({parentName:"li"},{href:"#local-variable-declarations"}),"Local Variable Declarations")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("a",Object(a.a)({parentName:"li"},{href:"#nil-is-a-valid-slice"}),"nil is a valid slice")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("a",Object(a.a)({parentName:"li"},{href:"#reduce-scope-of-variables"}),"Reduce Scope of Variables")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("a",Object(a.a)({parentName:"li"},{href:"#avoid-naked-parameters"}),"Avoid Naked Parameters")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("a",Object(a.a)({parentName:"li"},{href:"#use-raw-string-literals-to-avoid-escaping"}),"Use Raw String Literals to Avoid Escaping")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("a",Object(a.a)({parentName:"li"},{href:"#initializing-struct-references"}),"Initializing Struct References")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("a",Object(a.a)({parentName:"li"},{href:"#initializing-maps"}),"Initializing Maps")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("a",Object(a.a)({parentName:"li"},{href:"#format-strings-outside-printf"}),"Format Strings outside Printf")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("a",Object(a.a)({parentName:"li"},{href:"#naming-printf-style-functions"}),"Naming Printf-style Functions")))),Object(r.b)("li",{parentName:"ul"},Object(r.b)("a",Object(a.a)({parentName:"li"},{href:"#patterns"}),"Patterns"),Object(r.b)("ul",{parentName:"li"},Object(r.b)("li",{parentName:"ul"},Object(r.b)("a",Object(a.a)({parentName:"li"},{href:"#test-tables"}),"Test Tables")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("a",Object(a.a)({parentName:"li"},{href:"#functional-options"}),"Functional Options"))))),Object(r.b)("h2",{id:"introduction"},"Introduction"),Object(r.b)("p",null,"Styles are the conventions that govern our code. The term style is a bit of a\nmisnomer, since these conventions cover far more than just source file\nformatting\u2014gofmt handles that for us."),Object(r.b)("p",null,"The goal of this guide is to manage this complexity by describing in detail the\nDos and Don'ts of writing Go code at Blackspace. These rules exist to keep the code\nbase manageable while still allowing engineers to use Go language features\nproductively."),Object(r.b)("p",null,"This guide was originally created by ",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"https://github.com/prashantv"}),"Prashant Varanasi")," and ",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"https://github.com/nomis52"}),"Simon Newton")," as\na way to bring some colleagues up to speed with using Go. Over the years it has\nbeen amended based on feedback from others."),Object(r.b)("p",null,"This documents idiomatic conventions in Go code that we follow at Blackspace. A lot\nof these are general guidelines for Go, while others extend upon external\nresources:"),Object(r.b)("ol",null,Object(r.b)("li",{parentName:"ol"},Object(r.b)("a",Object(a.a)({parentName:"li"},{href:"https://golang.org/doc/effective_go.html"}),"Effective Go")),Object(r.b)("li",{parentName:"ol"},Object(r.b)("a",Object(a.a)({parentName:"li"},{href:"https://github.com/golang/go/wiki/CodeReviewComments"}),"The Go common mistakes guide"))),Object(r.b)("p",null,"All code should be error-free when run through ",Object(r.b)("inlineCode",{parentName:"p"},"golint")," and ",Object(r.b)("inlineCode",{parentName:"p"},"go vet"),". We\nrecommend setting up your editor to:"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},"Run ",Object(r.b)("inlineCode",{parentName:"li"},"goimports")," on save"),Object(r.b)("li",{parentName:"ul"},"Run ",Object(r.b)("inlineCode",{parentName:"li"},"golint")," and ",Object(r.b)("inlineCode",{parentName:"li"},"go vet")," to check for errors")),Object(r.b)("p",null,"You can find information in editor support for Go tools here:\n",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"https://github.com/golang/go/wiki/IDEsAndTextEditorPlugins"}),"https://github.com/golang/go/wiki/IDEsAndTextEditorPlugins")),Object(r.b)("h2",{id:"guidelines"},"Guidelines"),Object(r.b)("h3",{id:"pointers-to-interfaces"},"Pointers to Interfaces"),Object(r.b)("p",null,"You almost never need a pointer to an interface. You should be passing\ninterfaces as values\u2014the underlying data can still be a pointer."),Object(r.b)("p",null,"An interface is two fields:"),Object(r.b)("ol",null,Object(r.b)("li",{parentName:"ol"},'A pointer to some type-specific information. You can think of this as\n"type."'),Object(r.b)("li",{parentName:"ol"},"Data pointer. If the data stored is a pointer, it\u2019s stored directly. If\nthe data stored is a value, then a pointer to the value is stored.")),Object(r.b)("p",null,"If you want interface methods to modify the underlying data, you must use a\npointer."),Object(r.b)("h3",{id:"verify-interface-compliance"},"Verify Interface Compliance"),Object(r.b)("p",null,"Verify interface compliance at compile time where appropriate. This includes:"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},"Exported types that are required to implement specific interfaces as part of\ntheir API contract"),Object(r.b)("li",{parentName:"ul"},"Exported or unexported types that are part of a collection of types\nimplementing the same interface"),Object(r.b)("li",{parentName:"ul"},"Other cases where violating an interface would break users")),Object(r.b)("table",null,Object(r.b)("thead",null,Object(r.b)("tr",null,Object(r.b)("th",null,"Bad"),Object(r.b)("th",null,"Good"))),Object(r.b)("tbody",null,Object(r.b)("tr",null,Object(r.b)("td",null,Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-go"}),"type Handler struct {\n  // ...\n}\n\n\n\nfunc (h *Handler) ServeHTTP(\n  w http.ResponseWriter,\n  r *http.Request,\n) {\n  ...\n}\n"))),Object(r.b)("td",null,Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-go"}),"type Handler struct {\n  // ...\n}\n\nvar _ http.Handler = (*Handler)(nil)\n\nfunc (h *Handler) ServeHTTP(\n  w http.ResponseWriter,\n  r *http.Request,\n) {\n  // ...\n}\n")))))),Object(r.b)("p",null,"The statement ",Object(r.b)("inlineCode",{parentName:"p"},"var _ http.Handler = (*Handler)(nil)")," will fail to compile if\n",Object(r.b)("inlineCode",{parentName:"p"},"*Handler")," ever stops matching the ",Object(r.b)("inlineCode",{parentName:"p"},"http.Handler")," interface."),Object(r.b)("p",null,"The right hand side of the assignment should be the zero value of the asserted\ntype. This is ",Object(r.b)("inlineCode",{parentName:"p"},"nil")," for pointer types (like ",Object(r.b)("inlineCode",{parentName:"p"},"*Handler"),"), slices, and maps, and\nan empty struct for struct types."),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-go"}),"type LogHandler struct {\n  h   http.Handler\n  log *zap.Logger\n}\n\nvar _ http.Handler = LogHandler{}\n\nfunc (h LogHandler) ServeHTTP(\n  w http.ResponseWriter,\n  r *http.Request,\n) {\n  // ...\n}\n")),Object(r.b)("h3",{id:"receivers-and-interfaces"},"Receivers and Interfaces"),Object(r.b)("p",null,"Methods with value receivers can be called on pointers as well as values.\nMethods with pointer receivers can only be called on pointers or ",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"https://golang.org/ref/spec#Method_values"}),"addressable values"),"."),Object(r.b)("p",null,"For example,"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-go"}),'type S struct {\n  data string\n}\n\nfunc (s S) Read() string {\n  return s.data\n}\n\nfunc (s *S) Write(str string) {\n  s.data = str\n}\n\nsVals := map[int]S{1: {"A"}}\n\n// You can only call Read using a value\nsVals[1].Read()\n\n// This will not compile:\n//  sVals[1].Write("test")\n\nsPtrs := map[int]*S{1: {"A"}}\n\n// You can call both Read and Write using a pointer\nsPtrs[1].Read()\nsPtrs[1].Write("test")\n')),Object(r.b)("p",null,"Similarly, an interface can be satisfied by a pointer, even if the method has a\nvalue receiver."),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-go"}),"type F interface {\n  f()\n}\n\ntype S1 struct{}\n\nfunc (s S1) f() {}\n\ntype S2 struct{}\n\nfunc (s *S2) f() {}\n\ns1Val := S1{}\ns1Ptr := &S1{}\ns2Val := S2{}\ns2Ptr := &S2{}\n\nvar i F\ni = s1Val\ni = s1Ptr\ni = s2Ptr\n\n// The following doesn't compile, since s2Val is a value, and there is no value receiver for f.\n//   i = s2Val\n")),Object(r.b)("p",null,"Effective Go has a good write up on ",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"https://golang.org/doc/effective_go.html#pointers_vs_values"}),"Pointers vs.\xa0Values"),"."),Object(r.b)("h3",{id:"zero-value-mutexes-are-valid"},"Zero-value Mutexes are Valid"),Object(r.b)("p",null,"The zero-value of ",Object(r.b)("inlineCode",{parentName:"p"},"sync.Mutex")," and ",Object(r.b)("inlineCode",{parentName:"p"},"sync.RWMutex")," is valid, so you almost\nnever need a pointer to a mutex."),Object(r.b)("table",null,Object(r.b)("thead",null,Object(r.b)("tr",null,Object(r.b)("th",null,"Bad"),Object(r.b)("th",null,"Good"))),Object(r.b)("tbody",null,Object(r.b)("tr",null,Object(r.b)("td",null,Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-go"}),"mu := new(sync.Mutex)\nmu.Lock()\n"))),Object(r.b)("td",null,Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-go"}),"var mu sync.Mutex\nmu.Lock()\n")))))),Object(r.b)("p",null,"If you use a struct by pointer, then the mutex can be a non-pointer field."),Object(r.b)("p",null,"Unexported structs that use a mutex to protect fields of the struct may embed\nthe mutex."),Object(r.b)("table",null,Object(r.b)("tbody",null,Object(r.b)("tr",null,Object(r.b)("td",null,Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-go"}),"type smap struct {\n  sync.Mutex // only for unexported types\n\n  data map[string]string\n}\n\nfunc newSMap() *smap {\n  return &smap{\n    data: make(map[string]string),\n  }\n}\n\nfunc (m *smap) Get(k string) string {\n  m.Lock()\n  defer m.Unlock()\n\n  return m.data[k]\n}\n"))),Object(r.b)("td",null,Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-go"}),"type SMap struct {\n  mu sync.Mutex\n\n  data map[string]string\n}\n\nfunc NewSMap() *SMap {\n  return &SMap{\n    data: make(map[string]string),\n  }\n}\n\nfunc (m *SMap) Get(k string) string {\n  m.mu.Lock()\n  defer m.mu.Unlock()\n\n  return m.data[k]\n}\n")))),Object(r.b)("tr",null,Object(r.b)("td",null,"Embed for private types or types that need to implement the Mutex interface."),Object(r.b)("td",null,"For exported types, use a private field.")))),Object(r.b)("h3",{id:"copy-slices-and-maps-at-boundaries"},"Copy Slices and Maps at Boundaries"),Object(r.b)("p",null,"Slices and maps contain pointers to the underlying data so be wary of scenarios\nwhen they need to be copied."),Object(r.b)("h4",{id:"receiving-slices-and-maps"},"Receiving Slices and Maps"),Object(r.b)("p",null,"Keep in mind that users can modify a map or slice you received as an argument\nif you store a reference to it."),Object(r.b)("table",null,Object(r.b)("thead",null,Object(r.b)("tr",null,Object(r.b)("th",null,"Bad")," ",Object(r.b)("th",null,"Good"))),Object(r.b)("tbody",null,Object(r.b)("tr",null,Object(r.b)("td",null,Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-go"}),"func (d *Driver) SetTrips(trips []Trip) {\n  d.trips = trips\n}\n\ntrips := ...\nd1.SetTrips(trips)\n\n// Did you mean to modify d1.trips?\ntrips[0] = ...\n"))),Object(r.b)("td",null,Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-go"}),"func (d *Driver) SetTrips(trips []Trip) {\n  d.trips = make([]Trip, len(trips))\n  copy(d.trips, trips)\n}\n\ntrips := ...\nd1.SetTrips(trips)\n\n// We can now modify trips[0] without affecting d1.trips.\ntrips[0] = ...\n")))))),Object(r.b)("h4",{id:"returning-slices-and-maps"},"Returning Slices and Maps"),Object(r.b)("p",null,"Similarly, be wary of user modifications to maps or slices exposing internal\nstate."),Object(r.b)("table",null,Object(r.b)("thead",null,Object(r.b)("tr",null,Object(r.b)("th",null,"Bad"),Object(r.b)("th",null,"Good"))),Object(r.b)("tbody",null,Object(r.b)("tr",null,Object(r.b)("td",null,Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-go"}),"type Stats struct {\n  mu sync.Mutex\n  counters map[string]int\n}\n\n// Snapshot returns the current stats.\nfunc (s *Stats) Snapshot() map[string]int {\n  s.mu.Lock()\n  defer s.mu.Unlock()\n\n  return s.counters\n}\n\n// snapshot is no longer protected by the mutex, so any\n// access to the snapshot is subject to data races.\nsnapshot := stats.Snapshot()\n"))),Object(r.b)("td",null,Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-go"}),"type Stats struct {\n  mu sync.Mutex\n  counters map[string]int\n}\n\nfunc (s *Stats) Snapshot() map[string]int {\n  s.mu.Lock()\n  defer s.mu.Unlock()\n\n  result := make(map[string]int, len(s.counters))\n  for k, v := range s.counters {\n    result[k] = v\n  }\n  return result\n}\n\n// Snapshot is now a copy.\nsnapshot := stats.Snapshot()\n")))))),Object(r.b)("h3",{id:"defer-to-clean-up"},"Defer to Clean Up"),Object(r.b)("p",null,"Use defer to clean up resources such as files and locks."),Object(r.b)("table",null,Object(r.b)("thead",null,Object(r.b)("tr",null,Object(r.b)("th",null,"Bad"),Object(r.b)("th",null,"Good"))),Object(r.b)("tbody",null,Object(r.b)("tr",null,Object(r.b)("td",null,Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-go"}),"p.Lock()\nif p.count < 10 {\n  p.Unlock()\n  return p.count\n}\n\np.count++\nnewCount := p.count\np.Unlock()\n\nreturn newCount\n\n// easy to miss unlocks due to multiple returns\n"))),Object(r.b)("td",null,Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-go"}),"p.Lock()\ndefer p.Unlock()\n\nif p.count < 10 {\n  return p.count\n}\n\np.count++\nreturn p.count\n\n// more readable\n")))))),Object(r.b)("p",null,"Defer has an extremely small overhead and should be avoided only if you can\nprove that your function execution time is in the order of nanoseconds. The\nreadability win of using defers is worth the miniscule cost of using them. This\nis especially true for larger methods that have more than simple memory\naccesses, where the other computations are more significant than the ",Object(r.b)("inlineCode",{parentName:"p"},"defer"),"."),Object(r.b)("h3",{id:"channel-size-is-one-or-none"},"Channel Size is One or None"),Object(r.b)("p",null,"Channels should usually have a size of one or be unbuffered. By default,\nchannels are unbuffered and have a size of zero. Any other size\nmust be subject to a high level of scrutiny. Consider how the size is\ndetermined, what prevents the channel from filling up under load and blocking\nwriters, and what happens when this occurs."),Object(r.b)("table",null,Object(r.b)("thead",null,Object(r.b)("tr",null,Object(r.b)("th",null,"Bad"),Object(r.b)("th",null,"Good"))),Object(r.b)("tbody",null,Object(r.b)("tr",null,Object(r.b)("td",null,Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-go"}),"// Ought to be enough for anybody!\nc := make(chan int, 64)\n"))),Object(r.b)("td",null,Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-go"}),"// Size of one\nc := make(chan int, 1) // or\n// Unbuffered channel, size of zero\nc := make(chan int)\n")))))),Object(r.b)("h3",{id:"start-enums-at-one"},"Start Enums at One"),Object(r.b)("p",null,"The standard way of introducing enumerations in Go is to declare a custom type\nand a ",Object(r.b)("inlineCode",{parentName:"p"},"const")," group with ",Object(r.b)("inlineCode",{parentName:"p"},"iota"),". Since variables have a 0 default value, you\nshould usually start your enums on a non-zero value."),Object(r.b)("table",null,Object(r.b)("thead",null,Object(r.b)("tr",null,Object(r.b)("th",null,"Bad"),Object(r.b)("th",null,"Good"))),Object(r.b)("tbody",null,Object(r.b)("tr",null,Object(r.b)("td",null,Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-go"}),"type Operation int\n\nconst (\n  Add Operation = iota\n  Subtract\n  Multiply\n)\n\n// Add=0, Subtract=1, Multiply=2\n"))),Object(r.b)("td",null,Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-go"}),"type Operation int\n\nconst (\n  Add Operation = iota + 1\n  Subtract\n  Multiply\n)\n\n// Add=1, Subtract=2, Multiply=3\n")))))),Object(r.b)("p",null,"There are cases where using the zero value makes sense, for example when the\nzero value case is the desirable default behavior."),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-go"}),"type LogOutput int\n\nconst (\n  LogToStdout LogOutput = iota\n  LogToFile\n  LogToRemote\n)\n\n// LogToStdout=0, LogToFile=1, LogToRemote=2\n")),Object(r.b)("h3",{id:"use-time-to-handle-time"},"Use ",Object(r.b)("inlineCode",{parentName:"h3"},'"time"')," to handle time"),Object(r.b)("p",null,"Time is complicated. Incorrect assumptions often made about time include the\nfollowing."),Object(r.b)("ol",null,Object(r.b)("li",{parentName:"ol"},"A day has 24 hours"),Object(r.b)("li",{parentName:"ol"},"An hour has 60 minutes"),Object(r.b)("li",{parentName:"ol"},"A week has 7 days"),Object(r.b)("li",{parentName:"ol"},"A year has 365 days"),Object(r.b)("li",{parentName:"ol"},Object(r.b)("a",Object(a.a)({parentName:"li"},{href:"https://infiniteundo.com/post/25326999628/falsehoods-programmers-believe-about-time"}),"And a lot more"))),Object(r.b)("p",null,"For example, ",Object(r.b)("em",{parentName:"p"},"1")," means that adding 24 hours to a time instant will not always\nyield a new calendar day."),Object(r.b)("p",null,"Therefore, always use the ",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"https://golang.org/pkg/time/"}),Object(r.b)("inlineCode",{parentName:"a"},'"time"'))," package when dealing with time because it\nhelps deal with these incorrect assumptions in a safer, more accurate manner."),Object(r.b)("h4",{id:"use-timetime-for-instants-of-time"},"Use ",Object(r.b)("inlineCode",{parentName:"h4"},"time.Time")," for instants of time"),Object(r.b)("p",null,"Use ",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"https://golang.org/pkg/time/#Time"}),Object(r.b)("inlineCode",{parentName:"a"},"time.Time"))," when dealing with instants of time, and the methods on\n",Object(r.b)("inlineCode",{parentName:"p"},"time.Time")," when comparing, adding, or subtracting time."),Object(r.b)("table",null,Object(r.b)("thead",null,Object(r.b)("tr",null,Object(r.b)("th",null,"Bad"),Object(r.b)("th",null,"Good"))),Object(r.b)("tbody",null,Object(r.b)("tr",null,Object(r.b)("td",null,Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-go"}),"func isActive(now, start, stop int) bool {\n  return start <= now && now < stop\n}\n"))),Object(r.b)("td",null,Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-go"}),"func isActive(now, start, stop time.Time) bool {\n  return (start.Before(now) || start.Equal(now)) && now.Before(stop)\n}\n")))))),Object(r.b)("h4",{id:"use-timeduration-for-periods-of-time"},"Use ",Object(r.b)("inlineCode",{parentName:"h4"},"time.Duration")," for periods of time"),Object(r.b)("p",null,"Use ",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"https://golang.org/pkg/time/#Duration"}),Object(r.b)("inlineCode",{parentName:"a"},"time.Duration"))," when dealing with periods of time."),Object(r.b)("table",null,Object(r.b)("thead",null,Object(r.b)("tr",null,Object(r.b)("th",null,"Bad"),Object(r.b)("th",null,"Good"))),Object(r.b)("tbody",null,Object(r.b)("tr",null,Object(r.b)("td",null,Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-go"}),"func poll(delay int) {\n  for {\n    // ...\n    time.Sleep(time.Duration(delay) * time.Millisecond)\n  }\n}\n\npoll(10) // was it seconds or milliseconds?\n"))),Object(r.b)("td",null,Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-go"}),"func poll(delay time.Duration) {\n  for {\n    // ...\n    time.Sleep(delay)\n  }\n}\n\npoll(10*time.Second)\n")))))),Object(r.b)("p",null,"Going back to the example of adding 24 hours to a time instant, the method we\nuse to add time depends on intent. If we want the same time of the day, but on\nthe next calendar day, we should use ",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"https://golang.org/pkg/time/#Time.AddDate"}),Object(r.b)("inlineCode",{parentName:"a"},"Time.AddDate")),". However, if we want an\ninstant of time guaranteed to be 24 hours after the previous time, we should\nuse ",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"https://golang.org/pkg/time/#Time.Add"}),Object(r.b)("inlineCode",{parentName:"a"},"Time.Add")),"."),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-go"}),"newDay := t.AddDate(0 /* years */, 0, /* months */, 1 /* days */)\nmaybeNewDay := t.Add(24 * time.Hour)\n")),Object(r.b)("h4",{id:"use-timetime-and-timeduration-with-external-systems"},"Use ",Object(r.b)("inlineCode",{parentName:"h4"},"time.Time")," and ",Object(r.b)("inlineCode",{parentName:"h4"},"time.Duration")," with external systems"),Object(r.b)("p",null,"Use ",Object(r.b)("inlineCode",{parentName:"p"},"time.Duration")," and ",Object(r.b)("inlineCode",{parentName:"p"},"time.Time")," in interactions with external systems when\npossible. For example:"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},"Command-line flags: ",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"https://golang.org/pkg/flag/"}),Object(r.b)("inlineCode",{parentName:"a"},"flag"))," supports ",Object(r.b)("inlineCode",{parentName:"p"},"time.Duration")," via\n",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"https://golang.org/pkg/time/#ParseDuration"}),Object(r.b)("inlineCode",{parentName:"a"},"time.ParseDuration")))),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},"JSON: ",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"https://golang.org/pkg/encoding/json/"}),Object(r.b)("inlineCode",{parentName:"a"},"encoding/json"))," supports encoding ",Object(r.b)("inlineCode",{parentName:"p"},"time.Time")," as an ",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"https://tools.ietf.org/html/rfc3339"}),"RFC 3339"),"\nstring via its ",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"https://golang.org/pkg/time/#Time.UnmarshalJSON"}),Object(r.b)("inlineCode",{parentName:"a"},"UnmarshalJSON")," method"))),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},"SQL: ",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"https://golang.org/pkg/database/sql/"}),Object(r.b)("inlineCode",{parentName:"a"},"database/sql"))," supports converting ",Object(r.b)("inlineCode",{parentName:"p"},"DATETIME")," or ",Object(r.b)("inlineCode",{parentName:"p"},"TIMESTAMP")," columns\ninto ",Object(r.b)("inlineCode",{parentName:"p"},"time.Time")," and back if the underlying driver supports it")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},"YAML: ",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"https://godoc.org/gopkg.in/yaml.v2"}),Object(r.b)("inlineCode",{parentName:"a"},"gopkg.in/yaml.v2"))," supports ",Object(r.b)("inlineCode",{parentName:"p"},"time.Time")," as an ",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"https://tools.ietf.org/html/rfc3339"}),"RFC 3339")," string, and\n",Object(r.b)("inlineCode",{parentName:"p"},"time.Duration")," via ",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"https://golang.org/pkg/time/#ParseDuration"}),Object(r.b)("inlineCode",{parentName:"a"},"time.ParseDuration")),"."))),Object(r.b)("p",null,"When it is not possible to use ",Object(r.b)("inlineCode",{parentName:"p"},"time.Duration")," in these interactions, use\n",Object(r.b)("inlineCode",{parentName:"p"},"int")," or ",Object(r.b)("inlineCode",{parentName:"p"},"float64")," and include the unit in the name of the field."),Object(r.b)("p",null,"For example, since ",Object(r.b)("inlineCode",{parentName:"p"},"encoding/json")," does not support ",Object(r.b)("inlineCode",{parentName:"p"},"time.Duration"),", the unit\nis included in the name of the field."),Object(r.b)("table",null,Object(r.b)("thead",null,Object(r.b)("tr",null,Object(r.b)("th",null,"Bad"),Object(r.b)("th",null,"Good"))),Object(r.b)("tbody",null,Object(r.b)("tr",null,Object(r.b)("td",null,Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-go"}),'// {"interval": 2}\ntype Config struct {\n  Interval int `json:"interval"`\n}\n'))),Object(r.b)("td",null,Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-go"}),'// {"intervalMillis": 2000}\ntype Config struct {\n  IntervalMillis int `json:"intervalMillis"`\n}\n')))))),Object(r.b)("p",null,"When it is not possible to use ",Object(r.b)("inlineCode",{parentName:"p"},"time.Time")," in these interactions, unless an\nalternative is agreed upon, use ",Object(r.b)("inlineCode",{parentName:"p"},"string")," and format timestamps as defined in\n",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"https://tools.ietf.org/html/rfc3339"}),"RFC 3339"),". This format is used by default by ",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"https://golang.org/pkg/time/#Time.UnmarshalText"}),Object(r.b)("inlineCode",{parentName:"a"},"Time.UnmarshalText"))," and is\navailable for use in ",Object(r.b)("inlineCode",{parentName:"p"},"Time.Format")," and ",Object(r.b)("inlineCode",{parentName:"p"},"time.Parse")," via ",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"https://golang.org/pkg/time/#RFC3339"}),Object(r.b)("inlineCode",{parentName:"a"},"time.RFC3339")),"."),Object(r.b)("p",null,"Although this tends to not be a problem in practice, keep in mind that the\n",Object(r.b)("inlineCode",{parentName:"p"},'"time"')," package does not support parsing timestamps with leap seconds\n(",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"https://github.com/golang/go/issues/8728"}),"8728"),"), nor does it account for leap seconds in calculations (",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"https://github.com/golang/go/issues/15190"}),"15190"),"). If\nyou compare two instants of time, the difference will not include the leap\nseconds that may have occurred between those two instants."),Object(r.b)("h3",{id:"error-types"},"Error Types"),Object(r.b)("p",null,"There are various options for declaring errors:"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("a",Object(a.a)({parentName:"li"},{href:"https://golang.org/pkg/errors/#New"}),Object(r.b)("inlineCode",{parentName:"a"},"errors.New"))," for errors with simple static strings"),Object(r.b)("li",{parentName:"ul"},Object(r.b)("a",Object(a.a)({parentName:"li"},{href:"https://golang.org/pkg/fmt/#Errorf"}),Object(r.b)("inlineCode",{parentName:"a"},"fmt.Errorf"))," for formatted error strings"),Object(r.b)("li",{parentName:"ul"},"Custom types that implement an ",Object(r.b)("inlineCode",{parentName:"li"},"Error()")," method"),Object(r.b)("li",{parentName:"ul"},"Wrapped errors using ",Object(r.b)("a",Object(a.a)({parentName:"li"},{href:"https://godoc.org/github.com/pkg/errors#Wrap"}),Object(r.b)("inlineCode",{parentName:"a"},'"pkg/errors".Wrap')))),Object(r.b)("p",null,"When returning errors, consider the following to determine the best choice:"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},"Is this a simple error that needs no extra information? If so, ",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"https://golang.org/pkg/errors/#New"}),Object(r.b)("inlineCode",{parentName:"a"},"errors.New")),"\nshould suffice.")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},"Do the clients need to detect and handle this error? If so, you should use a\ncustom type, and implement the ",Object(r.b)("inlineCode",{parentName:"p"},"Error()")," method.")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},"Are you propagating an error returned by a downstream function? If so, check\nthe ",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"#error-wrapping"}),"section on error wrapping"),".")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},"Otherwise, ",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"https://golang.org/pkg/fmt/#Errorf"}),Object(r.b)("inlineCode",{parentName:"a"},"fmt.Errorf"))," is okay."))),Object(r.b)("p",null,"If the client needs to detect the error, and you have created a simple error\nusing ",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"https://golang.org/pkg/errors/#New"}),Object(r.b)("inlineCode",{parentName:"a"},"errors.New")),", use a var for the error."),Object(r.b)("table",null,Object(r.b)("thead",null,Object(r.b)("tr",null,Object(r.b)("th",null,"Bad"),Object(r.b)("th",null,"Good"))),Object(r.b)("tbody",null,Object(r.b)("tr",null,Object(r.b)("td",null,Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-go"}),'// package foo\n\nfunc Open() error {\n  return errors.New("could not open")\n}\n\n// package bar\n\nfunc use() {\n  if err := foo.Open(); err != nil {\n    if err.Error() == "could not open" {\n      // handle\n    } else {\n      panic("unknown error")\n    }\n  }\n}\n'))),Object(r.b)("td",null,Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-go"}),'// package foo\n\nvar ErrCouldNotOpen = errors.New("could not open")\n\nfunc Open() error {\n  return ErrCouldNotOpen\n}\n\n// package bar\n\nif err := foo.Open(); err != nil {\n  if err == foo.ErrCouldNotOpen {\n    // handle\n  } else {\n    panic("unknown error")\n  }\n}\n')))))),Object(r.b)("p",null,"If you have an error that clients may need to detect, and you would like to add\nmore information to it (e.g., it is not a static string), then you should use a\ncustom type."),Object(r.b)("table",null,Object(r.b)("thead",null,Object(r.b)("tr",null,Object(r.b)("th",null,"Bad"),Object(r.b)("th",null,"Good"))),Object(r.b)("tbody",null,Object(r.b)("tr",null,Object(r.b)("td",null,Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-go"}),'func open(file string) error {\n  return fmt.Errorf("file %q not found", file)\n}\n\nfunc use() {\n  if err := open("testfile.txt"); err != nil {\n    if strings.Contains(err.Error(), "not found") {\n      // handle\n    } else {\n      panic("unknown error")\n    }\n  }\n}\n'))),Object(r.b)("td",null,Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-go"}),'type errNotFound struct {\n  file string\n}\n\nfunc (e errNotFound) Error() string {\n  return fmt.Sprintf("file %q not found", e.file)\n}\n\nfunc open(file string) error {\n  return errNotFound{file: file}\n}\n\nfunc use() {\n  if err := open("testfile.txt"); err != nil {\n    if _, ok := err.(errNotFound); ok {\n      // handle\n    } else {\n      panic("unknown error")\n    }\n  }\n}\n')))))),Object(r.b)("p",null,"Be careful with exporting custom error types directly since they become part of\nthe public API of the package. It is preferable to expose matcher functions to\ncheck the error instead."),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-go"}),'// package foo\n\ntype errNotFound struct {\n  file string\n}\n\nfunc (e errNotFound) Error() string {\n  return fmt.Sprintf("file %q not found", e.file)\n}\n\nfunc IsNotFoundError(err error) bool {\n  _, ok := err.(errNotFound)\n  return ok\n}\n\nfunc Open(file string) error {\n  return errNotFound{file: file}\n}\n\n// package bar\n\nif err := foo.Open("foo"); err != nil {\n  if foo.IsNotFoundError(err) {\n    // handle\n  } else {\n    panic("unknown error")\n  }\n}\n')),Object(r.b)("h3",{id:"error-wrapping"},"Error Wrapping"),Object(r.b)("p",null,"There are three main options for propagating errors if a call fails:"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},"Return the original error if there is no additional context to add and you\nwant to maintain the original error type."),Object(r.b)("li",{parentName:"ul"},"Add context using ",Object(r.b)("a",Object(a.a)({parentName:"li"},{href:"https://godoc.org/github.com/pkg/errors#Wrap"}),Object(r.b)("inlineCode",{parentName:"a"},'"pkg/errors".Wrap'))," so that the error message provides\nmore context and ",Object(r.b)("a",Object(a.a)({parentName:"li"},{href:"https://godoc.org/github.com/pkg/errors#Cause"}),Object(r.b)("inlineCode",{parentName:"a"},'"pkg/errors".Cause'))," can be used to extract the original\nerror."),Object(r.b)("li",{parentName:"ul"},"Use ",Object(r.b)("a",Object(a.a)({parentName:"li"},{href:"https://golang.org/pkg/fmt/#Errorf"}),Object(r.b)("inlineCode",{parentName:"a"},"fmt.Errorf"))," if the callers do not need to detect or handle that\nspecific error case.")),Object(r.b)("p",null,'It is recommended to add context where possible so that instead of a vague\nerror such as "connection refused", you get more useful errors such as\n"call service foo: connection refused".'),Object(r.b)("p",null,'When adding context to returned errors, keep the context succinct by avoiding\nphrases like "failed to", which state the obvious and pile up as the error\npercolates up through the stack:'),Object(r.b)("table",null,Object(r.b)("thead",null,Object(r.b)("tr",null,Object(r.b)("th",null,"Bad"),Object(r.b)("th",null,"Good"))),Object(r.b)("tbody",null,Object(r.b)("tr",null,Object(r.b)("td",null,Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-go"}),'s, err := store.New()\nif err != nil {\n    return fmt.Errorf(\n        "failed to create new store: %s", err)\n}\n'))),Object(r.b)("td",null,Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-go"}),'s, err := store.New()\nif err != nil {\n    return fmt.Errorf(\n        "new store: %s", err)\n}\n')))),Object(r.b)("tr",null,Object(r.b)("td",null,Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{}),"failed to x: failed to y: failed to create new store: the error\n"))),Object(r.b)("td",null,Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{}),"x: y: new store: the error\n")))))),Object(r.b)("p",null,"However once the error is sent to another system, it should be clear the\nmessage is an error (e.g. an ",Object(r.b)("inlineCode",{parentName:"p"},"err"),' tag or "Failed" prefix in logs).'),Object(r.b)("p",null,"See also ",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"https://dave.cheney.net/2016/04/27/dont-just-check-errors-handle-them-gracefully"}),"Don't just check errors, handle them gracefully"),"."),Object(r.b)("h3",{id:"handle-type-assertion-failures"},"Handle Type Assertion Failures"),Object(r.b)("p",null,"The single return value form of a ",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"https://golang.org/ref/spec#Type_assertions"}),"type assertion"),' will panic on an incorrect\ntype. Therefore, always use the "comma ok" idiom.'),Object(r.b)("table",null,Object(r.b)("thead",null,Object(r.b)("tr",null,Object(r.b)("th",null,"Bad"),Object(r.b)("th",null,"Good"))),Object(r.b)("tbody",null,Object(r.b)("tr",null,Object(r.b)("td",null,Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-go"}),"t := i.(string)\n"))),Object(r.b)("td",null,Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-go"}),"t, ok := i.(string)\nif !ok {\n  // handle the error gracefully\n}\n")))))),Object(r.b)("h3",{id:"dont-panic"},"Don't Panic"),Object(r.b)("p",null,"Code running in production must avoid panics. Panics are a major source of\n",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"https://en.wikipedia.org/wiki/Cascading_failure"}),"cascading failures"),". If an error occurs, the function must return an error and\nallow the caller to decide how to handle it."),Object(r.b)("table",null,Object(r.b)("thead",null,Object(r.b)("tr",null,Object(r.b)("th",null,"Bad"),Object(r.b)("th",null,"Good"))),Object(r.b)("tbody",null,Object(r.b)("tr",null,Object(r.b)("td",null,Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-go"}),'func foo(bar string) {\n  if len(bar) == 0 {\n    panic("bar must not be empty")\n  }\n  // ...\n}\n\nfunc main() {\n  if len(os.Args) != 2 {\n    fmt.Println("USAGE: foo <bar>")\n    os.Exit(1)\n  }\n  foo(os.Args[1])\n}\n'))),Object(r.b)("td",null,Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-go"}),'func foo(bar string) error {\n  if len(bar) == 0 {\n    return errors.New("bar must not be empty")\n  }\n  // ...\n  return nil\n}\n\nfunc main() {\n  if len(os.Args) != 2 {\n    fmt.Println("USAGE: foo <bar>")\n    os.Exit(1)\n  }\n  if err := foo(os.Args[1]); err != nil {\n    panic(err)\n  }\n}\n')))))),Object(r.b)("p",null,"Panic/recover is not an error handling strategy. A program must panic only when\nsomething irrecoverable happens such as a nil dereference. An exception to this is\nprogram initialization: bad things at program startup that should abort the\nprogram may cause panic."),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-go"}),'var _statusTemplate = template.Must(template.New("name").Parse("_statusHTML"))\n')),Object(r.b)("p",null,"Even in tests, prefer ",Object(r.b)("inlineCode",{parentName:"p"},"t.Fatal")," or ",Object(r.b)("inlineCode",{parentName:"p"},"t.FailNow")," over panics to ensure that the\ntest is marked as failed."),Object(r.b)("table",null,Object(r.b)("thead",null,Object(r.b)("tr",null,Object(r.b)("th",null,"Bad"),Object(r.b)("th",null,"Good"))),Object(r.b)("tbody",null,Object(r.b)("tr",null,Object(r.b)("td",null,Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-go"}),'// func TestFoo(t *testing.T)\n\nf, err := ioutil.TempFile("", "test")\nif err != nil {\n  panic("failed to set up test")\n}\n'))),Object(r.b)("td",null,Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-go"}),'// func TestFoo(t *testing.T)\n\nf, err := ioutil.TempFile("", "test")\nif err != nil {\n  t.Fatal("failed to set up test")\n}\n')))))),Object(r.b)("h3",{id:"use-gouberorgatomic"},"Use go.uber.org/atomic"),Object(r.b)("p",null,"Atomic operations with the ",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"https://golang.org/pkg/sync/atomic/"}),"sync/atomic")," package operate on the raw types\n(",Object(r.b)("inlineCode",{parentName:"p"},"int32"),", ",Object(r.b)("inlineCode",{parentName:"p"},"int64"),", etc.) so it is easy to forget to use the atomic operation to\nread or modify the variables."),Object(r.b)("p",null,Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"https://godoc.org/go.uber.org/atomic"}),"go.uber.org/atomic")," adds type safety to these operations by hiding the\nunderlying type. Additionally, it includes a convenient ",Object(r.b)("inlineCode",{parentName:"p"},"atomic.Bool")," type."),Object(r.b)("table",null,Object(r.b)("thead",null,Object(r.b)("tr",null,Object(r.b)("th",null,"Bad"),Object(r.b)("th",null,"Good"))),Object(r.b)("tbody",null,Object(r.b)("tr",null,Object(r.b)("td",null,Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-go"}),"type foo struct {\n  running int32  // atomic\n}\n\nfunc (f* foo) start() {\n  if atomic.SwapInt32(&f.running, 1) == 1 {\n     // already running\u2026\n     return\n  }\n  // start the Foo\n}\n\nfunc (f *foo) isRunning() bool {\n  return f.running == 1  // race!\n}\n"))),Object(r.b)("td",null,Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-go"}),"type foo struct {\n  running atomic.Bool\n}\n\nfunc (f *foo) start() {\n  if f.running.Swap(true) {\n     // already running\u2026\n     return\n  }\n  // start the Foo\n}\n\nfunc (f *foo) isRunning() bool {\n  return f.running.Load()\n}\n")))))),Object(r.b)("h3",{id:"avoid-mutable-globals"},"Avoid Mutable Globals"),Object(r.b)("p",null,"Avoid mutating global variables, instead opting for dependency injection.\nThis applies to function pointers as well as other kinds of values."),Object(r.b)("table",null,Object(r.b)("thead",null,Object(r.b)("tr",null,Object(r.b)("th",null,"Bad"),Object(r.b)("th",null,"Good"))),Object(r.b)("tbody",null,Object(r.b)("tr",null,Object(r.b)("td",null,Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-go"}),"// sign.go\n\nvar _timeNow = time.Now\n\nfunc sign(msg string) string {\n  now := _timeNow()\n  return signWithTime(msg, now)\n}\n"))),Object(r.b)("td",null,Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-go"}),"// sign.go\n\ntype signer struct {\n  now func() time.Time\n}\n\nfunc newSigner() *signer {\n  return &signer{\n    now: time.Now,\n  }\n}\n\nfunc (s *signer) Sign(msg string) string {\n  now := s.now()\n  return signWithTime(msg, now)\n}\n")))),Object(r.b)("tr",null,Object(r.b)("td",null,Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-go"}),"// sign_test.go\n\nfunc TestSign(t *testing.T) {\n  oldTimeNow := _timeNow\n  _timeNow = func() time.Time {\n    return someFixedTime\n  }\n  defer func() { _timeNow = oldTimeNow }()\n\n  assert.Equal(t, want, sign(give))\n}\n"))),Object(r.b)("td",null,Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-go"}),"// sign_test.go\n\nfunc TestSigner(t *testing.T) {\n  s := newSigner()\n  s.now = func() time.Time {\n    return someFixedTime\n  }\n\n  assert.Equal(t, want, s.Sign(give))\n}\n")))))),Object(r.b)("h3",{id:"avoid-embedding-types-in-public-structs"},"Avoid Embedding Types in Public Structs"),Object(r.b)("p",null,"These embedded types leak implementation details, inhibit type evolution, and\nobscure documentation."),Object(r.b)("p",null,"Assuming you have implemented a variety of list types using a shared\n",Object(r.b)("inlineCode",{parentName:"p"},"AbstractList"),", avoid embedding the ",Object(r.b)("inlineCode",{parentName:"p"},"AbstractList")," in your concrete list\nimplementations.\nInstead, hand-write only the methods to your concrete list that will delegate\nto the abstract list."),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-go"}),"type AbstractList struct {}\n\n// Add adds an entity to the list.\nfunc (l *AbstractList) Add(e Entity) {\n  // ...\n}\n\n// Remove removes an entity from the list.\nfunc (l *AbstractList) Remove(e Entity) {\n  // ...\n}\n")),Object(r.b)("table",null,Object(r.b)("thead",null,Object(r.b)("tr",null,Object(r.b)("th",null,"Bad"),Object(r.b)("th",null,"Good"))),Object(r.b)("tbody",null,Object(r.b)("tr",null,Object(r.b)("td",null,Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-go"}),"// ConcreteList is a list of entities.\ntype ConcreteList struct {\n  *AbstractList\n}\n"))),Object(r.b)("td",null,Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-go"}),"// ConcreteList is a list of entities.\ntype ConcreteList struct {\n  list *AbstractList\n}\n\n// Add adds an entity to the list.\nfunc (l *ConcreteList) Add(e Entity) {\n  return l.list.Add(e)\n}\n\n// Remove removes an entity from the list.\nfunc (l *ConcreteList) Remove(e Entity) {\n  return l.list.Remove(e)\n}\n")))))),Object(r.b)("p",null,"Go allows ",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"https://golang.org/doc/effective_go.html#embedding"}),"type embedding")," as a compromise between inheritance and composition.\nThe outer type gets implicit copies of the embedded type's methods.\nThese methods, by default, delegate to the same method of the embedded\ninstance."),Object(r.b)("p",null,"The struct also gains a field by the same name as the type.\nSo, if the embedded type is public, the field is public.\nTo maintain backward compatibility, every future version of the outer type must\nkeep the embedded type."),Object(r.b)("p",null,"An embedded type is rarely necessary.\nIt is a convenience that helps you avoid writing tedious delegate methods."),Object(r.b)("p",null,"Even embedding a compatible AbstractList ",Object(r.b)("em",{parentName:"p"},"interface"),", instead of the struct,\nwould offer the developer more flexibility to change in the future, but still\nleak the detail that the concrete lists use an abstract implementation."),Object(r.b)("table",null,Object(r.b)("thead",null,Object(r.b)("tr",null,Object(r.b)("th",null,"Bad"),Object(r.b)("th",null,"Good"))),Object(r.b)("tbody",null,Object(r.b)("tr",null,Object(r.b)("td",null,Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-go"}),"// AbstractList is a generalized implementation\n// for various kinds of lists of entities.\ntype AbstractList interface {\n  Add(Entity)\n  Remove(Entity)\n}\n\n// ConcreteList is a list of entities.\ntype ConcreteList struct {\n  AbstractList\n}\n"))),Object(r.b)("td",null,Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-go"}),"// ConcreteList is a list of entities.\ntype ConcreteList struct {\n  list *AbstractList\n}\n\n// Add adds an entity to the list.\nfunc (l *ConcreteList) Add(e Entity) {\n  return l.list.Add(e)\n}\n\n// Remove removes an entity from the list.\nfunc (l *ConcreteList) Remove(e Entity) {\n  return l.list.Remove(e)\n}\n")))))),Object(r.b)("p",null,"Either with an embedded struct or an embedded interface, the embedded type\nplaces limits on the evolution of the type."),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},"Adding methods to an embedded interface is a breaking change."),Object(r.b)("li",{parentName:"ul"},"Removing methods from an embedded struct is a breaking change."),Object(r.b)("li",{parentName:"ul"},"Removing the embedded type is a breaking change."),Object(r.b)("li",{parentName:"ul"},"Replacing the embedded type, even with an alternative that satisfies the same\ninterface, is a breaking change.")),Object(r.b)("p",null,"Although writing these delegate methods is tedious, the additional effort hides\nan implementation detail, leaves more opportunities for change, and also\neliminates indirection for discovering the full List interface in\ndocumentation."),Object(r.b)("h3",{id:"avoid-using-built-in-names"},"Avoid Using Built-In Names"),Object(r.b)("p",null,"The Go ",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"https://golang.org/ref/spec"}),"language specification")," outlines several built-in,\n",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"https://golang.org/ref/spec#Predeclared_identifiers"}),"predeclared identifiers")," that should not be used as names within Go programs."),Object(r.b)("p",null,"Depending on context, reusing these identifiers as names will either shadow\nthe original within the current lexical scope (and any nested scopes) or make\naffected code confusing. In the best case, the compiler will complain; in the\nworst case, such code may introduce latent, hard-to-grep bugs."),Object(r.b)("table",null,Object(r.b)("thead",null,Object(r.b)("tr",null,Object(r.b)("th",null,"Bad"),Object(r.b)("th",null,"Good"))),Object(r.b)("tbody",null,Object(r.b)("tr",null,Object(r.b)("td",null,Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-go"}),"var error string\n// `error` shadows the builtin\n\n// or\n\nfunc handleErrorMessage(error string) {\n    // `error` shadows the builtin\n}\n"))),Object(r.b)("td",null,Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-go"}),"var errorMessage string\n// `error` refers to the builtin\n\n// or\n\nfunc handleErrorMessage(msg string) {\n    // `error` refers to the builtin\n}\n")))),Object(r.b)("tr",null,Object(r.b)("td",null,Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-go"}),"type Foo struct {\n    // While these fields technically don't\n    // constitute shadowing, grepping for\n    // `error` or `string` strings is now\n    // ambiguous.\n    error  error\n    string string\n}\n\nfunc (f Foo) Error() error {\n    // `error` and `f.error` are\n    // visually similar\n    return f.error\n}\n\nfunc (f Foo) String() string {\n    // `string` and `f.string` are\n    // visually similar\n    return f.string\n}\n"))),Object(r.b)("td",null,Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-go"}),"type Foo struct {\n    // `error` and `string` strings are\n    // now unambiguous.\n    err error\n    str string\n}\n\nfunc (f Foo) Error() error {\n    return f.err\n}\n\nfunc (f Foo) String() string {\n    return f.str\n}\n")))))),Object(r.b)("p",null,"Note that the compiler will not generate errors when using predeclared\nidentifiers, but tools such as ",Object(r.b)("inlineCode",{parentName:"p"},"go vet")," should correctly point out these and\nother cases of shadowing."),Object(r.b)("h3",{id:"avoid-init"},"Avoid ",Object(r.b)("inlineCode",{parentName:"h3"},"init()")),Object(r.b)("p",null,"Avoid ",Object(r.b)("inlineCode",{parentName:"p"},"init()")," where possible. When ",Object(r.b)("inlineCode",{parentName:"p"},"init()")," is unavoidable or desirable, code\nshould attempt to:"),Object(r.b)("ol",null,Object(r.b)("li",{parentName:"ol"},"Be completely deterministic, regardless of program environment or invocation."),Object(r.b)("li",{parentName:"ol"},"Avoid depending on the ordering or side-effects of other ",Object(r.b)("inlineCode",{parentName:"li"},"init()")," functions.\nWhile ",Object(r.b)("inlineCode",{parentName:"li"},"init()")," ordering is well-known, code can change, and thus\nrelationships between ",Object(r.b)("inlineCode",{parentName:"li"},"init()")," functions can make code brittle and\nerror-prone."),Object(r.b)("li",{parentName:"ol"},"Avoid accessing or manipulating global or environment state, such as machine\ninformation, environment variables, working directory, program\narguments/inputs, etc."),Object(r.b)("li",{parentName:"ol"},"Avoid I/O, including both filesystem, network, and system calls.")),Object(r.b)("p",null,"Code that cannot satisfy these requirements likely belongs as a helper to be\ncalled as part of ",Object(r.b)("inlineCode",{parentName:"p"},"main()")," (or elsewhere in a program's lifecycle), or be\nwritten as part of ",Object(r.b)("inlineCode",{parentName:"p"},"main()"),' itself. In particular, libraries that are intended\nto be used by other programs should take special care to be completely\ndeterministic and not perform "init magic".'),Object(r.b)("table",null,Object(r.b)("thead",null,Object(r.b)("tr",null,Object(r.b)("th",null,"Bad"),Object(r.b)("th",null,"Good"))),Object(r.b)("tbody",null,Object(r.b)("tr",null,Object(r.b)("td",null,Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-go"}),"type Foo struct {\n    // ...\n}\n\nvar _defaultFoo Foo\n\nfunc init() {\n    _defaultFoo = Foo{\n        // ...\n    }\n}\n"))),Object(r.b)("td",null,Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-go"}),"var _defaultFoo = Foo{\n    // ...\n}\n\n// or, better, for testability:\n\nvar _defaultFoo = defaultFoo()\n\nfunc defaultFoo() Foo {\n    return Foo{\n        // ...\n    }\n}\n")))),Object(r.b)("tr",null,Object(r.b)("td",null,Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-go"}),'type Config struct {\n    // ...\n}\n\nvar _config Config\n\nfunc init() {\n    // Bad: based on current directory\n    cwd, _ := os.Getwd()\n\n    // Bad: I/O\n    raw, _ := ioutil.ReadFile(\n        path.Join(cwd, "config", "config.yaml"),\n    )\n\n    yaml.Unmarshal(raw, &_config)\n}\n'))),Object(r.b)("td",null,Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-go"}),'type Config struct {\n    // ...\n}\n\nfunc loadConfig() Config {\n    cwd, err := os.Getwd()\n    // handle err\n\n    raw, err := ioutil.ReadFile(\n        path.Join(cwd, "config", "config.yaml"),\n    )\n    // handle err\n\n    var config Config\n    yaml.Unmarshal(raw, &config)\n\n    return config\n}\n')))))),Object(r.b)("p",null,"Considering the above, some situations in which ",Object(r.b)("inlineCode",{parentName:"p"},"init()")," may be preferable or\nnecessary might include:"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},"Complex expressions that cannot be represented as single assignments.")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},"Pluggable hooks, such as ",Object(r.b)("inlineCode",{parentName:"p"},"database/sql")," dialects, encoding type registries, etc.")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},"Optimizations to ",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"https://cloud.google.com/functions/docs/bestpractices/tips#use_global_variables_to_reuse_objects_in_future_invocations"}),"Google Cloud Functions")," and other forms of deterministic\nprecomputation."))),Object(r.b)("h2",{id:"performance"},"Performance"),Object(r.b)("p",null,"Performance-specific guidelines apply only to the hot path."),Object(r.b)("h3",{id:"prefer-strconv-over-fmt"},"Prefer strconv over fmt"),Object(r.b)("p",null,"When converting primitives to/from strings, ",Object(r.b)("inlineCode",{parentName:"p"},"strconv")," is faster than\n",Object(r.b)("inlineCode",{parentName:"p"},"fmt"),"."),Object(r.b)("table",null,Object(r.b)("thead",null,Object(r.b)("tr",null,Object(r.b)("th",null,"Bad"),Object(r.b)("th",null,"Good"))),Object(r.b)("tbody",null,Object(r.b)("tr",null,Object(r.b)("td",null,Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-go"}),"for i := 0; i < b.N; i++ {\n  s := fmt.Sprint(rand.Int())\n}\n"))),Object(r.b)("td",null,Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-go"}),"for i := 0; i < b.N; i++ {\n  s := strconv.Itoa(rand.Int())\n}\n")))),Object(r.b)("tr",null,Object(r.b)("td",null,Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{}),"BenchmarkFmtSprint-4    143 ns/op    2 allocs/op\n"))),Object(r.b)("td",null,Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{}),"BenchmarkStrconv-4    64.2 ns/op    1 allocs/op\n")))))),Object(r.b)("h3",{id:"avoid-string-to-byte-conversion"},"Avoid string-to-byte conversion"),Object(r.b)("p",null,"Do not create byte slices from a fixed string repeatedly. Instead, perform the\nconversion once and capture the result."),Object(r.b)("table",null,Object(r.b)("thead",null,Object(r.b)("tr",null,Object(r.b)("th",null,"Bad"),Object(r.b)("th",null,"Good"))),Object(r.b)("tbody",null,Object(r.b)("tr",null,Object(r.b)("td",null,Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-go"}),'for i := 0; i < b.N; i++ {\n  w.Write([]byte("Hello world"))\n}\n'))),Object(r.b)("td",null,Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-go"}),'data := []byte("Hello world")\nfor i := 0; i < b.N; i++ {\n  w.Write(data)\n}\n')))),Object(r.b)("tr",null,Object(r.b)("td",null,Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{}),"BenchmarkBad-4   50000000   22.2 ns/op\n"))),Object(r.b)("td",null,Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{}),"BenchmarkGood-4  500000000   3.25 ns/op\n")))))),Object(r.b)("h3",{id:"prefer-specifying-container-capacity"},"Prefer Specifying Container Capacity"),Object(r.b)("p",null,"Specify container capacity where possible in order to allocate memory for the\ncontainer up front. This minimizes subsequent allocations (by copying and\nresizing of the container) as elements are added."),Object(r.b)("h4",{id:"specifying-map-capacity-hints"},"Specifying Map Capacity Hints"),Object(r.b)("p",null,"Where possible, provide capacity hints when initializing\nmaps with ",Object(r.b)("inlineCode",{parentName:"p"},"make()"),"."),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-go"}),"make(map[T1]T2, hint)\n")),Object(r.b)("p",null,"Providing a capacity hint to ",Object(r.b)("inlineCode",{parentName:"p"},"make()")," tries to right-size the\nmap at initialization time, which reduces the need for growing\nthe map and allocations as elements are added to the map."),Object(r.b)("p",null,"Note that, unlike slices, map capacity hints do not guarantee complete,\npreemptive allocation, but are used to approximate the number of hashmap buckets\nrequired. Consequently, allocations may still occur when adding elements to the\nmap, even up to the specified capacity."),Object(r.b)("table",null,Object(r.b)("thead",null,Object(r.b)("tr",null,Object(r.b)("th",null,"Bad"),Object(r.b)("th",null,"Good"))),Object(r.b)("tbody",null,Object(r.b)("tr",null,Object(r.b)("td",null,Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-go"}),'m := make(map[string]os.FileInfo)\n\nfiles, _ := ioutil.ReadDir("./files")\nfor _, f := range files {\n    m[f.Name()] = f\n}\n'))),Object(r.b)("td",null,Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-go"}),'\nfiles, _ := ioutil.ReadDir("./files")\n\nm := make(map[string]os.FileInfo, len(files))\nfor _, f := range files {\n    m[f.Name()] = f\n}\n')))),Object(r.b)("tr",null,Object(r.b)("td",null,Object(r.b)("p",null,Object(r.b)("inlineCode",{parentName:"p"},"m")," is created without a size hint; there may be more\nallocations at assignment time.")),Object(r.b)("td",null,Object(r.b)("p",null,Object(r.b)("inlineCode",{parentName:"p"},"m")," is created with a size hint; there may be fewer\nallocations at assignment time."))))),Object(r.b)("h4",{id:"specifying-slice-capacity"},"Specifying Slice Capacity"),Object(r.b)("p",null,"Where possible, provide capacity hints when initializing slices with ",Object(r.b)("inlineCode",{parentName:"p"},"make()"),",\nparticularly when appending."),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-go"}),"make([]T, length, capacity)\n")),Object(r.b)("p",null,"Unlike maps, slice capacity is not a hint: the compiler will allocate enough\nmemory for the capacity of the slice as provided to ",Object(r.b)("inlineCode",{parentName:"p"},"make()"),", which means that\nsubsequent ",Object(r.b)("inlineCode",{parentName:"p"},"append()")," operations will incur zero allocations (until the length\nof the slice matches the capacity, after which any appends will require a resize\nto hold additional elements)."),Object(r.b)("table",null,Object(r.b)("thead",null,Object(r.b)("tr",null,Object(r.b)("th",null,"Bad"),Object(r.b)("th",null,"Good"))),Object(r.b)("tbody",null,Object(r.b)("tr",null,Object(r.b)("td",null,Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-go"}),"for n := 0; n < b.N; n++ {\n  data := make([]int, 0)\n  for k := 0; k < size; k++{\n    data = append(data, k)\n  }\n}\n"))),Object(r.b)("td",null,Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-go"}),"for n := 0; n < b.N; n++ {\n  data := make([]int, 0, size)\n  for k := 0; k < size; k++{\n    data = append(data, k)\n  }\n}\n")))),Object(r.b)("tr",null,Object(r.b)("td",null,Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{}),"BenchmarkBad-4    100000000    2.48s\n"))),Object(r.b)("td",null,Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{}),"BenchmarkGood-4   100000000    0.21s\n")))))),Object(r.b)("h2",{id:"style"},"Style"),Object(r.b)("h3",{id:"be-consistent"},"Be Consistent"),Object(r.b)("p",null,"Some of the guidelines outlined in this document can be evaluated objectively;\nothers are situational, contextual, or subjective."),Object(r.b)("p",null,"Above all else, ",Object(r.b)("strong",{parentName:"p"},"be consistent"),"."),Object(r.b)("p",null,"Consistent code is easier to maintain, is easier to rationalize, requires less\ncognitive overhead, and is easier to migrate or update as new conventions emerge\nor classes of bugs are fixed."),Object(r.b)("p",null,"Conversely, having multiple disparate or conflicting styles within a single\ncodebase causes maintenance overhead, uncertainty, and cognitive dissonance,\nall of which can directly contribute to lower velocity, painful code reviews,\nand bugs."),Object(r.b)("p",null,"When applying these guidelines to a codebase, it is recommended that changes\nare made at a package (or larger) level: application at a sub-package level\nviolates the above concern by introducing multiple styles into the same code."),Object(r.b)("h3",{id:"group-similar-declarations"},"Group Similar Declarations"),Object(r.b)("p",null,"Go supports grouping similar declarations."),Object(r.b)("table",null,Object(r.b)("thead",null,Object(r.b)("tr",null,Object(r.b)("th",null,"Bad"),Object(r.b)("th",null,"Good"))),Object(r.b)("tbody",null,Object(r.b)("tr",null,Object(r.b)("td",null,Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-go"}),'import "a"\nimport "b"\n'))),Object(r.b)("td",null,Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-go"}),'import (\n  "a"\n  "b"\n)\n')))))),Object(r.b)("p",null,"This also applies to constants, variables, and type declarations."),Object(r.b)("table",null,Object(r.b)("thead",null,Object(r.b)("tr",null,Object(r.b)("th",null,"Bad"),Object(r.b)("th",null,"Good"))),Object(r.b)("tbody",null,Object(r.b)("tr",null,Object(r.b)("td",null,Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-go"}),"\nconst a = 1\nconst b = 2\n\n\n\nvar a = 1\nvar b = 2\n\n\n\ntype Area float64\ntype Volume float64\n"))),Object(r.b)("td",null,Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-go"}),"const (\n  a = 1\n  b = 2\n)\n\nvar (\n  a = 1\n  b = 2\n)\n\ntype (\n  Area float64\n  Volume float64\n)\n")))))),Object(r.b)("p",null,"Only group related declarations. Do not group declarations that are unrelated."),Object(r.b)("table",null,Object(r.b)("thead",null,Object(r.b)("tr",null,Object(r.b)("th",null,"Bad"),Object(r.b)("th",null,"Good"))),Object(r.b)("tbody",null,Object(r.b)("tr",null,Object(r.b)("td",null,Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-go"}),'type Operation int\n\nconst (\n  Add Operation = iota + 1\n  Subtract\n  Multiply\n  ENV_VAR = "MY_ENV"\n)\n'))),Object(r.b)("td",null,Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-go"}),'type Operation int\n\nconst (\n  Add Operation = iota + 1\n  Subtract\n  Multiply\n)\n\nconst ENV_VAR = "MY_ENV"\n')))))),Object(r.b)("p",null,"Groups are not limited in where they can be used. For example, you can use them\ninside of functions."),Object(r.b)("table",null,Object(r.b)("thead",null,Object(r.b)("tr",null,Object(r.b)("th",null,"Bad"),Object(r.b)("th",null,"Good"))),Object(r.b)("tbody",null,Object(r.b)("tr",null,Object(r.b)("td",null,Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-go"}),"func f() string {\n  var red = color.New(0xff0000)\n  var green = color.New(0x00ff00)\n  var blue = color.New(0x0000ff)\n\n  ...\n}\n"))),Object(r.b)("td",null,Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-go"}),"func f() string {\n  var (\n    red   = color.New(0xff0000)\n    green = color.New(0x00ff00)\n    blue  = color.New(0x0000ff)\n  )\n\n  ...\n}\n")))))),Object(r.b)("h3",{id:"import-group-ordering"},"Import Group Ordering"),Object(r.b)("p",null,"There should be two import groups:"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},"Standard library"),Object(r.b)("li",{parentName:"ul"},"Everything else")),Object(r.b)("p",null,"This is the grouping applied by goimports by default."),Object(r.b)("table",null,Object(r.b)("thead",null,Object(r.b)("tr",null,Object(r.b)("th",null,"Bad"),Object(r.b)("th",null,"Good"))),Object(r.b)("tbody",null,Object(r.b)("tr",null,Object(r.b)("td",null,Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-go"}),'import (\n  "fmt"\n  "os"\n  "go.uber.org/atomic"\n  "golang.org/x/sync/errgroup"\n)\n'))),Object(r.b)("td",null,Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-go"}),'import (\n  "fmt"\n  "os"\n\n  "go.uber.org/atomic"\n  "golang.org/x/sync/errgroup"\n)\n')))))),Object(r.b)("h3",{id:"package-names"},"Package Names"),Object(r.b)("p",null,"When naming packages, choose a name that is:"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},"All lower-case. No capitals or underscores."),Object(r.b)("li",{parentName:"ul"},"Does not need to be renamed using named imports at most call sites."),Object(r.b)("li",{parentName:"ul"},"Short and succinct. Remember that the name is identified in full at every call\nsite."),Object(r.b)("li",{parentName:"ul"},"Not plural. For example, ",Object(r.b)("inlineCode",{parentName:"li"},"net/url"),", not ",Object(r.b)("inlineCode",{parentName:"li"},"net/urls"),"."),Object(r.b)("li",{parentName:"ul"},'Not "common", "util", "shared", or "lib". These are bad, uninformative names.')),Object(r.b)("p",null,"See also ",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"https://blog.golang.org/package-names"}),"Package Names")," and ",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"https://rakyll.org/style-packages/"}),"Style guideline for Go packages"),"."),Object(r.b)("h3",{id:"function-names"},"Function Names"),Object(r.b)("p",null,"We follow the Go community's convention of using ",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"https://golang.org/doc/effective_go.html#mixed-caps"}),"MixedCaps for function\nnames"),". An exception is made for test functions, which may contain underscores\nfor the purpose of grouping related test cases, e.g.,\n",Object(r.b)("inlineCode",{parentName:"p"},"TestMyFunction_WhatIsBeingTested"),"."),Object(r.b)("h3",{id:"import-aliasing"},"Import Aliasing"),Object(r.b)("p",null,"Import aliasing must be used if the package name does not match the last\nelement of the import path."),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-go"}),'import (\n  "net/http"\n\n  client "example.com/client-go"\n  trace "example.com/trace/v2"\n)\n')),Object(r.b)("p",null,"In all other scenarios, import aliases should be avoided unless there is a\ndirect conflict between imports."),Object(r.b)("table",null,Object(r.b)("thead",null,Object(r.b)("tr",null,Object(r.b)("th",null,"Bad"),Object(r.b)("th",null,"Good"))),Object(r.b)("tbody",null,Object(r.b)("tr",null,Object(r.b)("td",null,Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-go"}),'import (\n  "fmt"\n  "os"\n\n\n  nettrace "golang.net/x/trace"\n)\n'))),Object(r.b)("td",null,Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-go"}),'import (\n  "fmt"\n  "os"\n  "runtime/trace"\n\n  nettrace "golang.net/x/trace"\n)\n')))))),Object(r.b)("h3",{id:"function-grouping-and-ordering"},"Function Grouping and Ordering"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},"Functions should be sorted in rough call order."),Object(r.b)("li",{parentName:"ul"},"Functions in a file should be grouped by receiver.")),Object(r.b)("p",null,"Therefore, exported functions should appear first in a file, after\n",Object(r.b)("inlineCode",{parentName:"p"},"struct"),", ",Object(r.b)("inlineCode",{parentName:"p"},"const"),", ",Object(r.b)("inlineCode",{parentName:"p"},"var")," definitions."),Object(r.b)("p",null,"A ",Object(r.b)("inlineCode",{parentName:"p"},"newXYZ()"),"/",Object(r.b)("inlineCode",{parentName:"p"},"NewXYZ()")," may appear after the type is defined, but before the\nrest of the methods on the receiver."),Object(r.b)("p",null,"Since functions are grouped by receiver, plain utility functions should appear\ntowards the end of the file."),Object(r.b)("table",null,Object(r.b)("thead",null,Object(r.b)("tr",null,Object(r.b)("th",null,"Bad"),Object(r.b)("th",null,"Good"))),Object(r.b)("tbody",null,Object(r.b)("tr",null,Object(r.b)("td",null,Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-go"}),"func (s *something) Cost() {\n  return calcCost(s.weights)\n}\n\ntype something struct{ ... }\n\nfunc calcCost(n []int) int {...}\n\nfunc (s *something) Stop() {...}\n\nfunc newSomething() *something {\n    return &something{}\n}\n"))),Object(r.b)("td",null,Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-go"}),"type something struct{ ... }\n\nfunc newSomething() *something {\n    return &something{}\n}\n\nfunc (s *something) Cost() {\n  return calcCost(s.weights)\n}\n\nfunc (s *something) Stop() {...}\n\nfunc calcCost(n []int) int {...}\n")))))),Object(r.b)("h3",{id:"reduce-nesting"},"Reduce Nesting"),Object(r.b)("p",null,"Code should reduce nesting where possible by handling error cases/special\nconditions first and returning early or continuing the loop. Reduce the amount\nof code that is nested multiple levels."),Object(r.b)("table",null,Object(r.b)("thead",null,Object(r.b)("tr",null,Object(r.b)("th",null,"Bad"),Object(r.b)("th",null,"Good"))),Object(r.b)("tbody",null,Object(r.b)("tr",null,Object(r.b)("td",null,Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-go"}),'for _, v := range data {\n  if v.F1 == 1 {\n    v = process(v)\n    if err := v.Call(); err == nil {\n      v.Send()\n    } else {\n      return err\n    }\n  } else {\n    log.Printf("Invalid v: %v", v)\n  }\n}\n'))),Object(r.b)("td",null,Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-go"}),'for _, v := range data {\n  if v.F1 != 1 {\n    log.Printf("Invalid v: %v", v)\n    continue\n  }\n\n  v = process(v)\n  if err := v.Call(); err != nil {\n    return err\n  }\n  v.Send()\n}\n')))))),Object(r.b)("h3",{id:"unnecessary-else"},"Unnecessary Else"),Object(r.b)("p",null,"If a variable is set in both branches of an if, it can be replaced with a\nsingle if."),Object(r.b)("table",null,Object(r.b)("thead",null,Object(r.b)("tr",null,Object(r.b)("th",null,"Bad"),Object(r.b)("th",null,"Good"))),Object(r.b)("tbody",null,Object(r.b)("tr",null,Object(r.b)("td",null,Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-go"}),"var a int\nif b {\n  a = 100\n} else {\n  a = 10\n}\n"))),Object(r.b)("td",null,Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-go"}),"a := 10\nif b {\n  a = 100\n}\n")))))),Object(r.b)("h3",{id:"top-level-variable-declarations"},"Top-level Variable Declarations"),Object(r.b)("p",null,"At the top level, use the standard ",Object(r.b)("inlineCode",{parentName:"p"},"var")," keyword. Do not specify the type,\nunless it is not the same type as the expression."),Object(r.b)("table",null,Object(r.b)("thead",null,Object(r.b)("tr",null,Object(r.b)("th",null,"Bad"),Object(r.b)("th",null,"Good"))),Object(r.b)("tbody",null,Object(r.b)("tr",null,Object(r.b)("td",null,Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-go"}),'var _s string = F()\n\nfunc F() string { return "A" }\n'))),Object(r.b)("td",null,Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-go"}),'var _s = F()\n// Since F already states that it returns a string, we don\'t need to specify\n// the type again.\n\nfunc F() string { return "A" }\n')))))),Object(r.b)("p",null,"Specify the type if the type of the expression does not match the desired type\nexactly."),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-go"}),'type myError struct{}\n\nfunc (myError) Error() string { return "error" }\n\nfunc F() myError { return myError{} }\n\nvar _e error = F()\n// F returns an object of type myError but we want error.\n')),Object(r.b)("h3",{id:"prefix-unexported-globals-with-_"},"Prefix Unexported Globals with _"),Object(r.b)("p",null,"Prefix unexported top-level ",Object(r.b)("inlineCode",{parentName:"p"},"var"),"s and ",Object(r.b)("inlineCode",{parentName:"p"},"const"),"s with ",Object(r.b)("inlineCode",{parentName:"p"},"_")," to make it clear when\nthey are used that they are global symbols."),Object(r.b)("p",null,"Exception: Unexported error values, which should be prefixed with ",Object(r.b)("inlineCode",{parentName:"p"},"err"),"."),Object(r.b)("p",null,"Rationale: Top-level variables and constants have a package scope. Using a\ngeneric name makes it easy to accidentally use the wrong value in a different\nfile."),Object(r.b)("table",null,Object(r.b)("thead",null,Object(r.b)("tr",null,Object(r.b)("th",null,"Bad"),Object(r.b)("th",null,"Good"))),Object(r.b)("tbody",null,Object(r.b)("tr",null,Object(r.b)("td",null,Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-go"}),'// foo.go\n\nconst (\n  defaultPort = 8080\n  defaultUser = "user"\n)\n\n// bar.go\n\nfunc Bar() {\n  defaultPort := 9090\n  ...\n  fmt.Println("Default port", defaultPort)\n\n  // We will not see a compile error if the first line of\n  // Bar() is deleted.\n}\n'))),Object(r.b)("td",null,Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-go"}),'// foo.go\n\nconst (\n  _defaultPort = 8080\n  _defaultUser = "user"\n)\n')))))),Object(r.b)("h3",{id:"embedding-in-structs"},"Embedding in Structs"),Object(r.b)("p",null,"Embedded types (such as mutexes) should be at the top of the field list of a\nstruct, and there must be an empty line separating embedded fields from regular\nfields."),Object(r.b)("table",null,Object(r.b)("thead",null,Object(r.b)("tr",null,Object(r.b)("th",null,"Bad"),Object(r.b)("th",null,"Good"))),Object(r.b)("tbody",null,Object(r.b)("tr",null,Object(r.b)("td",null,Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-go"}),"type Client struct {\n  version int\n  http.Client\n}\n"))),Object(r.b)("td",null,Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-go"}),"type Client struct {\n  http.Client\n\n  version int\n}\n")))))),Object(r.b)("p",null,"Embedding should provide tangible benefit, like adding or augmenting\nfunctionality in a semantically-appropriate way. It should do this with zero\nadverse user-facing effects (see also: ",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"#avoid-embedding-types-in-public-structs"}),"Avoid Embedding Types in Public Structs"),")."),Object(r.b)("p",null,"Embedding ",Object(r.b)("strong",{parentName:"p"},"should not"),":"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},"Be purely cosmetic or convenience-oriented."),Object(r.b)("li",{parentName:"ul"},"Make outer types more difficult to construct or use."),Object(r.b)("li",{parentName:"ul"},"Affect outer types' zero values. If the outer type has a useful zero value, it\nshould still have a useful zero value after embedding the inner type."),Object(r.b)("li",{parentName:"ul"},"Expose unrelated functions or fields from the outer type as a side-effect of\nembedding the inner type."),Object(r.b)("li",{parentName:"ul"},"Expose unexported types."),Object(r.b)("li",{parentName:"ul"},"Affect outer types' copy semantics."),Object(r.b)("li",{parentName:"ul"},"Change the outer type's API or type semantics."),Object(r.b)("li",{parentName:"ul"},"Embed a non-canonical form of the inner type."),Object(r.b)("li",{parentName:"ul"},"Expose implementation details of the outer type."),Object(r.b)("li",{parentName:"ul"},"Allow users to observe or control type internals."),Object(r.b)("li",{parentName:"ul"},"Change the general behavior of inner functions through wrapping in a way that\nwould reasonably surprise users.")),Object(r.b)("p",null,'Simply put, embed consciously and intentionally. A good litmus test is, "would\nall of these exported inner methods/fields be added directly to the outer type";\nif the answer is "some" or "no", don\'t embed the inner type - use a field\ninstead.'),Object(r.b)("table",null,Object(r.b)("thead",null,Object(r.b)("tr",null,Object(r.b)("th",null,"Bad"),Object(r.b)("th",null,"Good"))),Object(r.b)("tbody",null,Object(r.b)("tr",null,Object(r.b)("td",null,Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-go"}),"type A struct {\n    // Bad: A.Lock() and A.Unlock() are\n    //      now available, provide no\n    //      functional benefit, and allow\n    //      users to control details about\n    //      the internals of A.\n    sync.Mutex\n}\n"))),Object(r.b)("td",null,Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-go"}),"type countingWriteCloser struct {\n    // Good: Write() is provided at this\n    //       outer layer for a specific\n    //       purpose, and delegates work\n    //       to the inner type's Write().\n    io.WriteCloser\n\n    count int\n}\n\nfunc (w *countingWriteCloser) Write(bs []byte) (int, error) {\n    w.count += len(bs)\n    return w.WriteCloser.Write(bs)\n}\n")))),Object(r.b)("tr",null,Object(r.b)("td",null,Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-go"}),"type Book struct {\n    // Bad: pointer changes zero value usefulness\n    io.ReadWriter\n\n    // other fields\n}\n\n// later\n\nvar b Book\nb.Read(...)  // panic: nil pointer\nb.String()   // panic: nil pointer\nb.Write(...) // panic: nil pointer\n"))),Object(r.b)("td",null,Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-go"}),"type Book struct {\n    // Good: has useful zero value\n    bytes.Buffer\n\n    // other fields\n}\n\n// later\n\nvar b Book\nb.Read(...)  // ok\nb.String()   // ok\nb.Write(...) // ok\n")))),Object(r.b)("tr",null,Object(r.b)("td",null,Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-go"}),"type Client struct {\n    sync.Mutex\n    sync.WaitGroup\n    bytes.Buffer\n    url.URL\n}\n"))),Object(r.b)("td",null,Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-go"}),"type Client struct {\n    mtx sync.Mutex\n    wg  sync.WaitGroup\n    buf bytes.Buffer\n    url url.URL\n}\n")))))),Object(r.b)("h3",{id:"use-field-names-to-initialize-structs"},"Use Field Names to Initialize Structs"),Object(r.b)("p",null,"You should almost always specify field names when initializing structs. This is\nnow enforced by ",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"https://golang.org/cmd/vet/"}),Object(r.b)("inlineCode",{parentName:"a"},"go vet")),"."),Object(r.b)("table",null,Object(r.b)("thead",null,Object(r.b)("tr",null,Object(r.b)("th",null,"Bad"),Object(r.b)("th",null,"Good"))),Object(r.b)("tbody",null,Object(r.b)("tr",null,Object(r.b)("td",null,Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-go"}),'k := User{"John", "Doe", true}\n'))),Object(r.b)("td",null,Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-go"}),'k := User{\n    FirstName: "John",\n    LastName: "Doe",\n    Admin: true,\n}\n')))))),Object(r.b)("p",null,"Exception: Field names ",Object(r.b)("em",{parentName:"p"},"may")," be omitted in test tables when there are 3 or\nfewer fields."),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-go"}),'tests := []struct{\n  op Operation\n  want string\n}{\n  {Add, "add"},\n  {Subtract, "subtract"},\n}\n')),Object(r.b)("h3",{id:"local-variable-declarations"},"Local Variable Declarations"),Object(r.b)("p",null,"Short variable declarations (",Object(r.b)("inlineCode",{parentName:"p"},":="),") should be used if a variable is being set to\nsome value explicitly."),Object(r.b)("table",null,Object(r.b)("thead",null,Object(r.b)("tr",null,Object(r.b)("th",null,"Bad"),Object(r.b)("th",null,"Good"))),Object(r.b)("tbody",null,Object(r.b)("tr",null,Object(r.b)("td",null,Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-go"}),'var s = "foo"\n'))),Object(r.b)("td",null,Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-go"}),'s := "foo"\n')))))),Object(r.b)("p",null,"However, there are cases where the default value is clearer when the ",Object(r.b)("inlineCode",{parentName:"p"},"var"),"\nkeyword is used. ",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"https://github.com/golang/go/wiki/CodeReviewComments#declaring-empty-slices"}),"Declaring Empty Slices"),", for example."),Object(r.b)("table",null,Object(r.b)("thead",null,Object(r.b)("tr",null,Object(r.b)("th",null,"Bad"),Object(r.b)("th",null,"Good"))),Object(r.b)("tbody",null,Object(r.b)("tr",null,Object(r.b)("td",null,Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-go"}),"func f(list []int) {\n  filtered := []int{}\n  for _, v := range list {\n    if v > 10 {\n      filtered = append(filtered, v)\n    }\n  }\n}\n"))),Object(r.b)("td",null,Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-go"}),"func f(list []int) {\n  var filtered []int\n  for _, v := range list {\n    if v > 10 {\n      filtered = append(filtered, v)\n    }\n  }\n}\n")))))),Object(r.b)("h3",{id:"nil-is-a-valid-slice"},"nil is a valid slice"),Object(r.b)("p",null,Object(r.b)("inlineCode",{parentName:"p"},"nil")," is a valid slice of length 0. This means that,"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},"You should not return a slice of length zero explicitly. Return ",Object(r.b)("inlineCode",{parentName:"p"},"nil"),"\ninstead."),Object(r.b)("table",null,Object(r.b)("thead",null,Object(r.b)("tr",null,Object(r.b)("th",null,"Bad"),Object(r.b)("th",null,"Good"))),Object(r.b)("tbody",null,Object(r.b)("tr",null,Object(r.b)("td",null,Object(r.b)("pre",{parentName:"li"},Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-go"}),'if x == "" {\n  return []int{}\n}\n'))),Object(r.b)("td",null,Object(r.b)("pre",{parentName:"li"},Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-go"}),'if x == "" {\n  return nil\n}\n'))))))),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},"To check if a slice is empty, always use ",Object(r.b)("inlineCode",{parentName:"p"},"len(s) == 0"),". Do not check for\n",Object(r.b)("inlineCode",{parentName:"p"},"nil"),"."),Object(r.b)("table",null,Object(r.b)("thead",null,Object(r.b)("tr",null,Object(r.b)("th",null,"Bad"),Object(r.b)("th",null,"Good"))),Object(r.b)("tbody",null,Object(r.b)("tr",null,Object(r.b)("td",null,Object(r.b)("pre",{parentName:"li"},Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-go"}),"func isEmpty(s []string) bool {\n  return s == nil\n}\n"))),Object(r.b)("td",null,Object(r.b)("pre",{parentName:"li"},Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-go"}),"func isEmpty(s []string) bool {\n  return len(s) == 0\n}\n"))))))),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},"The zero value (a slice declared with ",Object(r.b)("inlineCode",{parentName:"p"},"var"),") is usable immediately without\n",Object(r.b)("inlineCode",{parentName:"p"},"make()"),"."),Object(r.b)("table",null,Object(r.b)("thead",null,Object(r.b)("tr",null,Object(r.b)("th",null,"Bad"),Object(r.b)("th",null,"Good"))),Object(r.b)("tbody",null,Object(r.b)("tr",null,Object(r.b)("td",null,Object(r.b)("pre",{parentName:"li"},Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-go"}),"nums := []int{}\n// or, nums := make([]int)\n\nif add1 {\n  nums = append(nums, 1)\n}\n\nif add2 {\n  nums = append(nums, 2)\n}\n"))),Object(r.b)("td",null,Object(r.b)("pre",{parentName:"li"},Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-go"}),"var nums []int\n\nif add1 {\n  nums = append(nums, 1)\n}\n\nif add2 {\n  nums = append(nums, 2)\n}\n")))))))),Object(r.b)("p",null,"Remember that, while it is a valid slice, a nil slice is not equivalent to an\nallocated slice of length 0 - one is nil and the other is not - and the two may\nbe treated differently in different situations (such as serialization)."),Object(r.b)("h3",{id:"reduce-scope-of-variables"},"Reduce Scope of Variables"),Object(r.b)("p",null,"Where possible, reduce scope of variables. Do not reduce the scope if it\nconflicts with ",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"#reduce-nesting"}),"Reduce Nesting"),"."),Object(r.b)("table",null,Object(r.b)("thead",null,Object(r.b)("tr",null,Object(r.b)("th",null,"Bad"),Object(r.b)("th",null,"Good"))),Object(r.b)("tbody",null,Object(r.b)("tr",null,Object(r.b)("td",null,Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-go"}),"err := ioutil.WriteFile(name, data, 0644)\nif err != nil {\n return err\n}\n"))),Object(r.b)("td",null,Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-go"}),"if err := ioutil.WriteFile(name, data, 0644); err != nil {\n return err\n}\n")))))),Object(r.b)("p",null,"If you need a result of a function call outside of the if, then you should not\ntry to reduce the scope."),Object(r.b)("table",null,Object(r.b)("thead",null,Object(r.b)("tr",null,Object(r.b)("th",null,"Bad"),Object(r.b)("th",null,"Good"))),Object(r.b)("tbody",null,Object(r.b)("tr",null,Object(r.b)("td",null,Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-go"}),"if data, err := ioutil.ReadFile(name); err == nil {\n  err = cfg.Decode(data)\n  if err != nil {\n    return err\n  }\n\n  fmt.Println(cfg)\n  return nil\n} else {\n  return err\n}\n"))),Object(r.b)("td",null,Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-go"}),"data, err := ioutil.ReadFile(name)\nif err != nil {\n   return err\n}\n\nif err := cfg.Decode(data); err != nil {\n  return err\n}\n\nfmt.Println(cfg)\nreturn nil\n")))))),Object(r.b)("h3",{id:"avoid-naked-parameters"},"Avoid Naked Parameters"),Object(r.b)("p",null,"Naked parameters in function calls can hurt readability. Add C-style comments\n(",Object(r.b)("inlineCode",{parentName:"p"},"/* ... */"),") for parameter names when their meaning is not obvious."),Object(r.b)("table",null,Object(r.b)("thead",null,Object(r.b)("tr",null,Object(r.b)("th",null,"Bad"),Object(r.b)("th",null,"Good"))),Object(r.b)("tbody",null,Object(r.b)("tr",null,Object(r.b)("td",null,Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-go"}),'// func printInfo(name string, isLocal, done bool)\n\nprintInfo("foo", true, true)\n'))),Object(r.b)("td",null,Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-go"}),'// func printInfo(name string, isLocal, done bool)\n\nprintInfo("foo", true /* isLocal */, true /* done */)\n')))))),Object(r.b)("p",null,"Better yet, replace naked ",Object(r.b)("inlineCode",{parentName:"p"},"bool")," types with custom types for more readable and\ntype-safe code. This allows more than just two states (true/false) for that\nparameter in the future."),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-go"}),"type Region int\n\nconst (\n  UnknownRegion Region = iota\n  Local\n)\n\ntype Status int\n\nconst (\n  StatusReady Status = iota + 1\n  StatusDone\n  // Maybe we will have a StatusInProgress in the future.\n)\n\nfunc printInfo(name string, region Region, status Status)\n")),Object(r.b)("h3",{id:"use-raw-string-literals-to-avoid-escaping"},"Use Raw String Literals to Avoid Escaping"),Object(r.b)("p",null,"Go supports ",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"https://golang.org/ref/spec#raw_string_lit"}),"raw string literals"),",\nwhich can span multiple lines and include quotes. Use these to avoid\nhand-escaped strings which are much harder to read."),Object(r.b)("table",null,Object(r.b)("thead",null,Object(r.b)("tr",null,Object(r.b)("th",null,"Bad"),Object(r.b)("th",null,"Good"))),Object(r.b)("tbody",null,Object(r.b)("tr",null,Object(r.b)("td",null,Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-go"}),'wantError := "unknown name:\\"test\\""\n'))),Object(r.b)("td",null,Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-go"}),'wantError := `unknown error:"test"`\n')))))),Object(r.b)("h3",{id:"initializing-struct-references"},"Initializing Struct References"),Object(r.b)("p",null,"Use ",Object(r.b)("inlineCode",{parentName:"p"},"&T{}")," instead of ",Object(r.b)("inlineCode",{parentName:"p"},"new(T)")," when initializing struct references so that it\nis consistent with the struct initialization."),Object(r.b)("table",null,Object(r.b)("thead",null,Object(r.b)("tr",null,Object(r.b)("th",null,"Bad"),Object(r.b)("th",null,"Good"))),Object(r.b)("tbody",null,Object(r.b)("tr",null,Object(r.b)("td",null,Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-go"}),'sval := T{Name: "foo"}\n\n// inconsistent\nsptr := new(T)\nsptr.Name = "bar"\n'))),Object(r.b)("td",null,Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-go"}),'sval := T{Name: "foo"}\n\nsptr := &T{Name: "bar"}\n')))))),Object(r.b)("h3",{id:"initializing-maps"},"Initializing Maps"),Object(r.b)("p",null,"Prefer ",Object(r.b)("inlineCode",{parentName:"p"},"make(..)")," for empty maps, and maps populated\nprogrammatically. This makes map initialization visually\ndistinct from declaration, and it makes it easy to add size\nhints later if available."),Object(r.b)("table",null,Object(r.b)("thead",null,Object(r.b)("tr",null,Object(r.b)("th",null,"Bad"),Object(r.b)("th",null,"Good"))),Object(r.b)("tbody",null,Object(r.b)("tr",null,Object(r.b)("td",null,Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-go"}),"var (\n  // m1 is safe to read and write;\n  // m2 will panic on writes.\n  m1 = map[T1]T2{}\n  m2 map[T1]T2\n)\n"))),Object(r.b)("td",null,Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-go"}),"var (\n  // m1 is safe to read and write;\n  // m2 will panic on writes.\n  m1 = make(map[T1]T2)\n  m2 map[T1]T2\n)\n")))),Object(r.b)("tr",null,Object(r.b)("td",null,Object(r.b)("p",null,"Declaration and initialization are visually similar.")),Object(r.b)("td",null,Object(r.b)("p",null,"Declaration and initialization are visually distinct."))))),Object(r.b)("p",null,"Where possible, provide capacity hints when initializing\nmaps with ",Object(r.b)("inlineCode",{parentName:"p"},"make()"),". See\n",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"#specifying-map-capacity-hints"}),"Specifying Map Capacity Hints"),"\nfor more information."),Object(r.b)("p",null,"On the other hand, if the map holds a fixed list of elements,\nuse map literals to initialize the map."),Object(r.b)("table",null,Object(r.b)("thead",null,Object(r.b)("tr",null,Object(r.b)("th",null,"Bad"),Object(r.b)("th",null,"Good"))),Object(r.b)("tbody",null,Object(r.b)("tr",null,Object(r.b)("td",null,Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-go"}),"m := make(map[T1]T2, 3)\nm[k1] = v1\nm[k2] = v2\nm[k3] = v3\n"))),Object(r.b)("td",null,Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-go"}),"m := map[T1]T2{\n  k1: v1,\n  k2: v2,\n  k3: v3,\n}\n")))))),Object(r.b)("p",null,"The basic rule of thumb is to use map literals when adding a fixed set of\nelements at initialization time, otherwise use ",Object(r.b)("inlineCode",{parentName:"p"},"make")," (and specify a size hint\nif available)."),Object(r.b)("h3",{id:"format-strings-outside-printf"},"Format Strings outside Printf"),Object(r.b)("p",null,"If you declare format strings for ",Object(r.b)("inlineCode",{parentName:"p"},"Printf"),"-style functions outside a string\nliteral, make them ",Object(r.b)("inlineCode",{parentName:"p"},"const")," values."),Object(r.b)("p",null,"This helps ",Object(r.b)("inlineCode",{parentName:"p"},"go vet")," perform static analysis of the format string."),Object(r.b)("table",null,Object(r.b)("thead",null,Object(r.b)("tr",null,Object(r.b)("th",null,"Bad"),Object(r.b)("th",null,"Good"))),Object(r.b)("tbody",null,Object(r.b)("tr",null,Object(r.b)("td",null,Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-go"}),'msg := "unexpected values %v, %v\\n"\nfmt.Printf(msg, 1, 2)\n'))),Object(r.b)("td",null,Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-go"}),'const msg = "unexpected values %v, %v\\n"\nfmt.Printf(msg, 1, 2)\n')))))),Object(r.b)("h3",{id:"naming-printf-style-functions"},"Naming Printf-style Functions"),Object(r.b)("p",null,"When you declare a ",Object(r.b)("inlineCode",{parentName:"p"},"Printf"),"-style function, make sure that ",Object(r.b)("inlineCode",{parentName:"p"},"go vet")," can detect\nit and check the format string."),Object(r.b)("p",null,"This means that you should use predefined ",Object(r.b)("inlineCode",{parentName:"p"},"Printf"),"-style function\nnames if possible. ",Object(r.b)("inlineCode",{parentName:"p"},"go vet")," will check these by default. See ",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"https://golang.org/cmd/vet/#hdr-Printf_family"}),"Printf family"),"\nfor more information."),Object(r.b)("p",null,"If using the predefined names is not an option, end the name you choose with\nf: ",Object(r.b)("inlineCode",{parentName:"p"},"Wrapf"),", not ",Object(r.b)("inlineCode",{parentName:"p"},"Wrap"),". ",Object(r.b)("inlineCode",{parentName:"p"},"go vet")," can be asked to check specific ",Object(r.b)("inlineCode",{parentName:"p"},"Printf"),"-style\nnames but they must end with f."),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-shell"}),"$ go vet -printfuncs=wrapf,statusf\n")),Object(r.b)("p",null,"See also ",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"https://kuzminva.wordpress.com/2017/11/07/go-vet-printf-family-check/"}),"go vet: Printf family check"),"."),Object(r.b)("h2",{id:"patterns"},"Patterns"),Object(r.b)("h3",{id:"test-tables"},"Test Tables"),Object(r.b)("p",null,"Use table-driven tests with ",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"https://blog.golang.org/subtests"}),"subtests")," to avoid duplicating code when the core\ntest logic is repetitive."),Object(r.b)("table",null,Object(r.b)("thead",null,Object(r.b)("tr",null,Object(r.b)("th",null,"Bad"),Object(r.b)("th",null,"Good"))),Object(r.b)("tbody",null,Object(r.b)("tr",null,Object(r.b)("td",null,Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-go"}),'// func TestSplitHostPort(t *testing.T)\n\nhost, port, err := net.SplitHostPort("192.0.2.0:8000")\nrequire.NoError(t, err)\nassert.Equal(t, "192.0.2.0", host)\nassert.Equal(t, "8000", port)\n\nhost, port, err = net.SplitHostPort("192.0.2.0:http")\nrequire.NoError(t, err)\nassert.Equal(t, "192.0.2.0", host)\nassert.Equal(t, "http", port)\n\nhost, port, err = net.SplitHostPort(":8000")\nrequire.NoError(t, err)\nassert.Equal(t, "", host)\nassert.Equal(t, "8000", port)\n\nhost, port, err = net.SplitHostPort("1:8")\nrequire.NoError(t, err)\nassert.Equal(t, "1", host)\nassert.Equal(t, "8", port)\n'))),Object(r.b)("td",null,Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-go"}),'// func TestSplitHostPort(t *testing.T)\n\ntests := []struct{\n  give     string\n  wantHost string\n  wantPort string\n}{\n  {\n    give:     "192.0.2.0:8000",\n    wantHost: "192.0.2.0",\n    wantPort: "8000",\n  },\n  {\n    give:     "192.0.2.0:http",\n    wantHost: "192.0.2.0",\n    wantPort: "http",\n  },\n  {\n    give:     ":8000",\n    wantHost: "",\n    wantPort: "8000",\n  },\n  {\n    give:     "1:8",\n    wantHost: "1",\n    wantPort: "8",\n  },\n}\n\nfor _, tt := range tests {\n  t.Run(tt.give, func(t *testing.T) {\n    host, port, err := net.SplitHostPort(tt.give)\n    require.NoError(t, err)\n    assert.Equal(t, tt.wantHost, host)\n    assert.Equal(t, tt.wantPort, port)\n  })\n}\n')))))),Object(r.b)("p",null,"Test tables make it easier to add context to error messages, reduce duplicate\nlogic, and add new test cases."),Object(r.b)("p",null,"We follow the convention that the slice of structs is referred to as ",Object(r.b)("inlineCode",{parentName:"p"},"tests"),"\nand each test case ",Object(r.b)("inlineCode",{parentName:"p"},"tt"),". Further, we encourage explicating the input and output\nvalues for each test case with ",Object(r.b)("inlineCode",{parentName:"p"},"give")," and ",Object(r.b)("inlineCode",{parentName:"p"},"want")," prefixes."),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-go"}),"tests := []struct{\n  give     string\n  wantHost string\n  wantPort string\n}{\n  // ...\n}\n\nfor _, tt := range tests {\n  // ...\n}\n")),Object(r.b)("h3",{id:"functional-options"},"Functional Options"),Object(r.b)("p",null,"Functional options is a pattern in which you declare an opaque ",Object(r.b)("inlineCode",{parentName:"p"},"Option")," type\nthat records information in some internal struct. You accept a variadic number\nof these options and act upon the full information recorded by the options on\nthe internal struct."),Object(r.b)("p",null,"Use this pattern for optional arguments in constructors and other public APIs\nthat you foresee needing to expand, especially if you already have three or\nmore arguments on those functions."),Object(r.b)("table",null,Object(r.b)("thead",null,Object(r.b)("tr",null,Object(r.b)("th",null,"Bad"),Object(r.b)("th",null,"Good"))),Object(r.b)("tbody",null,Object(r.b)("tr",null,Object(r.b)("td",null,Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-go"}),"// package db\n\nfunc Open(\n  addr string,\n  cache bool,\n  logger *zap.Logger\n) (*Connection, error) {\n  // ...\n}\n"))),Object(r.b)("td",null,Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-go"}),"// package db\n\ntype Option interface {\n  // ...\n}\n\nfunc WithCache(c bool) Option {\n  // ...\n}\n\nfunc WithLogger(log *zap.Logger) Option {\n  // ...\n}\n\n// Open creates a connection.\nfunc Open(\n  addr string,\n  opts ...Option,\n) (*Connection, error) {\n  // ...\n}\n")))),Object(r.b)("tr",null,Object(r.b)("td",null,Object(r.b)("p",null,"The cache and logger parameters must always be provided, even if the user\nwants to use the default."),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-go"}),"db.Open(addr, db.DefaultCache, zap.NewNop())\ndb.Open(addr, db.DefaultCache, log)\ndb.Open(addr, false /* cache */, zap.NewNop())\ndb.Open(addr, false /* cache */, log)\n"))),Object(r.b)("td",null,Object(r.b)("p",null,"Options are provided only if needed."),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-go"}),"db.Open(addr)\ndb.Open(addr, db.WithLogger(log))\ndb.Open(addr, db.WithCache(false))\ndb.Open(\n  addr,\n  db.WithCache(false),\n  db.WithLogger(log),\n)\n")))))),Object(r.b)("p",null,"Our suggested way of implementing this pattern is with an ",Object(r.b)("inlineCode",{parentName:"p"},"Option")," interface\nthat holds an unexported method, recording options on an unexported ",Object(r.b)("inlineCode",{parentName:"p"},"options"),"\nstruct."),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-go"}),"type options struct {\n  cache  bool\n  logger *zap.Logger\n}\n\ntype Option interface {\n  apply(*options)\n}\n\ntype cacheOption bool\n\nfunc (c cacheOption) apply(opts *options) {\n  opts.cache = bool(c)\n}\n\nfunc WithCache(c bool) Option {\n  return cacheOption(c)\n}\n\ntype loggerOption struct {\n  Log *zap.Logger\n}\n\nfunc (l loggerOption) apply(opts *options) {\n  opts.logger = l.Log\n}\n\nfunc WithLogger(log *zap.Logger) Option {\n  return loggerOption{Log: log}\n}\n\n// Open creates a connection.\nfunc Open(\n  addr string,\n  opts ...Option,\n) (*Connection, error) {\n  options := options{\n    cache:  defaultCache,\n    logger: zap.NewNop(),\n  }\n\n  for _, o := range opts {\n    o.apply(&options)\n  }\n\n  // ...\n}\n")),Object(r.b)("p",null,"Note that there's a method of implementing this pattern with closures but we\nbelieve that the pattern above provides more flexibility for authors and is\neasier to debug and test for users. In particular, it allows options to be\ncompared against each other in tests and mocks, versus closures where this is\nimpossible. Further, it lets options implement other interfaces, including\n",Object(r.b)("inlineCode",{parentName:"p"},"fmt.Stringer")," which allows for user-readable string representations of the\noptions."),Object(r.b)("p",null,"See also,"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"https://commandcenter.blogspot.com/2014/01/self-referential-functions-and-design.html"}),"Self-referential functions and the design of options"))),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"https://dave.cheney.net/2014/10/17/functional-options-for-friendly-apis"}),"Functional options for friendly APIs")))))}s.isMDXComponent=!0}}]);